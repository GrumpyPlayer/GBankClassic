diff --git a/Core.lua b/Core.lua
index 5365e72..5253204 100644
--- a/Core.lua
+++ b/Core.lua
@@ -1,7 +1,16 @@
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("LibStub", "IsInRaid")
+local LibStub = upvalues.LibStub
+local IsInRaid = upvalues.IsInRaid
+
 GBankClassic_Core = LibStub("AceAddon-3.0"):NewAddon("GBankClassic", "AceComm-3.0", "AceConsole-3.0", "AceEvent-3.0", "AceSerializer-3.0", "AceTimer-3.0")
-local AceComm_SendCommMessage = GBankClassic_Core.SendCommMessage
 
-function GBankClassic_Core:SendCommMessage(prefix, text, distribution, target, prio, callbackFn, callbackArg)
+local Core = GBankClassic_Core
+local AceComm_SendCommMessage = Core.SendCommMessage
+
+local CHECKSUM_SEPARATOR = "\030" -- ASCII record separator, not used by AceSerializer
+
+function Core:SendCommMessage(prefix, text, distribution, target, prio, callbackFn, callbackArg)
     local prefixDesc = COMM_PREFIX_DESCRIPTIONS[prefix] or "(Unknown)"
     if IsInRaid() then
         GBankClassic_Output:Debug("COMMS", "< (suppressing) %s %s (in raid)", prefix, prefixDesc)
@@ -19,18 +28,18 @@ function GBankClassic_Core:SendCommMessage(prefix, text, distribution, target, p
     return AceComm_SendCommMessage(self, prefix, text, distribution, target, prio, callbackFn, callbackArg)
 end
 
--- Centralized WHISPER send with automatic online check
+-- Centralized whisper send with automatic online check
 -- Returns true if sent, false if target offline or send failed
-function GBankClassic_Core:SendWhisper(prefix, text, target, prio, callbackFn, callbackArg)
+function Core:SendWhisper(prefix, text, target, prio, callbackFn, callbackArg)
     -- Check if target is online
     if not GBankClassic_Guild:IsPlayerOnline(target) then
-        GBankClassic_Output:Debug("WHISPER", "Cannot send %s WHISPER to %s - player is offline", prefix, target)
+        GBankClassic_Output:Debug("WHISPER", "Cannot send %s whisper to %s - player is offline", prefix, target)
 
         return false
     end
 
-    -- Strip realm suffix for WHISPER (WoW requires name-only)
-    -- Target may be "Name-Realm" format, but WHISPER needs just "Name"
+    -- Strip realm suffix for whisper (WoW requires name-only)
+    -- Target may be "Name-Realm" format, but whisper needs just "Name"
     local nameOnly = target
     if target and string.find(target, "-") then
         nameOnly = string.match(target, "^(.-)%-")
@@ -42,39 +51,36 @@ function GBankClassic_Core:SendWhisper(prefix, text, target, prio, callbackFn, c
     return true
 end
 
-function GBankClassic_Core:OnInitialize()
+function Core:OnInitialize()
     -- Called when the addon is loaded
-    GBankClassic_Output:Init()
-    GBankClassic_Performance:Initialize()
     GBankClassic_Database:Init()
     GBankClassic_Chat:Init()
     GBankClassic_Options:Init()
     GBankClassic_UI:Init()
 
-    -- Initialize module for item highlights
-    if GBankClassic_ItemHighlight and GBankClassic_ItemHighlight.Initialize then
-        GBankClassic_ItemHighlight:Initialize()
-    end
+    -- -- Initialize module for item highlights
+    -- if GBankClassic_ItemHighlight and GBankClassic_ItemHighlight.Initialize then
+    --     GBankClassic_ItemHighlight:Initialize()
+    -- end
 end
 
-function GBankClassic_Core:OnEnable()
+function Core:OnEnable()
     -- Called when the addon is enabled
     GBankClassic_Events:RegisterEvents()
 end
 
-function GBankClassic_Core:OnDisable()
+function Core:OnDisable()
     -- Called when the addon is disabled
     GBankClassic_Events:UnregisterEvents()
 end
 
 -- Checksum implementation for message integrity
 -- Uses a simple but effective hash that detects corruption
-local CHECKSUM_SEPARATOR = "\030" -- ASCII record separator, not used by AceSerializer
-
-local function ComputeChecksum(str)
+local function computeChecksum(str)
     if not str or type(str) ~= "string" then
         return 0
     end
+
     -- Simple additive checksum with bit mixing for better distribution
     local sum = 0
     local len = #str
@@ -84,21 +90,29 @@ local function ComputeChecksum(str)
     end
     -- Include length to catch truncation
     sum = (sum * 31 + len) % 2147483647
+
     return sum
 end
 
+-- Expose as public method for DeltaComms
+function Core:Checksum(str)
+    return computeChecksum(str)
+end
+
 -- Serialize data with appended checksum for integrity verification
-function GBankClassic_Core:SerializeWithChecksum(data)
+function Core:SerializeWithChecksum(data)
     local serialized = self:Serialize(data)
     if not serialized then
         return nil
     end
-    local checksum = ComputeChecksum(serialized)
+
+    local checksum = computeChecksum(serialized)
+    
     return serialized .. CHECKSUM_SEPARATOR .. tostring(checksum)
 end
 
 -- Deserialize data and verify checksum; returns success, data (or nil, error)
-function GBankClassic_Core:DeserializeWithChecksum(message)
+function Core:DeserializeWithChecksum(message)
     if not message or type(message) ~= "string" then
         return false, "invalid message"
     end
@@ -118,31 +132,10 @@ function GBankClassic_Core:DeserializeWithChecksum(message)
         return false, "invalid checksum format"
     end
 
-    local actualChecksum = ComputeChecksum(serialized)
+    local actualChecksum = computeChecksum(serialized)
     if actualChecksum ~= expectedChecksum then
         return false, "checksum mismatch (expected " .. expectedChecksum .. ", got " .. actualChecksum .. ")"
     end
 
     return self:Deserialize(serialized)
-end
-
--- Delta functions
-function GBankClassic_Core:ValidateDeltaStructure(delta)
-	return GBankClassic_DeltaComms:ValidateDeltaStructure(delta)
-end
-
-function GBankClassic_Core:ValidateItemDelta(itemDelta)
-	return GBankClassic_DeltaComms:ValidateItemDelta(itemDelta)
-end
-
-function GBankClassic_Core:SanitizeDelta(delta)
-	return GBankClassic_DeltaComms:SanitizeDelta(delta)
-end
-
-function GBankClassic_Core:SanitizeItemDelta(itemDelta)
-	return GBankClassic_DeltaComms:SanitizeItemDelta(itemDelta)
-end
-
-function GBankClassic_Core:ComputeInventoryHash(bank, bags, money)
-	return GBankClassic_DeltaComms:ComputeInventoryHash(bank, bags, money)
 end
\ No newline at end of file
diff --git a/GBankClassic.toc b/GBankClassic.toc
index a96ee8d..d798e04 100644
--- a/GBankClassic.toc
+++ b/GBankClassic.toc
@@ -2,8 +2,8 @@
 ## Title: GBankClassic - Revived
 ## Notes: A simple way to aggregate and view the inventories of multiple guild bank alts.
 ## Author: Dominion-Myzrael, GrumpyPlayers (also known as <SG>Soul), Lothsahn, Huntmehuntme-Myzrael, Pimptasty
-## Version: 2.5.1
-## SavedVariables: GBankClassicDB, GBankClassicIconDB, GBankClassicOptionDB, GBankClassicDebugLogEnabled, GBankClassicDebugLog, GBankClassicPerfMetricsEnabled, GBankClassicPerfMetrics
+## Version: 2.6.0
+## SavedVariables: GBankClassicDB, GBankClassicIconDB, GBankClassicOptionDB
 ## OptionalDeps: Ace3
 ## X-Embeds: Ace3
 ## X-Curse-Project-ID: 807339
@@ -11,24 +11,30 @@
 # Libraries
 embeds.xml
 
+# Globals and shared functions
+Globals.lua
+
 # Modules
 Modules/Constants.lua
 Modules/Output.lua
-Modules/Performance.lua
 Modules/DeltaComms.lua
 Modules/Bank.lua
 Modules/Chat.lua
 Modules/Database.lua
 Modules/Events.lua
 Modules/Guild.lua
+Modules/RequestLog.lua
 Modules/Item.lua
+Modules/ItemHighlight.lua
 Modules/Mail.lua
+Modules/MailInventory.lua
 Modules/Options.lua
 Modules/UI.lua
 Modules/UI/Donations.lua
 Modules/UI/Inventory.lua
 Modules/UI/Mail.lua
 Modules/UI/Minimap.lua
+Modules/UI/Requests.lua
 Modules/UI/Search.lua
 Modules/Tests.lua
 
diff --git a/Globals.lua b/Globals.lua
new file mode 100644
index 0000000..48ed9dd
--- /dev/null
+++ b/Globals.lua
@@ -0,0 +1,229 @@
+GBankClassic_Globals = GBankClassic_Globals or {}
+
+local Globals = GBankClassic_Globals
+
+-- Globals
+
+-- WoW Lua APIs
+local debugprofilestop = debugprofilestop
+local hooksecurefunc = hooksecurefunc
+local date = date
+local time = time
+local wipe = wipe
+Globals.debugprofilestop = debugprofilestop
+Globals.hooksecurefunc = hooksecurefunc
+Globals.date = date
+Globals.time = time
+Globals.wipe = wipe
+
+-- WoW APIs
+local IsInRaid = IsInRaid
+local IsInGuild = IsInGuild
+local IsShiftKeyDown = IsShiftKeyDown
+local IsControlKeyDown = IsControlKeyDown
+Globals.IsInRaid = IsInRaid
+Globals.IsInGuild = IsInGuild
+Globals.IsShiftKeyDown = IsShiftKeyDown
+Globals.IsControlKeyDown = IsControlKeyDown
+local FCF_DockFrame = FCF_DockFrame
+local FCF_ResetChatWindows = FCF_ResetChatWindows
+local FCF_SetLocked = FCF_SetLocked
+local FCF_SetWindowColor = FCF_SetWindowColor
+local FCF_SetWindowName = FCF_SetWindowName
+Globals.FCF_DockFrame = FCF_DockFrame
+Globals.FCF_ResetChatWindows = FCF_ResetChatWindows
+Globals.FCF_SetLocked = FCF_SetLocked
+Globals.FCF_SetWindowColor = FCF_SetWindowColor
+Globals.FCF_SetWindowName = FCF_SetWindowName
+local ChatFrame_RemoveAllMessageGroups = ChatFrame_RemoveAllMessageGroups
+local GetChatWindowInfo = GetChatWindowInfo
+local CreateFrame = CreateFrame
+local ChatFrame_RemoveAllChannels = ChatFrame_RemoveAllChannels
+local ChatEdit_InsertLink = ChatEdit_InsertLink
+local StaticPopup_Show = StaticPopup_Show
+local GameTooltip_SetDefaultAnchor = GameTooltip_SetDefaultAnchor
+Globals.ChatFrame_RemoveAllMessageGroups = ChatFrame_RemoveAllMessageGroups
+Globals.GetChatWindowInfo = GetChatWindowInfo
+Globals.CreateFrame = CreateFrame
+Globals.ChatFrame_RemoveAllChannels = ChatFrame_RemoveAllChannels
+Globals.ChatEdit_InsertLink = ChatEdit_InsertLink
+Globals.StaticPopup_Show = StaticPopup_Show
+Globals.GameTooltip_SetDefaultAnchor = GameTooltip_SetDefaultAnchor
+local GetCursorInfo = GetCursorInfo
+local ClearCursor = ClearCursor
+local ClickSendMailItemButton = ClickSendMailItemButton
+local PickupItem = PickupItem or C_Container.PickupItem
+local PickupContainerItem = PickupContainerItem or C_Container.PickupContainerItem
+local CheckInbox = CheckInbox
+local TakeInboxItem = TakeInboxItem
+local TakeInboxMoney = TakeInboxMoney
+local DressUpItemLink = DressUpItemLink
+Globals.GetCursorInfo = GetCursorInfo
+Globals.ClearCursor = ClearCursor
+Globals.ClickSendMailItemButton = ClickSendMailItemButton
+Globals.PickupItem = PickupItem
+Globals.PickupContainerItem = PickupContainerItem
+Globals.CheckInbox = CheckInbox
+Globals.TakeInboxItem = TakeInboxItem
+Globals.TakeInboxMoney = TakeInboxMoney
+Globals.DressUpItemLink = DressUpItemLink
+local GuildRoster = GuildRoster or C_GuildInfo.GuildRoster
+local GetGuildInfo = GetGuildInfo
+local GetNumGuildMembers = GetNumGuildMembers or C_GuildInfo.GetNumGuildMembers
+local GetGuildRosterInfo = GetGuildRosterInfo or C_GuildInfo.GetGuildRosterInfo
+local CanViewOfficerNote = CanViewOfficerNote or C_GuildInfo.CanViewOfficerNote
+Globals.GuildRoster = GuildRoster
+Globals.GetGuildInfo = GetGuildInfo
+Globals.GetNumGuildMembers = GetNumGuildMembers
+Globals.GetGuildRosterInfo = GetGuildRosterInfo
+Globals.CanViewOfficerNote = CanViewOfficerNote
+local GetItemNameByID = GetItemNameByID or C_Item.GetItemNameByID
+local GetItemInfo = GetItemInfo or C_Item.GetItemInfo
+local GetItemInfoInstant = GetItemInfoInstant or C_Item.GetItemInfoInstant
+local GetItemQualityColor = GetItemQualityColor or C_Item.GetItemQualityColor
+local GetItemInventoryTypeByID = GetItemInventoryTypeByID or C_Item.GetItemInventoryTypeByID
+Globals.GetItemNameByID = GetItemNameByID
+Globals.GetItemInfo = GetItemInfo
+Globals.GetItemInfoInstant = GetItemInfoInstant
+Globals.GetItemQualityColor = GetItemQualityColor
+Globals.GetItemInventoryTypeByID = GetItemInventoryTypeByID
+local GetInboxHeaderInfo = GetInboxHeaderInfo
+local GetInboxItem = GetInboxItem
+local GetInboxText = GetInboxText
+local GetInboxItemLink = GetInboxItemLink
+local GetInboxNumItems = GetInboxNumItems
+local GetSendMailItem = GetSendMailItem
+Globals.GetInboxHeaderInfo = GetInboxHeaderInfo
+Globals.GetInboxItem = GetInboxItem
+Globals.GetInboxText = GetInboxText
+Globals.GetInboxItemLink = GetInboxItemLink
+Globals.GetInboxNumItems = GetInboxNumItems
+Globals.GetSendMailItem = GetSendMailItem
+local GetMoney = GetMoney
+local GetCoinTextureString = GetCoinTextureString or C_CurrencyInfo.GetCoinTextureString
+local GetContainerNumFreeSlots = GetContainerNumFreeSlots or C_Container.GetContainerNumFreeSlots
+local GetContainerItemInfo = GetContainerItemInfo or C_Container.GetContainerItemInfo
+local GetContainerNumSlots = GetContainerNumSlots or C_Container.GetContainerNumSlots
+Globals.GetMoney = GetMoney
+Globals.GetCoinTextureString = GetCoinTextureString
+Globals.GetContainerNumFreeSlots = GetContainerNumFreeSlots
+Globals.GetContainerItemInfo = GetContainerItemInfo
+Globals.GetContainerNumSlots = GetContainerNumSlots
+local GetAddOnMetadata = GetAddOnMetadata or C_AddOns.GetAddOnMetadata
+local UnitName = UnitName
+local GetNormalizedRealmName = GetNormalizedRealmName
+local GetRealmName = GetRealmName
+local GetClassColor = GetClassColor or C_ClassColor.GetClassColor
+Globals.GetAddOnMetadata = GetAddOnMetadata
+Globals.UnitName = UnitName
+Globals.GetNormalizedRealmName = GetNormalizedRealmName
+Globals.GetRealmName = GetRealmName
+Globals.GetClassColor = GetClassColor
+local GetServerTime = GetServerTime
+local GetTime = GetTime
+local SecondsToTime = SecondsToTime
+Globals.GetServerTime = GetServerTime or C_DateAndTime.GetServerTime
+Globals.GetTime = GetTime
+Globals.SecondsToTime = SecondsToTime
+local After = After or C_Timer.After
+local NewTicker = NewTicker or C_Timer.NewTicker
+local NewTimer = NewTimer or C_Timer.NewTimer
+Globals.After = After
+Globals.NewTicker = NewTicker
+Globals.NewTimer = NewTimer
+
+-- WoW global tables
+local GameFontNormal = GameFontNormal
+local GameTooltip = GameTooltip
+local SendMailNameEditBox = SendMailNameEditBox
+local Settings = Settings
+local BankFrame = BankFrame
+local MailFrame = MailFrame
+local UIParent = UIParent
+local UISpecialFrames = UISpecialFrames
+local WorldFrame = WorldFrame
+Globals.GameFontNormal = GameFontNormal
+Globals.GameTooltip = GameTooltip
+Globals.SendMailNameEditBox = SendMailNameEditBox
+Globals.Settings = Settings
+Globals.BankFrame = BankFrame
+Globals.MailFrame = MailFrame
+Globals.UIParent = UIParent
+Globals.UISpecialFrames = UISpecialFrames
+Globals.WorldFrame = WorldFrame
+
+-- WoW global variables
+local ATTACHMENTS_MAX_RECEIVE = ATTACHMENTS_MAX_RECEIVE
+local ATTACHMENTS_MAX_SEND = ATTACHMENTS_MAX_SEND
+local BANK_CONTAINER = BANK_CONTAINER
+local ITEM_UNIQUE = ITEM_UNIQUE
+local NUM_CHAT_WINDOWS = NUM_CHAT_WINDOWS
+local NUM_BANKGENERIC_SLOTS = NUM_BANKGENERIC_SLOTS
+Globals.ATTACHMENTS_MAX_RECEIVE = ATTACHMENTS_MAX_RECEIVE
+Globals.ATTACHMENTS_MAX_SEND = ATTACHMENTS_MAX_SEND
+Globals.BANK_CONTAINER = BANK_CONTAINER
+Globals.ITEM_UNIQUE = ITEM_UNIQUE
+Globals.NUM_CHAT_WINDOWS = NUM_CHAT_WINDOWS
+Globals.NUM_BANKGENERIC_SLOTS = NUM_BANKGENERIC_SLOTS
+
+-- Embedded libraries or other AddOns
+local LibStub = LibStub
+local Bagnon = Bagnon
+local BagBrother = BagBrother
+Globals.LibStub = LibStub
+Globals.Bagnon = Bagnon
+Globals.BagBrother = BagBrother
+
+-- Helper function that returns upvalues
+function Globals.GetUpvalues(...)
+    local keys = {...}
+    local result = {}
+    for _, key in ipairs(keys) do
+        result[key] = Globals[key] or _G[key]
+    end
+
+    return result
+end
+
+-- Helpers
+
+-- Generic helpers to count entries in tables
+function Globals:CountTableEntries(tbl)
+    if not tbl or type(tbl) ~= "table" then
+        return 0
+    end
+
+    local n = 0
+    for _ in pairs(tbl) do
+        n = n + 1
+    end
+
+    return n
+end
+
+-- Generic helpers to count entries in array
+function Globals:CountArrayEntries(tbl)
+    if not tbl or type(tbl) ~= "table" then
+        return 0
+    end
+
+    local n = 0
+    for _ in ipairs(tbl) do
+        n = n + 1
+    end
+
+    return n
+end
+
+-- Smart count: uses array counting when it looks list-like (`tbl[1]`), otherwise counts by pairs
+function Globals:Count(tbl)
+    if not tbl or type(tbl) ~= "table" then
+        return 0
+    end
+
+    if tbl[1] ~= nil then
+        return self:CountArrayEntries(tbl)
+    end
+
+    return self:CountTableEntries(tbl)
+end
\ No newline at end of file
diff --git a/Modules/Bank.lua b/Modules/Bank.lua
index 72eb729..80a4cf5 100644
--- a/Modules/Bank.lua
+++ b/Modules/Bank.lua
@@ -1,21 +1,34 @@
-GBankClassic_Bank = { ... }
+GBankClassic_Bank = GBankClassic_Bank or {}
 
-local function IsBankAvailable()
-    local _, bagType = C_Container.GetContainerNumFreeSlots(BANK_CONTAINER)
+local Bank = GBankClassic_Bank
+
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("GetContainerNumFreeSlots", "GetContainerItemInfo", "GetContainerNumSlots", "GetMoney", "GetServerTime")
+local GetContainerNumFreeSlots = upvalues.GetContainerNumFreeSlots
+local GetContainerItemInfo = upvalues.GetContainerItemInfo
+local GetContainerNumSlots = upvalues.GetContainerNumSlots
+local GetMoney = upvalues.GetMoney
+local GetServerTime = upvalues.GetServerTime
+local upvalues = Globals.GetUpvalues("BANK_CONTAINER", "NUM_BANKGENERIC_SLOTS")
+local BANK_CONTAINER = upvalues.BANK_CONTAINER
+local NUM_BANKGENERIC_SLOTS = upvalues.NUM_BANKGENERIC_SLOTS
+
+local function isBankAvailable()
+    local _, bagType = GetContainerNumFreeSlots(BANK_CONTAINER)
 
     return bagType ~= nil
 end
 
-local function HasUpdated()
-    return GBankClassic_Bank.hasUpdated
+local function hasUpdated()
+    return Bank.hasUpdated
 end
 
-local function ScanBag(bag, slots)
+local function scanBag(bag, slots)
     local count = 0
     local items = {}
 
     for slot = 1, slots do
-        local itemInfo = C_Container.GetContainerItemInfo(bag, slot)
+        local itemInfo = GetContainerItemInfo(bag, slot)
         if itemInfo then 
             local itemCount = itemInfo.stackCount
             local itemLink = itemInfo.hyperlink
@@ -36,14 +49,14 @@ local function ScanBag(bag, slots)
     return count, items
 end
 
-local function ScanBags(bag_info)
+local function scanBags(bag_info)
     local total = 0
     local numslots = 0
     local bagItems = nil
 
     for bag = 0, 4 do
-        local slots = C_Container.GetContainerNumSlots(bag)
-        local count, items = ScanBag(bag, slots)
+        local slots = GetContainerNumSlots(bag)
+        local count, items = scanBag(bag, slots)
         if bagItems == nil then
             bagItems = items
         else
@@ -67,13 +80,13 @@ local function ScanBags(bag_info)
     return total, numslots
 end
 
-local function ScanBank(bank_info)
+local function scanBank(bank_info)
     local numslots = NUM_BANKGENERIC_SLOTS
-    local total, bankItems = ScanBag(BANK_CONTAINER, NUM_BANKGENERIC_SLOTS)
+    local total, bankItems = scanBag(BANK_CONTAINER, NUM_BANKGENERIC_SLOTS)
 
     for bag = 5, 11 do
-        local slots = C_Container.GetContainerNumSlots(bag)
-        local count, items = ScanBag(bag, slots)
+        local slots = GetContainerNumSlots(bag)
+        local count, items = scanBag(bag, slots)
         for k, v in pairs(items) do
             if bankItems[k] then
                 local item = bankItems[k]
@@ -93,9 +106,9 @@ local function ScanBank(bank_info)
     return total, numslots
 end
 
-function GBankClassic_Bank:Scan()
-    if GBankClassic_Bank.eventsRegistered then
-        if not HasUpdated() then
+function Bank:Scan()
+    if Bank.eventsRegistered then
+        if not hasUpdated() then
             return
         end
     end
@@ -128,6 +141,7 @@ function GBankClassic_Bank:Scan()
 		return
 	end
 
+	-- Roster sync (because some players may be unable to view officer notes defining guild bank alts)
     local updateRoster = false
     if info.roster["version"] ~= nil then
         if table.concat(banks) ~= table.concat(info.roster.alts) then
@@ -142,16 +156,17 @@ function GBankClassic_Bank:Scan()
     end
 
 	local alt = {}
-	if info.alts[player] then
+	-- Load from aggregate view (info.alts)
+	if info.alts and info.alts[player] then
 		alt = info.alts[player]
 	end
 
-	if IsBankAvailable() then
+	if isBankAvailable() then
 		alt.bank = {
 			items = {},
 			slots = {},
 		}
-		local count, slots = ScanBank(alt.bank.items)
+		local count, slots = scanBank(alt.bank.items)
 		alt.bank.slots = { count = count, total = slots }
 	end
 
@@ -159,52 +174,310 @@ function GBankClassic_Bank:Scan()
 		items = {},
 		slots = {},
 	}
-	local count, slots = ScanBags(alt.bags.items)
+	local count, slots = scanBags(alt.bags.items)
 	alt.bags.slots = { count = count, total = slots }
 
 	local money = GetMoney()
 	alt.money = money
 
-	local currentHash = GBankClassic_Core:ComputeInventoryHash(alt.bank, alt.bags, money)
+	-- Scan mail inventory if mail was accessed
+	GBankClassic_Output:Debug("MAIL", "Bank:Scan() for player '%s', hasUpdated=%s", player, tostring(GBankClassic_MailInventory.hasUpdated))
+	
+	if GBankClassic_MailInventory.hasUpdated then
+		GBankClassic_Output:Debug("MAIL", "Starting mail scan for player '%s'", player)
+		
+		local mailData = GBankClassic_MailInventory:ScanMailInventory()
+		if mailData then
+			local itemCount = GBankClassic_Globals:Count(mailData.items)
+			
+			-- Check if alt.mail already exists
+			local hadPreviousMail = alt.mail ~= nil
+			local previousItemCount = 0
+			if hadPreviousMail and alt.mail.items then
+				previousItemCount = #alt.mail.items
+			end
+			
+			GBankClassic_Output:Debug("MAIL", "Replacing mail data for '%s': old=%d items, new=%d items", player, previousItemCount, itemCount)
+			
+			alt.mail = mailData
+			GBankClassic_Output:Debug("MAIL", "Assigned alt.mail with %d items, version=%s, lastScan=%s", #mailData.items, tostring(mailData.version), tostring(mailData.lastScan))
+			
+			-- Verify assignment worked
+			if alt.mail then
+				GBankClassic_Output:Debug("MAIL", "Confirmed: alt.mail exists with %d items", #alt.mail.items)
+			else
+				GBankClassic_Output:Debug("MAIL", "ERROR: alt.mail is nil after assignment!")
+			end
+		end
+		
+		GBankClassic_Output:Debug("MAIL", "Clearing hasUpdated flag after scan")
+		GBankClassic_MailInventory.hasUpdated = false
+	end
+
+	-- Aggregate bank + bags + mail into alt.items for sync and display
+	local bankItems = (alt.bank and alt.bank.items) or {}
+	local bagItems = (alt.bags and alt.bags.items) or {}
+	local mailItems = (alt.mail and alt.mail.items) or {}
+	
+	-- Log sample counts from SOURCE arrays before aggregation
+	if #bankItems > 0 then
+		local bankSample = {}
+		for i = 1, math.min(3, #bankItems) do
+			local item = bankItems[i]
+			if item then
+				table.insert(bankSample, string.format("%s:%d", item.ID or "?", item.Count or 0))
+			end
+		end
+		GBankClassic_Output:Debug("DATABASE", "  bank.items (first 3): %s", table.concat(bankSample, ", "))
+	end
+	if #bagItems > 0 then
+		local bagSample = {}
+		for i = 1, math.min(3, #bagItems) do
+			local item = bagItems[i]
+			if item then
+				table.insert(bagSample, string.format("%s:%d", item.ID or "?", item.Count or 0))
+			end
+		end
+		GBankClassic_Output:Debug("DATABASE", "  bags.items (first 3): %s", table.concat(bagSample, ", "))
+	end
+	if #mailItems > 0 then
+		local mailSample = {}
+		for i = 1, math.min(3, #mailItems) do
+			local item = mailItems[i]
+			if item then
+				table.insert(mailSample, string.format("%s:%d", item.ID or "?", item.Count or 0))
+			end
+		end
+		GBankClassic_Output:Debug("DATABASE", "  mail.items (first 3): %s", table.concat(mailSample, ", "))
+	end
+	
+	-- Aggregate all three sources (returns table with composite keys, deduplicates by ID)
+	local aggregated = GBankClassic_Item:Aggregate(bankItems, bagItems)
+	aggregated = GBankClassic_Item:Aggregate(aggregated, mailItems)
+	
+	-- Convert back to array format for storage/sync/display
+	alt.items = {}
+	for _, item in pairs(aggregated) do
+		table.insert(alt.items, item)
+	end
+	
+	-- Log sample counts after aggregation
+	if alt.items and #alt.items > 0 then
+		local scanSample = {}
+		for i = 1, math.min(5, #alt.items) do
+			local item = alt.items[i]
+			if item then
+				table.insert(scanSample, string.format("%s:%d", item.ID or "?", item.Count or 0))
+			end
+		end
+		GBankClassic_Output:Debug("DATABASE", "After scan aggregation - First 5 items: %s", table.concat(scanSample, ", "))
+	end
+	
+	-- Also clean up source arrays to remove any duplicates (in case of corrupted data)
+	-- This ensures future scans start fresh
+	if alt.bank and alt.bank.items then
+		local cleanBank = {}
+		local bankAgg = GBankClassic_Item:Aggregate(alt.bank.items, nil)
+		for _, item in pairs(bankAgg) do
+			table.insert(cleanBank, item)
+		end
+		alt.bank.items = cleanBank
+	end
+	if alt.bags and alt.bags.items then
+		local cleanBags = {}
+		local bagsAgg = GBankClassic_Item:Aggregate(alt.bags.items, nil)
+		for _, item in pairs(bagsAgg) do
+			table.insert(cleanBags, item)
+		end
+		alt.bags.items = cleanBags
+	end
+
+	-- Only update version if inventory actually changed
+	-- Compute a hash of the current inventory state (use aggregated alt.items)
+	local currentHash = GBankClassic_DeltaComms:ComputeInventoryHash(alt.items, nil, nil, money)
 	local previousHash = alt.inventoryHash
 
 	if currentHash ~= previousHash then
 		-- Inventory changed, update version timestamp
 		alt.version = GetServerTime()
 		alt.inventoryHash = currentHash
-		GBankClassic_Output:Debug("SYNC", "Inventory changed for %s, version updated to %d", player, alt.version)
+		GBankClassic_Output:Debug("SYNC", "Inventory changed for %s, version updated to %d (hash: %s)", player, alt.version, tostring(currentHash))
 	else
 		-- No changes detected, preserve existing version
-		GBankClassic_Output:Debug("SYNC", "No inventory changes for %s, version unchanged", player)
+		GBankClassic_Output:Debug("SYNC", "No inventory changes for %s, version unchanged (hash: %s)", player, tostring(currentHash))
 	end
 
 	if not info.alts then
 		info.alts = {}
 	end
 
+	-- Log what we're about to save
+	if alt.mail then
+		GBankClassic_Output:Debug("MAIL", "alt.mail exists with %d items, type=%s", #alt.mail.items, type(alt.mail))
+		-- Handle both old format (number) and new format (table)
+		if type(alt.mail.slots) == "table" then
+			GBankClassic_Output:Debug("MAIL", "alt.mail.slots = table with count=%d", alt.mail.slots.count)
+		elseif type(alt.mail.slots) == "number" then
+			GBankClassic_Output:Debug("MAIL", "alt.mail.slots = %d (old format, migrating)", alt.mail.slots)
+			-- Migrate old format to new format
+			local oldSlots = alt.mail.slots
+			alt.mail.slots = { count = #alt.mail.items, total = oldSlots }
+		else
+			GBankClassic_Output:Debug("MAIL", "alt.mail.slots = nil")
+		end
+	end
+
+	-- Write to aggregate view (info.alts) for normal use
 	info.alts[player] = alt
+	
+	if alt.mail then
+		GBankClassic_Output:Debug("MAIL", "Saved mail to info.alts[%s] (%d items)", player, #alt.mail.items)
+	else
+		GBankClassic_Output:Debug("MAIL", "No mail data to save for %s", player)
+	end
 
-    -- Share updated inventory with guild
-    GBankClassic_Guild:Share() --TODO: decide to remove?
+    -- Always share inventory with guild after a scan
+    GBankClassic_Guild:Share()
 end
 
-function GBankClassic_Bank:HasInventorySpace()
+function Bank:HasInventorySpace()
     local total = 0
     for bag = 0, 4 do
-        local slots, _ = C_Container.GetContainerNumFreeSlots(bag)
+        local slots, _ = GetContainerNumFreeSlots(bag)
         total = total + slots
     end
 
     return total > 0
 end
 
-function GBankClassic_Bank:OnUpdateStart()
+-- -- Find all slots containing an item by name (case-insensitive)
+-- -- Returns: table of {bag, slot, count, link}
+-- function Bank:FindItemsByName(itemName)
+-- 	local results = {}
+-- 	if not itemName or itemName == "" then
+-- 		return results
+-- 	end
+
+-- 	local targetName = string.lower(itemName)
+
+-- 	for bag = 0, 4 do
+-- 		local slots = GetContainerNumSlots(bag)
+-- 		for slot = 1, slots do
+-- 			local itemInfo = GetContainerItemInfo(bag, slot)
+-- 			if itemInfo and itemInfo.hyperlink then
+-- 				local name = GetItemInfo(itemInfo.hyperlink)
+-- 				if name and string.lower(name) == targetName then
+-- 					table.insert(results, { bag = bag, slot = slot, count = itemInfo.stackCount or 1, link = itemInfo.hyperlink })
+-- 				end
+-- 			end
+-- 		end
+-- 	end
+
+-- 	return results
+-- end
+
+-- -- Count total of named item in bags (0-4)
+-- -- Returns: totalCount, itemsTable
+-- function Bank:CountItemInBags(itemName)
+-- 	local items = self:FindItemsByName(itemName)
+-- 	local total = 0
+-- 	for _, item in ipairs(items) do
+-- 		total = total + item.count
+-- 	end
+    
+-- 	return total, items
+-- end
+
+function Bank:OnUpdateStart()
     self.hasUpdated = true
 end
 
-function GBankClassic_Bank:OnUpdateStop()
+function Bank:OnUpdateStop()
+	GBankClassic_Output:Debug("INVENTORY", "OnUpdateStop called, hasUpdated=%s", tostring(self.hasUpdated))
     if self.hasUpdated then
+		GBankClassic_Output:Debug("INVENTORY", "Calling scan")
         self:Scan()
+		GBankClassic_Output:Debug("INVENTORY", "Scan completed")
+	else
+		GBankClassic_Output:Debug("INVENTORY", "Skipping scan because hasUpdated is false")
     end
     self.hasUpdated = false
+end
+
+-- Recalculate alt.items from existing bank/bags/mail data
+-- Used to fix aggregation without requiring a full scan
+function Bank:RecalculateAggregatedItems(alt)
+	if not alt then
+		return
+	end
+
+	-- First deduplicate source data (bank/bags) in case they have duplicates
+	local bankItems = {}
+	if alt.bank and alt.bank.items then
+		local deduped = GBankClassic_Item:Aggregate(alt.bank.items, nil)
+		for _, item in pairs(deduped) do
+			table.insert(bankItems, item)
+		end
+		-- Write deduplicated bank items back to source to fix SV file
+		alt.bank.items = bankItems
+	end
+	
+	local bagItems = {}
+	if alt.bags and alt.bags.items then
+		local deduped = GBankClassic_Item:Aggregate(alt.bags.items, nil)
+		for _, item in pairs(deduped) do
+			table.insert(bagItems, item)
+		end
+		-- Write deduplicated bag items back to source to fix SV file
+		alt.bags.items = bagItems
+	end
+	
+	local mailItems = {}
+	if alt.mail and alt.mail.items then
+		GBankClassic_Output:Debug("MAIL", "Before dedupe: mail has %d entries", #alt.mail.items)
+		-- Check for duplicates before deduplication
+		local mailByID = {}
+		for i, item in ipairs(alt.mail.items) do
+			if item and item.ID then
+				if not mailByID[item.ID] then
+					mailByID[item.ID] = {}
+				end
+				table.insert(mailByID[item.ID], { index = i, Count = item.Count, Link = item.Link })
+			end
+		end
+		for itemID, entries in pairs(mailByID) do
+			if #entries > 1 then
+				GBankClassic_Output:Debug("MAIL", "Before dedupe: mail item ID %d has %d entries", itemID, #entries)
+				for _, entry in ipairs(entries) do
+					GBankClassic_Output:Debug("MAIL", "  index=%d count=%d link=%s", entry.index, entry.Count, entry.Link or "nil")
+				end
+			end
+		end
+		
+		-- Mail items are now stored as array (same as bank/bags)
+		local deduped = GBankClassic_Item:Aggregate(alt.mail.items, nil)
+		for _, item in pairs(deduped) do
+			table.insert(mailItems, item)
+		end
+		GBankClassic_Output:Debug("MAIL", "After dedupe: mail has %d entries", #mailItems)
+		-- Write deduplicated mail items back to source to fix SV file
+		alt.mail.items = mailItems
+	end
+	
+	-- Aggregate all three sources
+	GBankClassic_Output:Debug("INVENTORY", "Aggregating: bank=%d, bags=%d, mail=%d", #bankItems, #bagItems, #mailItems)
+	local aggregated = GBankClassic_Item:Aggregate(bankItems, bagItems)
+	GBankClassic_Output:Debug("INVENTORY", "After bank+bags aggregate: %d unique items", GBankClassic_Globals:Count(aggregated))
+	aggregated = GBankClassic_Item:Aggregate(aggregated, mailItems)
+	GBankClassic_Output:Debug("INVENTORY", "After adding mail: %d unique items", GBankClassic_Globals:Count(aggregated))
+	
+	-- Convert back to array format
+	alt.items = {}
+	for _, item in pairs(aggregated) do
+		if item.ID then
+			table.insert(alt.items, item)
+		end
+	end
+	
+	GBankClassic_Output:Debug("INVENTORY", "Recalculated aggregated items: bank=%d, bags=%d, mail=%d, total=%d", #bankItems, #bagItems, #mailItems, #alt.items)
 end
\ No newline at end of file
diff --git a/Modules/Chat.lua b/Modules/Chat.lua
index ada2749..15baa23 100644
--- a/Modules/Chat.lua
+++ b/Modules/Chat.lua
@@ -1,12 +1,23 @@
-GBankClassic_Chat = {}
+GBankClassic_Chat = GBankClassic_Chat or {}
 
--- Store pre-debug log level for restoration
+local Chat = GBankClassic_Chat
 local preDebugLogLevel = nil
 
-function GBankClassic_Chat:Init()
-	GBankClassic_Output:Debug("PROTOCOL", "[INIT] GBankClassic_Chat:Init() starting")
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("time", "date")
+local time = upvalues.time
+local date = upvalues.date
+local upvalues = Globals.GetUpvalues("GetClassColor", "IsInRaid", "After", "GetServerTime", "GetAddOnMetadata")
+local GetClassColor = upvalues.GetClassColor
+local IsInRaid = upvalues.IsInRaid
+local After = upvalues.After
+local GetServerTime = upvalues.GetServerTime
+local GetAddOnMetadata = upvalues.GetAddOnMetadata
+
+function Chat:Init()
+	GBankClassic_Output:Debug("PROTOCOL", "GBankClassic_Chat:Init() starting")
     GBankClassic_Core:RegisterChatCommand("bank", function(input)
-        return GBankClassic_Chat:ChatCommand(input)
+        return self:ChatCommand(input)
     end)
 
     self.addon_outdated = false
@@ -18,100 +29,124 @@ function GBankClassic_Chat:Init()
 	self.sync_queue = {}
 	self.is_syncing = false
 	self.last_share_sync = nil
-
-    -- Version
-    GBankClassic_Core:RegisterComm("gbank-v", function(prefix, message, distribution, sender)
-        GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
-    end)
-    -- Delta version
-	GBankClassic_Output:Debug("PROTOCOL", "[INIT] Registering gbank-dv handler")
-	GBankClassic_Core:RegisterComm("gbank-dv", function(prefix, message, distribution, sender)
-		GBankClassic_Output:Debug("PROTOCOL", "[HANDLER] gbank-dv called: %s from %s (%d bytes)", prefix, sender, #message)
-		GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
-	end)
-
-    -- Data (no links)
+	
+	-- Protocol prioritization: delay legacy dv processing to allow dv2 to arrive first
+	self.pending_dv_messages = {} -- {sender = {altName = {timer, data, ...}}}
+	self.DV_DELAY = 5 -- Seconds to wait before processing legacy dv messages
+
+	-- Unused: togbank-d
+	-- Unused: togbank-d2
+    -- Data (no links): togbank-d3 -> gbank-d
 	GBankClassic_Core:RegisterComm("gbank-d", function(prefix, message, distribution, sender)
-		GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
+		self:OnCommReceived(prefix, message, distribution, sender)
 	end)
-    -- Delta data (no links)
+    -- Delta data (no links): togbank-d4 -> gbank-dd
 	GBankClassic_Core:RegisterComm("gbank-dd", function(prefix, message, distribution, sender)
-		GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
+		self:OnCommReceived(prefix, message, distribution, sender)
 	end)
 
-    -- Delta range request
-	GBankClassic_Core:RegisterComm("gbank-dr", function(prefix, message, distribution, sender)
-		GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
+	-- -- Request mutations (add/cancel/complete)
+	-- -- Uses separate throttle bucket to prevent BULK messages from blocking ALERT mutations
+	-- GBankClassic_Core:RegisterComm("gbank-rm", function(prefix, message, distribution, sender)
+	-- 	self:OnCommReceived(prefix, message, distribution, sender)
+	-- end)
+
+    -- -- Delta range request
+	-- GBankClassic_Core:RegisterComm("gbank-dr", function(prefix, message, distribution, sender)
+	-- 	self:OnCommReceived(prefix, message, distribution, sender)
+	-- end)
+    -- -- Delta chain
+	-- GBankClassic_Core:RegisterComm("gbank-dc", function(prefix, message, distribution, sender)
+	-- 	self:OnCommReceived(prefix, message, distribution, sender)
+	-- end)
+
+    -- Version
+    GBankClassic_Core:RegisterComm("gbank-v", function(prefix, message, distribution, sender)
+        self:OnCommReceived(prefix, message, distribution, sender)
+    end)
+    -- Delta version (legacy)
+	GBankClassic_Output:Debug("PROTOCOL", "Registering gbank-dv handler")
+	GBankClassic_Core:RegisterComm("gbank-dv", function(prefix, message, distribution, sender)
+		GBankClassic_Output:Debug("PROTOCOL", "gbank-dv called: %s from %s (%d bytes)", prefix, sender, #message)
+		self:OnCommReceived(prefix, message, distribution, sender)
 	end)
-    -- Delta chain
-	GBankClassic_Core:RegisterComm("gbank-dc", function(prefix, message, distribution, sender)
-		GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
+	-- Delta version (new protocol for aggregated items structure)
+	GBankClassic_Output:Debug("PROTOCOL", "Registering gbank-dv2 handler")
+	GBankClassic_Core:RegisterComm("gbank-dv2", function(prefix, message, distribution, sender)
+		GBankClassic_Output:Debug("PROTOCOL", "gbank-dv2 called: %s from %s (%d bytes)", prefix, sender, #message)
+		self:OnCommReceived(prefix, message, distribution, sender)
 	end)
 
     -- Query
     GBankClassic_Core:RegisterComm("gbank-r", function(prefix, message, distribution, sender)
-        GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
+        self:OnCommReceived(prefix, message, distribution, sender)
     end)
     -- Query reply
 	GBankClassic_Core:RegisterComm("gbank-rr", function(prefix, message, distribution, sender)
-		GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
+		self:OnCommReceived(prefix, message, distribution, sender)
 	end)
 
     -- State summary
 	GBankClassic_Core:RegisterComm("gbank-state", function(prefix, message, distribution, sender)
-		GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
+		self:OnCommReceived(prefix, message, distribution, sender)
 	end)
     -- No change
 	GBankClassic_Core:RegisterComm("gbank-nochange", function(prefix, message, distribution, sender)
-		GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
+		self:OnCommReceived(prefix, message, distribution, sender)
 	end)
 
     -- Hello
     GBankClassic_Core:RegisterComm("gbank-h", function(prefix, message, distribution, sender)
-        GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
+        self:OnCommReceived(prefix, message, distribution, sender)
     end)
     -- Hello reply
     GBankClassic_Core:RegisterComm("gbank-hr", function(prefix, message, distribution, sender)
-        GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
+        self:OnCommReceived(prefix, message, distribution, sender)
     end)
 
     -- Share
     GBankClassic_Core:RegisterComm("gbank-s", function(prefix, message, distribution, sender)
-        GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
+        self:OnCommReceived(prefix, message, distribution, sender)
     end)
     -- Share reply
     GBankClassic_Core:RegisterComm("gbank-sr", function(prefix, message, distribution, sender)
-        GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
+        self:OnCommReceived(prefix, message, distribution, sender)
     end)
 
     -- Wipe
     GBankClassic_Core:RegisterComm("gbank-w", function(prefix, message, distribution, sender)
-        GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
+        self:OnCommReceived(prefix, message, distribution, sender)
     end)
     -- Wipe reply
-    GBankClassic_Core:RegisterComm("gbank-o", function(prefix, message, distribution, sender)
-        GBankClassic_Chat:OnOfferReceived(prefix, message, distribution, sender)
+    GBankClassic_Core:RegisterComm("gbank-wr", function(prefix, message, distribution, sender)
+        self:OnCommReceived(prefix, message, distribution, sender)
     end)
-end
 
--- Wrapper for debug logging (delegates to centralized logger)
-function GBankClassic_Chat:Debug(...)
-	return GBankClassic_Output:Debug(...)
+	-- -- Request-specific message handlers
+	-- GBankClassic_Core:RegisterComm("gbank-rq", function(prefix, message, distribution, sender)
+	-- 	self:OnCommReceived(prefix, message, distribution, sender)
+	-- end)
+	-- GBankClassic_Core:RegisterComm("gbank-rd", function(prefix, message, distribution, sender)
+	-- 	self:OnCommReceived(prefix, message, distribution, sender)
+	-- end)
 end
 
 -- Centralized sync function for both /sync command and UI opening
-function GBankClassic_Chat:PerformSync()
+function Chat:PerformSync()
 	-- Use delta version broadcast with ALERT priority so it happens immediately
 	GBankClassic_Events:SyncDeltaVersion("ALERT")
 	-- Also send legacy version broadcast like the automatic timer does
 	GBankClassic_Events:Sync("ALERT")
 	GBankClassic_Guild:FastFillMissingAlts()
+	-- -- Query request snapshot with ALERT priority for immediate sync
+	-- local player = GBankClassic_Guild:GetPlayer()
+	-- GBankClassic_Guild:QueryRequestsSnapshot("ALERT")
 end
 
 local SHARES_COLOR = "|cff80bfffshares|r"
 local QUERIES_COLOR = "|cffffff00queries|r"
 
-local function ColorPlayerName(name)
+local function colorPlayerName(name)
 	if not name or name == "" then
 		return ""
 	end
@@ -133,7 +168,7 @@ local function ColorPlayerName(name)
 	return string.format("|cff80bfff%s|r", name)
 end
 
-local function FormatSyncStatus(status)
+local function formatSyncStatus(status)
 	if status == ADOPTION_STATUS.ADOPTED then
 		return "(newer, integrating)"
 	end
@@ -153,64 +188,19 @@ local function FormatSyncStatus(status)
 	return ""
 end
 
-function GBankClassic_Chat:IsAltDataAllowed_Restrictive(sender, claimedNorm)
-	-- 'sender' was normalized near the top of OnCommReceived
-	local hasExistingAlt = false
-	if GBankClassic_Guild and GBankClassic_Guild.Info and GBankClassic_Guild.Info.alts then
-		local existingAlt = GBankClassic_Guild.Info.alts[claimedNorm]
-		hasExistingAlt = existingAlt ~= nil and type(existingAlt) == "table"
-	end
-	local allowed = false
-	-- If the sender is the claimed owner, always accept
-	if sender == claimedNorm then
-		allowed = true
-	else
-		-- If the claimed owner is a registered bank toon, only accept from bank-marked senders
-		local claimedIsBank = GBankClassic_Guild:IsBank(claimedNorm)
-		if claimedIsBank then
-			if GBankClassic_Guild:SenderHasGbankNote(sender) then
-				allowed = true
-			else
-				allowed = false
-				-- Allow relayed data only when we have no entry yet
-				if not hasExistingAlt then
-					allowed = true
-				end
-			end
-		else
-			-- claimed owner is not a bank toon: accept delegated shares from anyone
-			allowed = true
-		end
-	end
-
-	return allowed
-end
-
-function GBankClassic_Chat:IsAltDataAllowed_Permissive(_, _)
-	return true
-end
-
 -- Roster-based validation to prevent cross-guild data bleed
 -- Only accept alt data if both sender and claimed alt are in current guild
-function GBankClassic_Chat:IsAltDataAllowed_RosterBased(sender, claimedNorm)
+function Chat:IsAltDataAllowed_RosterBased(sender, claimedNorm)
 	-- Check if sender is in the current guild
 	if not GBankClassic_Guild:IsInCurrentGuildRoster(sender) then
-		GBankClassic_Output:Debug(
-			"PROTOCOL",
-			"Rejecting alt data from %s: sender not in current guild roster",
-			sender
-		)
+		GBankClassic_Output:Debug("PROTOCOL", "Rejecting alt data from %s: sender not in current guild roster", sender)
 
 		return false
 	end
 
-	-- Check if claimed alt is in the current guild's bank roster
+	-- Check if claimed alt is in the current guild's bank alt roster
 	if not GBankClassic_Guild:IsBank(claimedNorm) then
-		GBankClassic_Output:Debug(
-			"PROTOCOL",
-			"Rejecting alt data for %s: not a guild bank alt in current guild roster",
-			claimedNorm
-		)
+		GBankClassic_Output:Debug("PROTOCOL", "Rejecting alt data for %s: not a guild bank alt in current guild bank alt roster", claimedNorm)
 
 		return false
 	end
@@ -218,26 +208,176 @@ function GBankClassic_Chat:IsAltDataAllowed_RosterBased(sender, claimedNorm)
 	return true
 end
 
-function GBankClassic_Chat:IsAltDataAllowed(sender, claimedNorm)
+function Chat:IsAltDataAllowed(sender, claimedNorm)
 	-- Use roster-based validation by default
 	return self:IsAltDataAllowed_RosterBased(sender, claimedNorm)
 end
 
-function GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
+-- Cancel pending legacy dv messages for specific alts (called when dv2 arrives)
+function Chat:CancelPendingDvMessages(sender, altNames)
+	if not self.pending_dv_messages[sender] then
+		return
+	end
+	
+	for _, altName in ipairs(altNames) do
+		local pending = self.pending_dv_messages[sender][altName]
+		if pending and pending.timer then
+			GBankClassic_Output:Debug("PROTOCOL", "Canceling pending dv message for %s (dv2 arrived)", altName)
+			pending.timer:Cancel()
+			self.pending_dv_messages[sender][altName] = nil
+		end
+	end
+end
+
+-- Process delayed legacy dv message after timer expires
+function Chat:ProcessDelayedDvMessage(sender, data, prefix, message, distribution)
+	GBankClassic_Output:Debug("PROTOCOL", "Processing delayed dv message from %s (no dv2 received)", sender)
+
+	-- Remove from pending queue
+	if self.pending_dv_messages[sender] then
+		self.pending_dv_messages[sender] = nil
+	end
+
+	-- Process the message normally
+	self:ProcessVersionBroadcast(prefix, data, sender, message, distribution)
+end
+
+-- Process version broadcast message (gbank-v, gbank-dv, gbank-dv2)
+function Chat:ProcessVersionBroadcast(prefix, data, sender, message, distribution)
+	local isDeltaVersion = (prefix == "gbank-dv" or prefix == "gbank-dv2")
+	local isDV2 = (prefix == "gbank-dv2")
+
+	-- Show what data we received
+	if isDeltaVersion then
+		local altCount = data.alts and GBankClassic_Globals:Count(data.alts)
+		GBankClassic_Output:Debug("PROTOCOL", "gbank-dv/dv2 from %s: has data.alts=%s, alts count=%d, isDV2=%s", sender, tostring(data.alts ~= nil), altCount, tostring(isDV2))
+	end
+
+	local current_data = GBankClassic_Guild:GetVersion()
+	if current_data then
+		if data.name then
+			if current_data.name ~= data.name then
+				GBankClassic_Output:Warn("A non-guild version!")
+
+				return
+			end
+		end
+		if data.addon then
+			-- Track this user's addon version
+			if not self.guild_versions then
+				self.guild_versions = {}
+			end
+			self.guild_versions[sender] = {
+				version = data.addon,
+				seen = time(),
+			}
+
+			-- Track online guild bank alts for pull-based protocol
+			if data.isGuildBankAlt then
+				if not self.online_guild_bank_alts then
+					self.online_guild_bank_alts = {}
+				end
+				self.online_guild_bank_alts[sender] = {
+					seen = time(),
+					version = data.addon,
+				}
+					GBankClassic_Output:Debug("ROSTER", "Tracked online guild bank alt: %s", sender)
+			end
+
+			-- Track protocol capabilities
+			local protocolVersion = data.protocol_version or 1
+			local supportsDelta = data.supports_delta or false
+			GBankClassic_Database:UpdatePeerProtocol(current_data.name, sender, protocolVersion, supportsDelta)
+
+			if current_data.addon and data.addon > current_data.addon then
+				if not self.addon_outdated then
+					-- Only make the callout once
+					self.addon_outdated = true
+					GBankClassic_Output:Info("A newer version is available! Download it from https://www.curseforge.com/wow/addons/gbankclassic-revived")
+				end
+			end
+		end
+		if data.roster then
+			if current_data.roster == nil or data.roster > current_data.roster then
+				GBankClassic_Output:Debug("SYNC", ">", colorPlayerName(sender), "has fresher roster data, querying.")
+				GBankClassic_Guild:QueryRoster(sender, data.roster)
+			end
+		end
+		-- Request sync decoupled from inventory sync (gbank-dv)
+		-- Request syncs now handled independently via SendRequestsVersionPing()
+		if data.alts then
+			local altCount = GBankClassic_Globals:Count(data.alts)
+			GBankClassic_Output:Debug("PROTOCOL", "Processing %d alts from %s (isDeltaVersion=%s)", altCount, sender, tostring(isDeltaVersion))
+			for k, v in pairs(data.alts) do
+				local kNorm = GBankClassic_Guild:NormalizeName(k)
+				local ourAlt = current_data.alts[kNorm]
+
+				-- Handle both old format (number) and new format (table with version+hash)
+				local theirVersion = type(v) == "table" and v.version or v
+				local theirHash = type(v) == "table" and v.hash or nil
+				local ourVersion = type(ourAlt) == "table" and ourAlt.version or nil
+				local ourHash = type(ourAlt) == "table" and ourAlt.inventoryHash or nil
+
+				-- Show what we received
+				if theirHash then
+					GBankClassic_Output:Debug("SYNC", "Received %s from %s: version=%d, hash=%d (our hash=%s)", kNorm, sender, theirVersion, theirHash, ourHash and tostring(ourHash) or "nil")
+				end
+
+				-- Don't query sender about themselves
+				local senderNorm = GBankClassic_Guild:NormalizeName(sender)
+				if kNorm ~= senderNorm then
+					-- For delta version broadcasts, only query if we support delta
+					-- For legacy version broadcasts, query as normal
+					local shouldQuery = false
+					if isDeltaVersion then
+						-- Hash-based comparison (most accurate)
+						if theirHash then
+							if not ourHash then
+								-- They have data, we don't - query
+								shouldQuery = true
+								GBankClassic_Output:Debug("SYNC", ">", colorPlayerName(sender), "has bank data for", colorPlayerName(kNorm) .. " (we have none), querying.")
+							elseif theirHash ~= ourHash then
+								-- Hashes differ - we need an update
+								shouldQuery = true
+								GBankClassic_Output:Debug("SYNC", ">", colorPlayerName(sender), "has different inventory for", colorPlayerName(kNorm) .. " (hash mismatch), querying.")
+							end
+						elseif not ourVersion or theirVersion > ourVersion then
+							-- No hash available, fall back to version comparison
+							shouldQuery = true
+							GBankClassic_Output:Debug("SYNC", ">", colorPlayerName(sender), "has fresher bank data about", colorPlayerName(kNorm) .. ", querying (delta).")
+						end
+					else
+						-- Legacy version: query as usual
+						if not ourVersion or theirVersion > ourVersion then
+							shouldQuery = true
+							GBankClassic_Output:Debug("SYNC", ">", colorPlayerName(sender), "has fresher bank data about", colorPlayerName(kNorm) .. ", querying.")
+						end
+					end
+
+					if shouldQuery then
+						-- Use pull-based query for delta version broadcasts
+						GBankClassic_Guild:QueryAltPullBased(kNorm)
+					end
+				end
+			end
+		end
+	end
+end
+
+function Chat:OnCommReceived(prefix, message, distribution, sender)
 	local prefixDesc = COMM_PREFIX_DESCRIPTIONS[prefix] or "(Unknown)"
 
-	-- Log ALL incoming messages before any filtering
+	-- Log all incoming messages before any filtering
 	if prefix == "gbank-dv" then
-		GBankClassic_Output:Debug("COMMS", "RAW RECEIVED: %s from %s (%d bytes)", prefix, sender, #message)
+		GBankClassic_Output:Debug("COMMS", "Received: %s from %s (%d bytes)", prefix, sender, #message)
 	end
 
-	-- WHISPER DEBUG
 	if distribution == "WHISPER" or prefix == "gbank-r" or prefix == "gbank-rr" then
-		GBankClassic_Output:DebugComm("RECEIVED: %s via %s from %s", prefix, distribution, sender)
+		GBankClassic_Output:DebugComm("Received: %s via %s from %s", prefix, distribution, sender)
 	end
 
 	if IsInRaid() then
-		self:Debug("PROTOCOL", "> (ignoring)", prefix, prefixDesc, "from", ColorPlayerName(sender), "(in raid)")
+		GBankClassic_Output:Debug("PROTOCOL", "> (ignoring)", prefix, prefixDesc, "from", colorPlayerName(sender), "(in raid)")
 
 		return
 	end
@@ -247,243 +387,102 @@ function GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
 	sender = GBankClassic_Guild:NormalizeName(sender)
 
 	if player == sender then
-		self:Debug("PROTOCOL", "> (ignoring)", prefix, prefixDesc, "(our own)")
+		GBankClassic_Output:Debug("PROTOCOL", "> (ignoring)", prefix, prefixDesc, "(our own)")
 
 		return
 	end
 
 	local success, data = GBankClassic_Core:DeserializeWithChecksum(message)
 	if not success then
-		self:Debug("PROTOCOL", "> failed to deserialize", prefix, prefixDesc, "from", ColorPlayerName(sender), "error:", tostring(data))
+		GBankClassic_Output:Debug("PROTOCOL", "> failed to deserialize", prefix, prefixDesc, "from", colorPlayerName(sender), "ERROR:", tostring(data))
 		
         return
 	end
 
 	-- Log what we deserialized for gbank-dv
 	if prefix == "gbank-dv" then
-		local altCount = 0
-		if data and data.alts then
-			for _ in pairs(data.alts) do
-				altCount = altCount + 1
-			end
-		end
-		GBankClassic_Output:Debug("PROTOCOL", "[DESERIALIZE] gbank-dv from %s: success=%s, has data=%s, has data.alts=%s, altCount=%d",
-			sender,
-			tostring(success),
-			tostring(data ~= nil),
-			tostring(data and data.alts ~= nil),
-			altCount
-		)
+		local altCount = data and data.alts and GBankClassic_Globals:Count(data.alts)
+		GBankClassic_Output:Debug("PROTOCOL", "gbank-dv from %s: success=%s, has data=%s, has data.alts=%s, altCount=%d", sender, tostring(success), tostring(data ~= nil), tostring(data and data.alts ~= nil), altCount)
 	end
 
 	if prefix ~= "gbank-r" then
 		-- gbank-r does its own output
-		self:Debug("PROTOCOL", ">", ColorPlayerName(sender), ">", prefix, prefixDesc)
+		GBankClassic_Output:Debug("PROTOCOL", ">", colorPlayerName(sender), ">", prefix, prefixDesc)
 	end
 
-	if prefix == "gbank-v" or prefix == "gbank-dv" then
-		local isDeltaVersion = (prefix == "gbank-dv")
-
+	if prefix == "gbank-v" or prefix == "gbank-dv" or prefix == "gbank-dv2" then
 		-- Delta clients ignore legacy version broadcasts
-		local weUseDelta = GBankClassic_Guild:ShouldUseDelta()
-		if weUseDelta and prefix == "gbank-v" then
-			-- Silently ignore - delta clients only listen to gbank-dv
+		if prefix == "gbank-v" then
 			return
 		end
 
-		-- Show what data we received
-		if isDeltaVersion then
-			local altCount = 0
-			if data.alts then
-				for _ in pairs(data.alts) do
-					altCount = altCount + 1
-				end
-			end
-			GBankClassic_Output:Debug("PROTOCOL", "gbank-dv from %s: has data.alts=%s, alts count=%d",
-				sender,
-				tostring(data.alts ~= nil),
-				altCount
-			)
-		end
-
-		local current_data = GBankClassic_Guild:GetVersion()
-		if current_data then
-			if data.name then
-				if current_data.name ~= data.name then
-					GBankClassic_Output:Warn("A non-guild version!")
-                    
-					return
-				end
+		-- New clients only listen to gbank-dv2, ignore gbank-dv
+		-- Legacy clients only listen to gbank-dv, ignore gbank-dv2
+		if prefix == "gbank-dv" then
+			-- Delay dv processing to allow dv2 to arrive first (prioritize newer protocol)
+			GBankClassic_Output:Debug("PROTOCOL", "Delaying dv message from %s for %d seconds (waiting for dv2)", sender, self.DV_DELAY)
+			
+			-- Store the message with a timer
+			if not self.pending_dv_messages[sender] then
+				self.pending_dv_messages[sender] = {}
 			end
-			if data.addon then
-				-- Track this user's addon version
-				if not self.guild_versions then
-					self.guild_versions = {}
-				end
-				self.guild_versions[sender] = {
-					version = data.addon,
-					seen = time(),
-				}
-
-				-- Track online guild bank alts for pull-based protocol
-				if data.isGuildBankAlt then
-					if not self.online_guild_bank_alts then
-						self.online_guild_bank_alts = {}
-					end
-					self.online_guild_bank_alts[sender] = {
-						seen = time(),
-						version = data.addon,
+			
+			-- Extract alt names from data to track what needs canceling
+			local altNames = {}
+			if data.alts then
+				for altName in pairs(data.alts) do
+					table.insert(altNames, altName)
+					-- Store pending message keyed by alt name for easy cancellation
+					self.pending_dv_messages[sender][altName] = {
+						data = data,
+						prefix = prefix,
+						message = message,
+						distribution = distribution,
 					}
-					GBankClassic_Output:Debug("ROSTER", "Tracked online guild bank alt: %s", sender)
-				end
-
-				-- Track protocol capabilities
-				local protocolVersion = data.protocol_version or 1
-				local supportsDelta = data.supports_delta or false
-				GBankClassic_Database:UpdatePeerProtocol(
-					current_data.name,
-					sender,
-					protocolVersion,
-					supportsDelta
-				)
-
-				if current_data.addon and data.addon > current_data.addon then
-					if not self.addon_outdated then
-						-- only make the callout once
-						self.addon_outdated = true
-						GBankClassic_Output:Info("A newer version is available! Download it from https://www.curseforge.com/wow/addons/gbankclassic/")
-					end
 				end
 			end
-			if data.roster then
-				if current_data.roster == nil or data.roster > current_data.roster then
-					self:Debug("SYNC", ">", ColorPlayerName(sender), "has fresher roster data, querying.")
-					GBankClassic_Guild:QueryRoster(sender, data.roster)
-				end
+			
+			-- Create timer to process after delay
+			After(self.DV_DELAY, function()
+				self:ProcessDelayedDvMessage(sender, data, prefix, message, distribution)
+			end)
+			
+			return
+		end
+		
+		-- If we're processing dv2, cancel any pending dv messages for these alts
+		if prefix == "gbank-dv2" and data.alts then
+			local altNames = {}
+			for altName in pairs(data.alts) do
+				table.insert(altNames, altName)
 			end
-			-- Request sync decoupled from inventory sync (gbank-dv)
-			if data.alts then
-				local altCount = 0
-				for _ in pairs(data.alts) do
-					altCount = altCount + 1
-				end
-				GBankClassic_Output:Debug("PROTOCOL", "[PROCESS] Processing %d alts from %s (isDeltaVersion=%s)",
-					altCount, sender, tostring(isDeltaVersion))
-				for k, v in pairs(data.alts) do
-					local kNorm = GBankClassic_Guild:NormalizeName(k)
-					local ourAlt = current_data.alts[kNorm]
-
-					-- Handle both old format (number) and new format (table with version+hash)
-					local theirVersion = type(v) == "table" and v.version or v
-					local theirHash = type(v) == "table" and v.hash or nil
-					local ourVersion = type(ourAlt) == "table" and ourAlt.version or nil
-					local ourHash = type(ourAlt) == "table" and ourAlt.inventoryHash or nil
-
-					-- Show what we received
-					if theirHash then
-						GBankClassic_Output:Debug(
-							"SYNC",
-							"Received %s from %s: version=%d, hash=%d (our hash=%s)",
-							kNorm,
-							sender,
-							theirVersion,
-							theirHash,
-							ourHash and tostring(ourHash) or "nil"
-						)
-					end
+			self:CancelPendingDvMessages(sender, altNames)
+		end
 
-					-- Don't query sender about themselves
-					local senderNorm = GBankClassic_Guild:NormalizeName(sender)
-					if kNorm ~= senderNorm then
-						-- For delta version broadcasts, only query if we support delta
-						-- For legacy version broadcasts, query as normal
-						local shouldQuery = false
-						if isDeltaVersion then
-							-- Delta version: check hash first (most accurate), then version
-							if GBankClassic_Guild:ShouldUseDelta() then
-								-- Hash-based comparison (most accurate)
-								if theirHash then
-									if not ourHash then
-										-- They have data, we don't - query
-										shouldQuery = true
-										self:Debug(
-											"SYNC",
-											">",
-											ColorPlayerName(sender),
-											"has bank data for",
-											ColorPlayerName(kNorm) .. " (we have none), querying."
-										)
-									elseif theirHash ~= ourHash then
-										-- Hashes differ - we need an update
-										shouldQuery = true
-										self:Debug(
-											"SYNC",
-											">",
-											ColorPlayerName(sender),
-											"has different inventory for",
-											ColorPlayerName(kNorm) .. " (hash mismatch), querying."
-										)
-									end
-								elseif not ourVersion or theirVersion > ourVersion then
-									-- No hash available, fall back to version comparison
-									shouldQuery = true
-									self:Debug(
-										"SYNC",
-										">",
-										ColorPlayerName(sender),
-										"has fresher bank data about",
-										ColorPlayerName(kNorm) .. ", querying (delta)."
-									)
-								end
-							end
-						else
-							-- Legacy version: query as usual
-							if not ourVersion or theirVersion > ourVersion then
-								shouldQuery = true
-								self:Debug(
-									"SYNC",
-									">",
-									ColorPlayerName(sender),
-									"has fresher bank data about",
-									ColorPlayerName(kNorm) .. ", querying."
-								)
-							end
-						end
+		-- Process the message immediately
+		self:ProcessVersionBroadcast(prefix, data, sender, message, distribution)
 
-						if shouldQuery then
-							-- Use pull-based query for delta version broadcasts
-							GBankClassic_Guild:QueryAltPullBased(kNorm)
-						end
-					end
-				end
-			end
-		end
+		return
 	end
 
 	if prefix == "gbank-r" then
-		GBankClassic_Output:DebugComm("gbank-r DATA.TYPE = %s from %s", tostring(data.type), sender)
+		GBankClassic_Output:DebugComm("gbank-r type = %s from %s", tostring(data.type), sender)
 
 		-- Check if this is a pull-based request (has type == "alt-request")
 		if data.type == "alt-request" then
 			-- Pull-based request flow - respond with gbank-rr acknowledgment
 			local altName = data.name
 
-			GBankClassic_Output:DebugComm("RECEIVED PULL-BASED REQUEST from %s for alt %s", sender, altName)
-			self:Debug(
-				"SYNC",
-				">",
-				ColorPlayerName(sender),
-				QUERIES_COLOR,
-				"pull-based request for",
-				ColorPlayerName(altName)
-			)
+			GBankClassic_Output:DebugComm("Received pull-based alt-request from %s for alt %s", sender, altName)
+			GBankClassic_Output:Debug("SYNC", ">", colorPlayerName(sender), QUERIES_COLOR, "pull-based request for", colorPlayerName(altName))
 
 			-- Check if we have this alt
 			local player = GBankClassic_Guild:GetNormalizedPlayer()
 			local isGuildBankAlt = player and GBankClassic_Guild:IsBank(player) or false
 			local hasData = GBankClassic_Guild.Info and GBankClassic_Guild.Info.alts and GBankClassic_Guild.Info.alts[altName] ~= nil
 
-			if hasData or isGuildBankAlt then
+			-- Only guild bank alts respond to pull-based requests
+			if isGuildBankAlt and hasData then
 				-- Send acknowledgment with guild bank alt flag
 				local ack = {
 					type = "alt-request-reply",
@@ -493,27 +492,62 @@ function GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
 				}
 				local ackData = GBankClassic_Core:SerializeWithChecksum(ack)
 
-				GBankClassic_Output:DebugComm("SENDING ACK: gbank-rr via WHISPER to %s (isGuildBankAlt=%s, hasData=%s)", sender, tostring(isGuildBankAlt), tostring(hasData))
+				GBankClassic_Output:DebugComm("Sending acknowledgement: gbank-rr via whisper to %s (isGuildBankAlt=%s, hasData=%s)", sender, tostring(isGuildBankAlt), tostring(hasData))
 				if not GBankClassic_Core:SendWhisper("gbank-rr", ackData, sender, "NORMAL") then
 					return
 				end
-				self:Debug(
-					"SYNC",
-					"<",
-					"Sent gbank-rr to",
-					ColorPlayerName(sender),
-					string.format("(isGuildBankAlt=%s, hasData=%s)", tostring(isGuildBankAlt), tostring(hasData))
-				)
+				GBankClassic_Output:Debug("SYNC", "<", "Sent gbank-rr to", colorPlayerName(sender), string.format("(isGuildBankAlt=%s, hasData=%s)", tostring(isGuildBankAlt), tostring(hasData)))
 			else
 				-- Don't respond if we don't have the data
-				self:Debug("SYNC", "Ignoring pull-based request (no data for %s)", altName)
+				GBankClassic_Output:Debug("SYNC", "Ignoring pull-based request (no data for %s)", altName)
 			end
 
 			return
 		end
 
+		-- -- Legacy request handling
+		-- if data.player then
+		-- 	-- Use REQUESTS category for request-related queries, SYNC for alt queries
+		-- 	local isRequestQuery = data.type and string.find(data.type, "^requests") ~= nil
+		-- 	local category = isRequestQuery and "REQUESTS" or "SYNC"
+		-- 	GBankClassic_Output:Debug(category, ">", colorPlayerName(sender), QUERIES_COLOR, isRequestQuery and "Requests:" or "Sync:", data.type, data.name and colorPlayerName(GBankClassic_Guild:NormalizeName(data.name)) or "")
+
+		-- 	-- Request data is guild-wide, anyone can respond (player="*")
+		-- 	if data.type == "requests" then
+		-- 		local matches = (data.player == "*" or data.player == player)
+		-- 		GBankClassic_Output:DebugComm("Handler check: type=requests, player=%s, myName=%s, matches=%s", tostring(data.player), tostring(player), tostring(matches))
+		-- 		if matches then
+		-- 			GBankClassic_Output:DebugComm("Responding to requests query")
+		-- 			GBankClassic_Guild:SendRequestsSnapshot(sender)
+		-- 		end
+		-- 	end
+		-- 	if data.type == "requests-index" then
+		-- 		local matches = (data.player == "*" or data.player == player)
+		-- 		if matches then
+		-- 			GBankClassic_Output:DebugComm("Responding to requests-index query")
+		-- 			GBankClassic_Guild:SendRequestsIndex(sender)
+		-- 		end
+		-- 	end
+		-- 	if data.type == "requests-by-id" then
+		-- 		local matches = (data.player == "*" or data.player == player)
+		-- 		if matches then
+		-- 			GBankClassic_Output:DebugComm("Responding to requests-by-id query")
+		-- 			GBankClassic_Guild:SendRequestsById(sender, data.ids)
+		-- 		end
+		-- 	end
+		-- 	if data.type == "requests-log" then
+		-- 		-- Legacy query type - respond with full snapshot
+		-- 		local matches = (data.player == "*" or data.player == player)
+		-- 		if matches then
+		-- 			GBankClassic_Output:DebugComm("Responding with snapshot (log queries deprecated)")
+		-- 			GBankClassic_Guild:SendRequestsSnapshot(sender)
+		-- 		end
+		-- 	end
+		-- end
+
 		-- Alt and roster queries are per-player, only respond if query is for us
 		if data.player and data.player == player then
+			-- Roster query: keep because some players may be unable to know about guild bank alts defined in officer notes
 			if data.type == "roster" then
 				local time = GetServerTime()
 				if self.last_roster_sync == nil or time - self.last_roster_sync > 300 then
@@ -534,15 +568,7 @@ function GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
 					if type(requestedVersion) == "number" and type(currentVersion) == "number" and requestedVersion < currentVersion then
 						local deltaChain = GBankClassic_Database:GetDeltaHistory(GBankClassic_Guild.Info.name, nameNorm, requestedVersion, currentVersion)
 						if deltaChain and #deltaChain > 0 then
-							GBankClassic_Output:Debug(
-								"DELTA",
-								"Query from %s for %s v%d (have v%d), sending %d-delta chain",
-								sender,
-								nameNorm,
-								requestedVersion,
-								currentVersion,
-								#deltaChain
-							)
+							GBankClassic_Output:Debug("DELTA", "Query from %s for %s v%d (have v%d), sending %d-delta chain", sender, nameNorm, requestedVersion, currentVersion, #deltaChain)
 							GBankClassic_Guild:SendDeltaChain(nameNorm, deltaChain, sender)
 
 							return
@@ -553,7 +579,7 @@ function GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
 				-- Fall back to normal query response
 				table.insert(self.sync_queue, nameNorm)
 				if not self.is_syncing then
-					GBankClassic_Chat:ProcessQueue()
+					self:ProcessQueue()
 				end
 			end
 		end
@@ -566,24 +592,15 @@ function GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
 			local isGuildBankAlt = data.isGuildBankAlt or false
 			local hasData = data.hasData or false
 
-			GBankClassic_Output:DebugComm("RECEIVED ACK: gbank-rr from %s for alt %s (isGuildBankAlt=%s, hasData=%s)", sender, altName, tostring(isGuildBankAlt), tostring(hasData))
-			self:Debug(
-				"SYNC",
-				">",
-				ColorPlayerName(sender),
-				QUERIES_COLOR,
-				string.format("acknowledged request for %s (altName=%s, hasData=%s)",
-					ColorPlayerName(altName),
-					tostring(isGuildBankAlt),
-					tostring(hasData))
-			)
+			GBankClassic_Output:DebugComm("Received acknowledgment: gbank-rr from %s for alt %s (isGuildBankAlt=%s, hasData=%s)", sender, altName, tostring(isGuildBankAlt), tostring(hasData))
+			GBankClassic_Output:Debug("SYNC", ">", colorPlayerName(sender), QUERIES_COLOR, string.format("acknowledged request for %s (altName=%s, hasData=%s)", colorPlayerName(altName), tostring(isGuildBankAlt), tostring(hasData)))
 
 			-- If sender has the data, send our state summary to them
 			if hasData then
-				GBankClassic_Output:DebugComm("CALLING SendStateSummary for %s to %s", altName, sender)
+				GBankClassic_Output:DebugComm("Calling SendStateSummary for %s to %s", altName, sender)
 				GBankClassic_Guild:SendStateSummary(altName, sender)
 			else
-				GBankClassic_Output:DebugComm("NOT sending state summary (hasData=false)")
+				GBankClassic_Output:DebugComm("Not sending state summary (hasData=false)")
 			end
 		end
 	end
@@ -594,17 +611,11 @@ function GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
 			local altName = data.name
 			local summary = data.summary
 
-			GBankClassic_Output:DebugComm("RECEIVED STATE SUMMARY from %s for alt %s (hash=%s, version=%s)", sender, altName, tostring(summary and summary.hash), tostring(summary and summary.version))
-			self:Debug(
-				"SYNC",
-				">",
-				ColorPlayerName(sender),
-				QUERIES_COLOR,
-				string.format("received state summary for %s", ColorPlayerName(altName))
-			)
+			GBankClassic_Output:DebugComm("Received state summary from %s for alt %s (hash=%s, version=%s)", sender, altName, tostring(summary and summary.hash), tostring(summary and summary.version))
+			GBankClassic_Output:Debug("SYNC", ">", colorPlayerName(sender), QUERIES_COLOR, string.format("received state summary for %s", colorPlayerName(altName)))
 
 			-- Compute and send response (full/delta/no-change)
-			GBankClassic_Output:DebugComm("CALLING RespondToStateSummary for %s from %s", altName, sender)
+			GBankClassic_Output:DebugComm("Calling RespondToStateSummary for %s from %s", altName, sender)
 			GBankClassic_Guild:RespondToStateSummary(altName, summary, sender)
 		end
 	end
@@ -615,14 +626,8 @@ function GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
 			local altName = data.name
 			local version = data.version or 0
 
-			GBankClassic_Output:DebugComm("RECEIVED NO-CHANGE from %s for alt %s (version=%d)", sender, altName, version)
-			self:Debug(
-				"SYNC",
-				">",
-				ColorPlayerName(sender),
-				QUERIES_COLOR,
-				string.format("no changes for %s (v%d)", ColorPlayerName(altName), version)
-			)
+			GBankClassic_Output:DebugComm("Received no-change from %s for alt %s (version=%d)", sender, altName, version)
+			GBankClassic_Output:Debug("SYNC", ">", colorPlayerName(sender), QUERIES_COLOR, string.format("no changes for %s (v%d)", colorPlayerName(altName), version))
 
 			-- Mark sync as complete
 			GBankClassic_Guild:ConsumePendingSync("alt", sender, altName)
@@ -640,76 +645,93 @@ function GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
 		end
 	end
 
-	-- gbank-d: link-less full sync
+	-- if prefix == "gbank-rm" then
+	-- 	GBankClassic_Output:DebugComm("%s received from %s: type=%s", prefix, sender, tostring(data.type))
+		
+	-- 	-- -- Critical debug for request mutations
+	-- 	-- if data.type == "requests-log" then
+	-- 	-- 	GBankClassic_Output:Debug("SYNC", "%s requests-log received from %s, about to call ReceiveRequestMutations", prefix, sender)
+	-- 	-- end
+
+	-- 	if data.type == "roster" then
+	-- 		-- Only accept roster updates from a sender that is marked as a bank in guild notes, or from the guild master
+	-- 		-- TODO: also accept from players that can view guild notes
+	-- 		local allowed = (GBankClassic_Guild and GBankClassic_Guild.SenderHasGbankNote and GBankClassic_Guild:SenderHasGbankNote(sender)) or GBankClassic_Guild:SenderIsGM(sender)
+	-- 		if GBankClassic_Guild:ConsumePendingSync("roster", sender) then
+	-- 			allowed = true
+	-- 		end
+	-- 		GBankClassic_Output:Debug("SYNC", ">", colorPlayerName(sender), SHARES_COLOR, "roster data. We", allowed and "accept it." or "do not accept it.")
+	-- 	end
+
+	-- 	if data.type == "requests" then
+	-- 		local status = GBankClassic_Guild:ReceiveRequestsData(data)
+	-- 		GBankClassic_Output:Debug("REQUESTS", ">", colorPlayerName(sender), SHARES_COLOR, "requests snapshot. We accept it by default.", formatSyncStatus(status))
+	-- 	end
+	-- 	if data.type == "requests-index" then
+	-- 		GBankClassic_Output:Debug("REQUESTS", ">", colorPlayerName(sender), SHARES_COLOR, "requests index. We accept it by default.")
+	-- 		GBankClassic_Guild:ReceiveRequestsIndex(data, sender)
+	-- 	end
+	-- 	if data.type == "requests-by-id" then
+	-- 		local status = GBankClassic_Guild:ReceiveRequestsById(data)
+	-- 		GBankClassic_Output:Debug("REQUESTS", ">", colorPlayerName(sender), SHARES_COLOR, "requests by-id data. We accept it by default.", formatSyncStatus(status))
+	-- 	end
+	-- 	if data.type == "requests-log" then
+	-- 		GBankClassic_Output:Debug("REQUESTS", ">", colorPlayerName(sender), SHARES_COLOR, "request mutations. We accept by default.")
+	-- 		GBankClassic_Guild:ReceiveRequestMutations(data, sender)
+	-- 	end
+	-- 	if data.type == "alt" then
+	-- 		-- Only accept alt data if the sender matches the claimed alt name
+	-- 		local claimed = data.name
+	-- 		local claimedNorm = GBankClassic_Guild:NormalizeName(claimed)
+	-- 		local allowed = self:IsAltDataAllowed(sender, claimedNorm)
+	-- 		if GBankClassic_Guild:ConsumePendingSync("alt", sender, claimedNorm) then
+	-- 			allowed = true
+	-- 		end
+	-- 		local status = allowed and GBankClassic_Guild:ReceiveAltData(claimedNorm, data.alt, sender) or ADOPTION_STATUS.UNAUTHORIZED
+	-- 		GBankClassic_Output:Debug("SYNC", ">", colorPlayerName(sender), SHARES_COLOR, "bank data (link-less) about", colorPlayerName(claimedNorm) .. ". We", allowed and "accept it." or "do not accept it.", formatSyncStatus(status))
+	-- 		if allowed then
+	-- 			-- ReceiveAltData already applied/rejected; refresh UI if open
+	-- 			if status == ADOPTION_STATUS.ADOPTED and GBankClassic_UI_Inventory and GBankClassic_UI_Inventory.isOpen then
+	-- 				GBankClassic_UI_Inventory:DrawContent()
+	-- 			end
+	-- 		else
+	-- 			-- Ignore spoofed alt data
+	-- 			return
+	-- 		end
+	-- 	end
+	-- end
+
+	-- Full sync with links
 	if prefix == "gbank-d" then
-		GBankClassic_Output:DebugComm("gbank-d received from %s: type=%s", sender, tostring(data.type))
-		self:Debug(
-			"SYNC",
-			">",
-			ColorPlayerName(sender),
-			QUERIES_COLOR,
-			string.format("gbank-d received from %s: type=%s", ColorPlayerName(sender), tostring(data.type))
-		)
-
-		if data.type == "roster" then
-			-- Only accept roster updates from a sender that is marked as a bank in guild notes, or from the guild master
-			-- TODO: also accept from players that can view guild notes
-			local allowed = (
-				GBankClassic_Guild
-				and GBankClassic_Guild.SenderHasGbankNote
-				and GBankClassic_Guild:SenderHasGbankNote(sender)
-			) or GBankClassic_Guild:SenderIsGM(sender)
-			if GBankClassic_Guild:ConsumePendingSync("roster", sender) then
-				allowed = true
-			end
-			self:Debug(
-				"SYNC",
-				">",
-				ColorPlayerName(sender),
-				SHARES_COLOR,
-				"roster data. We",
-				allowed and "accept it." or "do not accept it."
-			)
-		end
 		if data.type == "alt" then
-			-- only accept alt data if the sender matches the claimed alt name
+			-- Only accept alt data if the sender matches the claimed alt name
 			local claimed = data.name
 			local claimedNorm = GBankClassic_Guild:NormalizeName(claimed)
 
-			GBankClassic_Output:DebugComm("RECEIVED DATA: gbank-d from %s for alt %s (%d bytes)", sender, claimedNorm, #message)
+			GBankClassic_Output:DebugComm("Receive data: gbank-d from %s for alt %s (%d bytes)", sender, claimedNorm, #message)
 
 			local allowed = self:IsAltDataAllowed(sender, claimedNorm)
 			if GBankClassic_Guild:ConsumePendingSync("alt", sender, claimedNorm) then
 				allowed = true
 			end
-			local status = allowed and GBankClassic_Guild:ReceiveAltData(claimedNorm, data.alt)
-				or ADOPTION_STATUS.UNAUTHORIZED
-			self:Debug(
-				"SYNC",
-				">",
-				ColorPlayerName(sender),
-				SHARES_COLOR,
-				"bank data (link-less) about",
-				ColorPlayerName(claimedNorm) .. ". We",
-				allowed and "accept it." or "do not accept it.",
-				FormatSyncStatus(status)
-			)
+			local status = allowed and GBankClassic_Guild:ReceiveAltData(claimedNorm, data.alt, sender) or ADOPTION_STATUS.UNAUTHORIZED
+			GBankClassic_Output:Debug("SYNC", ">", colorPlayerName(sender), SHARES_COLOR, "bank data (link-less) about", colorPlayerName(claimedNorm) .. ". We", allowed and "accept it." or "do not accept it.", formatSyncStatus(status))
 			if allowed then
 				-- ReceiveAltData already applied/rejected; refresh UI if open
 				if status == ADOPTION_STATUS.ADOPTED and GBankClassic_UI_Inventory and GBankClassic_UI_Inventory.isOpen then
 					GBankClassic_UI_Inventory:DrawContent()
 				end
 			else
-				-- ignore spoofed alt data
+				-- Ignore spoofed alt data
 				return
 			end
 		end
 	end
 
-	-- gbank-dd: link-less delta
+	-- Delta with links
 	if prefix == "gbank-dd" then
 		if data.type == "alt-delta" then
-			-- only accept delta data if the sender matches the claimed alt name
+			-- Only accept delta data if the sender matches the claimed alt name
 			local claimed = data.name
 			local claimedNorm = GBankClassic_Guild:NormalizeName(claimed)
 			local allowed = self:IsAltDataAllowed(sender, claimedNorm)
@@ -719,19 +741,10 @@ function GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
 
 			if allowed then
 				-- Validate and sanitize delta structure
-				local valid, err = GBankClassic_Core:ValidateDeltaStructure(data)
+				local valid, err = GBankClassic_DeltaComms:ValidateDeltaStructure(data)
 				if not valid then
 					local errorMsg = "Validation failed: " .. (err or "unknown error")
-					self:Debug(
-						"DELTA",
-						">",
-						ColorPlayerName(sender),
-						SHARES_COLOR,
-						"delta (link-less) for",
-						ColorPlayerName(claimedNorm),
-						"- validation failed:",
-						err
-					)
+					GBankClassic_Output:Debug("DELTA", ">", colorPlayerName(sender), SHARES_COLOR, "delta (link-less) for", colorPlayerName(claimedNorm), "- validation failed:", err)
 					-- Record error and request full sync
 					GBankClassic_Guild:RecordDeltaError(claimedNorm, "VALIDATION_FAILED", errorMsg)
 					GBankClassic_Guild:QueryAlt(sender, claimedNorm, nil)
@@ -742,7 +755,8 @@ function GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
 					return
 				end
 
-				-- Reconstruct links from ItemIDs before applying delta
+				-- Reconstruct item links in background using batched queue system
+				-- Processes 5 items every 0.1s to prevent stuttering
 				if data.changes then
 					if data.changes.bank then
 						GBankClassic_Guild:ReconstructItemLinks(data.changes.bank.added)
@@ -757,115 +771,119 @@ function GBankClassic_Chat:OnCommReceived(prefix, message, distribution, sender)
 				end
 
 				local status = GBankClassic_Guild:ApplyDelta(claimedNorm, data, sender)
-				self:Debug(
-					"DELTA",
-					">",
-					ColorPlayerName(sender),
-					SHARES_COLOR,
-					"delta (link-less) for",
-					ColorPlayerName(claimedNorm) .. ".",
-					FormatSyncStatus(status)
-				)
+				GBankClassic_Output:Debug("DELTA", ">", colorPlayerName(sender), SHARES_COLOR, "delta (link-less) for", colorPlayerName(claimedNorm) .. ".", formatSyncStatus(status))
 			else
-				self:Debug(
-					"DELTA",
-					">",
-					ColorPlayerName(sender),
-					SHARES_COLOR,
-					"delta (link-less) for",
-					ColorPlayerName(claimedNorm) .. ". We do not accept it.",
-					FormatSyncStatus(ADOPTION_STATUS.UNAUTHORIZED)
-				)
+				GBankClassic_Output:Debug("DELTA", ">", colorPlayerName(sender), SHARES_COLOR, "delta (link-less) for", colorPlayerName(claimedNorm) .. ". We do not accept it.", formatSyncStatus(ADOPTION_STATUS.UNAUTHORIZED))
 			end
 		end
 	end
 
-	-- Delta range request handler
-	if prefix == "gbank-dr" then
-		if data.altName and data.fromVersion and data.toVersion then
-			local altName = data.altName
-			local fromVersion = data.fromVersion
-			local toVersion = data.toVersion
-
-			self:Debug(
-				"REQUESTS",
-				">",
-				ColorPlayerName(sender),
-				QUERIES_COLOR,
-				"requests delta chain for",
-				ColorPlayerName(altName),
-				string.format("(v%dv%d)", fromVersion, toVersion)
-			)
-
-			-- Get delta history
-			if GBankClassic_Guild.Info and GBankClassic_Guild.Info.name then
-				local deltaChain = GBankClassic_Database:GetDeltaHistory(
-					GBankClassic_Guild.Info.name,
-					altName,
-					fromVersion,
-					toVersion
-				)
-
-				if deltaChain then
-					-- Send delta chain back via whisper
-					local chainData = {
-						altName = altName,
-						deltas = deltaChain
-					}
-					local serialized = GBankClassic_Core:SerializeWithChecksum(chainData)
-					if not GBankClassic_Core:SendWhisper("gbank-dc", serialized, sender, "ALERT") then
-						return
-					end
-					self:Debug(
-						"<",
-						"gbank-dc (delta chain) to",
-						ColorPlayerName(sender),
-						string.format("(%d hops, %d bytes)", #deltaChain, string.len(serialized or ""))
-					)
-				else
-					-- Can't build chain, let them request full sync
-					self:Debug(
-						"< Cannot build delta chain for",
-						ColorPlayerName(altName),
-						string.format("(v%dv%d), no history", fromVersion, toVersion)
-					)
-				end
-			end
-		end
-	end
-
-	-- Delta chain response handler
-	if prefix == "gbank-dc" then
-		if data.altName and data.deltas then
-			local altName = data.altName
-			local deltaChain = data.deltas
-
-			self:Debug(
-				"REQUESTS",
-				">",
-				ColorPlayerName(sender),
-				SHARES_COLOR,
-				"delta chain for",
-				ColorPlayerName(altName),
-				string.format("(%d hops)", #deltaChain)
-			)
-
-			-- Apply delta chain
-			local status = GBankClassic_Guild:ApplyDeltaChain(altName, deltaChain)
-			self:Debug(
-				"REQUESTS",
-				"Delta chain application",
-				FormatSyncStatus(status)
-			)
-		end
-	end
+	-- -- Delta range request handler
+	-- if prefix == "gbank-dr" then
+	-- 	if data.altName and data.fromVersion and data.toVersion then
+	-- 		local altName = data.altName
+	-- 		local fromVersion = data.fromVersion
+	-- 		local toVersion = data.toVersion
+
+	-- 		GBankClassic_Output:Debug("REQUESTS", ">", colorPlayerName(sender), QUERIES_COLOR, "requests delta chain for", colorPlayerName(altName), string.format("(v%dv%d)", fromVersion, toVersion))
+
+	-- 		-- Get delta history
+	-- 		if GBankClassic_Guild.Info and GBankClassic_Guild.Info.name then
+	-- 			local deltaChain = GBankClassic_Database:GetDeltaHistory(GBankClassic_Guild.Info.name, altName, fromVersion, toVersion)
+
+	-- 			if deltaChain then
+	-- 				-- Send delta chain back via whisper
+	-- 				local chainData = {
+	-- 					altName = altName,
+	-- 					deltas = deltaChain
+	-- 				}
+	-- 				local serialized = GBankClassic_Core:SerializeWithChecksum(chainData)
+	-- 				if not GBankClassic_Core:SendWhisper("gbank-dc", serialized, sender, "ALERT") then
+	-- 					return
+	-- 				end
+	-- 				GBankClassic_Output:Debug("REQUESTS", "<", "gbank-dc (delta chain) to", colorPlayerName(sender), string.format("(%d hops, %d bytes)", #deltaChain, string.len(serialized or "")))
+	-- 			else
+	-- 				-- Can't build chain, let them request full sync
+	-- 				GBankClassic_Output:Debug("REQUESTS", "< Cannot build delta chain for", colorPlayerName(altName), string.format("(v%dv%d), no history", fromVersion, toVersion))
+	-- 			end
+	-- 		end
+	-- 	end
+	-- end
+
+	-- -- Delta chain response handler
+	-- if prefix == "gbank-dc" then
+	-- 	if data.altName and data.deltas then
+	-- 		local altName = data.altName
+	-- 		local deltaChain = data.deltas
+
+	-- 		GBankClassic_Output:Debug("REQUESTS", ">", colorPlayerName(sender), SHARES_COLOR, "delta chain for", colorPlayerName(altName), string.format("(%d hops)", #deltaChain))
+
+	-- 		-- Apply delta chain
+	-- 		local status = GBankClassic_Guild:ApplyDeltaChain(altName, deltaChain)
+	-- 		GBankClassic_Output:Debug("REQUESTS", "Delta chain application", formatSyncStatus(status))
+	-- 	end
+	-- end
+
+	-- -- Request-specific query handler (gbank-rq)
+	-- -- This is the dedicated prefix for request queries, replacing gbank-r with type="requests*"
+	-- if prefix == "gbank-rq" then
+	-- 	GBankClassic_Output:DebugComm("gbank-rq type = %s from %s", tostring(data.type), sender)
+	-- 	GBankClassic_Output:Debug( "REQUESTS", ">", colorPlayerName(sender), QUERIES_COLOR, "request query:", data.type or "unknown")
+
+	-- 	-- Request data is guild-wide, anyone can respond (player="*")
+	-- 	if data.type == "requests" then
+	-- 		local matches = (data.player == "*" or data.player == player)
+	-- 		GBankClassic_Output:DebugComm("Handler check: type=requests, player=%s, myName=%s, matches=%s", tostring(data.player), tostring(player), tostring(matches))
+	-- 		if matches then
+	-- 			GBankClassic_Output:DebugComm("Responding to requests query")
+	-- 			GBankClassic_Guild:SendRequestsSnapshot(sender)
+	-- 		end
+	-- 	end
+	-- 	if data.type == "requests-index" then
+	-- 		local matches = (data.player == "*" or data.player == player)
+	-- 		if matches then
+	-- 			GBankClassic_Output:DebugComm("Responding to requests-index query")
+	-- 			GBankClassic_Guild:SendRequestsIndex(sender)
+	-- 		end
+	-- 	end
+	-- 	if data.type == "requests-by-id" then
+	-- 		local matches = (data.player == "*" or data.player == player)
+	-- 		if matches then
+	-- 			GBankClassic_Output:DebugComm("Responding to requests-by-id query")
+	-- 			GBankClassic_Guild:SendRequestsById(sender, data.ids)
+	-- 		end
+	-- 	end
+	-- end
+
+	-- -- Request-specific data handler (togbank-rd)
+	-- -- This is the dedicated prefix for request data
+	-- if prefix == "gbank-rd" then
+	-- 	GBankClassic_Output:DebugComm("gbank-rd received from %s: type=%s", sender, tostring(data.type))
+
+	-- 	if data.type == "requests" then
+	-- 		local status = GBankClassic_Guild:ReceiveRequestsData(data)
+	-- 		GBankClassic_Output:Debug("REQUESTS", ">", colorPlayerName(sender), SHARES_COLOR, "requests snapshot.", formatSyncStatus(status))
+	-- 	end
+	-- 	if data.type == "requests-index" then
+	-- 		GBankClassic_Output:Debug("REQUESTS", ">", colorPlayerName(sender), SHARES_COLOR, "requests index.")
+	-- 		GBankClassic_Guild:ReceiveRequestsIndex(data, sender)
+	-- 	end
+	-- 	if data.type == "requests-by-id" then
+	-- 		local status = GBankClassic_Guild:ReceiveRequestsById(data)
+	-- 		GBankClassic_Output:Debug("REQUESTS", ">", colorPlayerName(sender), SHARES_COLOR, "requests by-id data.", formatSyncStatus(status))
+	-- 	end
+	-- 	if data.type == "requests-log" then
+	-- 		GBankClassic_Output:Debug("REQUESTS", ">", colorPlayerName(sender), SHARES_COLOR, "request mutations.")
+	-- 		GBankClassic_Guild:ReceiveRequestMutations(data, sender)
+	-- 	end
+	-- end
 
 	if prefix == "gbank-h" then
 		GBankClassic_Guild:Hello("reply")
 	end
 
 	if prefix == "gbank-hr" then
-		self:Debug("PROTOCOL", data)
+		GBankClassic_Output:Debug("PROTOCOL", data)
 	end
 
 	if prefix == "gbank-s" then
@@ -898,14 +916,13 @@ local COMMAND_REGISTRY = {
 		name = "help",
 		help = "this message",
 		handler = function()
-			GBankClassic_Chat:ShowHelp()
+			Chat:ShowHelp()
 		end,
 	},
 	{
 		name = "version",
 		help = "display the GBankClassic version",
 		handler = function()
-            local GetAddOnMetadata = GetAddOnMetadata or C_AddOns.GetAddOnMetadata
 			local version = GetAddOnMetadata("GBankClassic", "Version") or "unknown"
 			GBankClassic_Output:Response("GBankClassic version:", version)
 		end,
@@ -914,7 +931,7 @@ local COMMAND_REGISTRY = {
 		name = "sync",
 		help = "manually receive the latest data from other online users with guild bank data; this is done every 10 minutes automatically",
 		handler = function()
-			GBankClassic_Chat:PerformSync()
+			Chat:PerformSync()
 		end,
 	},
 	{
@@ -934,197 +951,250 @@ local COMMAND_REGISTRY = {
 			if not guild then
 				return
 			end
+
 			GBankClassic_Guild:Reset(guild)
 		end,
 	},
-	-- Expert commands
+	-- Expert commands (alphabetically sorted)
 	{
-		name = "roster",
-		help = "guild banks and members that can read the officer note can use this command to share updated roster data with online guild members",
+		name = "clearhistory",
+		help = "clear delta chain history (removes saved deltas)",
 		expert = true,
 		handler = function()
-			GBankClassic_Guild:AuthorRosterData()
+			local guild = GBankClassic_Guild:GetGuild()
+			if not guild then
+				GBankClassic_Output:Response("Not in a guild")
+
+				return
+			end
+			local db = GBankClassic_Database.db.factionrealm[guild]
+			if db and db.deltaHistory then
+				local count = 0
+				for _, deltas in pairs(db.deltaHistory) do
+					if type(deltas) == "table" then
+						count = count + #deltas
+					end
+				end
+				db.deltaHistory = {}
+				GBankClassic_Output:Response("Cleared %d delta(s) from history", count)
+			else
+				GBankClassic_Output:Response("No delta history to clear")
+			end
 		end,
 	},
 	{
-		name = "hello",
-		help = "understand which online guild members use which addon version and know what guild bank data",
+		name = "clearsnapshots",
+		help = "clear all delta snapshots (forces full syncs next time)",
 		expert = true,
 		handler = function()
-			GBankClassic_Guild:Hello()
+			local guild = GBankClassic_Guild:GetGuild()
+			if not guild then
+				GBankClassic_Output:Response("Not in a guild")
+
+				return
+			end
+			local db = GBankClassic_Database.db.factionrealm[guild]
+			if db and db.deltaSnapshots then
+				local count = GBankClassic_Globals:Count(db.deltaSnapshots)
+				db.deltaSnapshots = {}
+				GBankClassic_Output:Response("Cleared %d delta snapshot(s)", count)
+			else
+				GBankClassic_Output:Response("No snapshots to clear")
+			end
 		end,
 	},
+	-- {
+	-- 	name = "compact",
+	-- 	help = "manually run compaction to prune old requests and tombstones",
+	-- 	expert = true,
+	-- 	handler = function()
+	-- 		GBankClassic_Guild:Compact()
+	-- 	end,
+	-- },
 	{
-		name = "versions",
-		help = "show addon versions of online guild members",
+		name = "deltaerrors",
+		help = "show recent delta sync errors and failure counts",
 		expert = true,
 		handler = function()
-			GBankClassic_Chat:PrintVersions()
+			Chat:PrintDeltaErrors()
 		end,
 	},
 	{
-		name = "deltastats",
-		help = "show delta sync statistics and bandwidth savings",
+		name = "clear-delta-errors",
+		help = "clear all recorded delta sync errors",
 		expert = true,
 		handler = function()
-			GBankClassic_Chat:PrintDeltaStats()
+			local guild = GBankClassic_Guild:GetGuild()
+			if not guild then
+				GBankClassic_Output:Response("Not in a guild")
+
+				return
+			end
+			
+			local db = GBankClassic_Database.db.factionrealm[guild]
+			if db and db.deltaErrors then
+				db.deltaErrors.lastErrors = {}
+				db.deltaErrors.failureCounts = {}
+				db.deltaErrors.notifiedAlts = {}
+				GBankClassic_Output:Response("Cleared all delta sync errors")
+			else
+				GBankClassic_Output:Response("No delta errors to clear")
+			end
 		end,
 	},
 	{
-		name = "deltaerrors",
-		help = "show recent delta sync errors and failure counts",
+		name = "deltahistory",
+		help = "show stored delta chain history for offline recovery",
 		expert = true,
 		handler = function()
-			GBankClassic_Chat:PrintDeltaErrors()
+			Chat:PrintDeltaHistory()
 		end,
 	},
 	{
-		name = "deltahistory",
-		help = "show stored delta chain history for offline recovery",
+		name = "deltastats",
+		help = "show delta sync statistics and bandwidth savings",
 		expert = true,
 		handler = function()
-			GBankClassic_Chat:PrintDeltaHistory()
+			Chat:PrintDeltaStats()
 		end,
 	},
 	{
-		name = "perfstats",
-		help = "show performance metrics for current session",
+		name = "debugtab",
+		help = "create a dedicated chat tab for debug output",
 		expert = true,
 		handler = function()
-			GBankClassic_Performance:PrintReport()
+			if GBankClassic_Output:CreateDebugTab() then
+				GBankClassic_Output:Response("Debug output will now appear in 'GBankClassicDebug' tab")
+				GBankClassic_Output:Response("Use /bank debug to enable debug logging")
+			end
 		end,
 	},
 	{
-		name = "protocol",
-		help = "show protocol version distribution across guild members",
+		name = "debugtabremove",
+		help = "remove the GBankClassicDebug chat tab",
 		expert = true,
 		handler = function()
-			GBankClassic_Chat:PrintProtocolInfo()
+			GBankClassic_Output:RemoveDebugTab()
 		end,
 	},
 	{
-		name = "clearsnapshots",
-		help = "clear all delta snapshots (forces full syncs next time)",
+		name = "hello",
+		help = "understand which online guild members use which addon version and know what guild bank data",
 		expert = true,
 		handler = function()
-			local guild = GBankClassic_Guild:GetGuild()
-			if not guild then
-				GBankClassic_Output:Response("Not in a guild")
-				return
-			end
-			local db = GBankClassic_Database.db.factionrealm[guild]
-			if db and db.deltaSnapshots then
-				local count = 0
-				for _ in pairs(db.deltaSnapshots) do
-					count = count + 1
-				end
-				db.deltaSnapshots = {}
-				GBankClassic_Output:Response("Cleared %d delta snapshot(s)", count)
-			else
-				GBankClassic_Output:Response("No snapshots to clear")
-			end
+			GBankClassic_Guild:Hello()
 		end,
 	},
+	-- {
+	-- 	name = "persistcheck",
+	-- 	help = "check current request persistence state",
+	-- 	expert = true,
+	-- 	handler = function()
+	-- 		if not GBankClassic_Guild or not GBankClassic_Guild.Info then
+	-- 			GBankClassic_Output:Response("Guild info not loaded")
+
+	-- 			return
+	-- 		end
+
+	-- 		local logCount = #(GBankClassic_Guild.Info.requestLog or {})
+	-- 		local appliedCount = 0
+	-- 		local appliedActors = {}
+	-- 		if GBankClassic_Guild.Info.requestLogApplied then
+	-- 			for actor, seq in pairs(GBankClassic_Guild.Info.requestLogApplied) do
+	-- 				appliedCount = appliedCount + 1
+	-- 				table.insert(appliedActors, string.format("%s=%d", actor, seq))
+	-- 			end
+	-- 		end
+	-- 		local requestCount = #(GBankClassic_Guild.Info.requests or {})
+	-- 		local seqCount = GBankClassic_Guild.Info.requestLogSeq and GBankClassic_Globals:Count(GBankClassic_Guild.Info.requestLogSeq) or 0
+
+	-- 		GBankClassic_Output:Response("=== Request persistence state ===")
+	-- 		GBankClassic_Output:Response("requests: %d items", requestCount)
+	-- 		GBankClassic_Output:Response("requestLog: %d entries", logCount)
+	-- 		GBankClassic_Output:Response("requestLogApplied: %d actors", appliedCount)
+	-- 		if appliedCount > 0 then
+	-- 			GBankClassic_Output:Response("  %s", table.concat(appliedActors, ", "))
+	-- 		end
+	-- 		GBankClassic_Output:Response("requestLogSeq: %d actors", seqCount)
+
+	-- 		-- Check if data is referencing SavedVariables
+	-- 		local db = GBankClassic_Database and GBankClassic_Database.db
+	-- 		if db and db.faction then
+	-- 			local guildName = GBankClassic_Guild:GetGuild()
+	-- 			if guildName and db.faction[guildName] then
+	-- 				local isSameRef = (GBankClassic_Guild.Info == db.faction[guildName])
+	-- 				GBankClassic_Output:Response("Guild.Info %s SavedVariables reference", isSameRef and "is" or "is not")
+	-- 			end
+	-- 		end
+	-- 	end,
+	-- },
+	-- {
+	-- 	name = "requestlog",
+	-- 	usage = "[N|all]",
+	-- 	help = "print the request log, optionally limited to N entries",
+	-- 	expert = true,
+	-- 	handler = function(arg1)
+	-- 		GBankClassic_Guild:PrintRequestLog(arg1)
+	-- 	end,
+	-- },
 	{
-		name = "clearhistory",
-		help = "clear delta chain history (removes saved deltas)",
+		name = "resetmetrics",
+		help = "reset delta sync statistics and metrics",
 		expert = true,
 		handler = function()
 			local guild = GBankClassic_Guild:GetGuild()
 			if not guild then
 				GBankClassic_Output:Response("Not in a guild")
+
 				return
 			end
-			local db = GBankClassic_Database.db.factionrealm[guild]
-			if db and db.deltaHistory then
-				local count = 0
-				for _, deltas in pairs(db.deltaHistory) do
-					if type(deltas) == "table" then
-						count = count + #deltas
-					end
-				end
-				db.deltaHistory = {}
-				GBankClassic_Output:Response("Cleared %d delta(s) from history", count)
-			else
-				GBankClassic_Output:Response("No delta history to clear")
-			end
-		end,
-	},
-	{
-		name = "forcedelta",
-		help = "force delta sync mode (on|off) - bypass thresholds for testing",
-		expert = true,
-		handler = function(arg)
-			if arg == "on" then
-				FEATURES.FORCE_DELTA_SYNC = true
-				FEATURES.FORCE_FULL_SYNC = false
-				GBankClassic_Output:Response("Force delta sync: ENABLED (will always use delta)")
-			elseif arg == "off" then
-				FEATURES.FORCE_DELTA_SYNC = false
-				GBankClassic_Output:Response("Force delta sync: DISABLED (normal behavior)")
-			else
-				local status = FEATURES.FORCE_DELTA_SYNC and "ON" or "OFF"
-				GBankClassic_Output:Response("Force delta sync: %s", status)
-				GBankClassic_Output:Response("Usage: /bank forcedelta [on|off]")
-			end
-		end,
-	},
-	{
-		name = "forcefull",
-		help = "force full sync mode (on|off) - disable delta for testing",
-		expert = true,
-		handler = function(arg)
-			if arg == "on" then
-				FEATURES.FORCE_FULL_SYNC = true
-				FEATURES.FORCE_DELTA_SYNC = false
-				GBankClassic_Output:Response("Force full sync: ENABLED (will never use delta)")
-			elseif arg == "off" then
-				FEATURES.FORCE_FULL_SYNC = false
-				GBankClassic_Output:Response("Force full sync: DISABLED (normal behavior)")
+			if GBankClassic_Database:ResetDeltaMetrics(guild) then
+				GBankClassic_Output:Response("Delta metrics reset")
 			else
-				local status = FEATURES.FORCE_FULL_SYNC and "ON" or "OFF"
-				GBankClassic_Output:Response("Force full sync: %s", status)
-				GBankClassic_Output:Response("Usage: /bank forcefull [on|off]")
+				GBankClassic_Output:Response("Failed to reset metrics")
 			end
 		end,
 	},
 	{
-		name = "forcefull",
-		help = "toggle forcing full sync (disables delta temporarily)",
+		name = "roster",
+		help = "guild banks and members that can read the officer note can use this command to share updated roster data with online guild members",
 		expert = true,
 		handler = function()
-			FEATURES.FORCE_FULL_SYNC = not FEATURES.FORCE_FULL_SYNC
-			if FEATURES.FORCE_FULL_SYNC then
-				GBankClassic_Output:Response("|cffff0000Full sync forced|r - delta sync temporarily disabled")
-			else
-				GBankClassic_Output:Response("|cff00ff00Full sync force removed|r - delta sync re-enabled")
-			end
+			GBankClassic_Guild:AuthorRosterData()
 		end,
 	},
 	{
-		name = "resetmetrics",
-		help = "reset delta sync statistics and metrics",
+		name = "test",
+		help = "run automated delta sync tests (use 'test help' for options)",
 		expert = true,
-		handler = function()
-			local guild = GBankClassic_Guild:GetGuild()
-			if not guild then
-				GBankClassic_Output:Response("Not in a guild")
+		handler = function(arg)
+			if not GBankClassic_Tests then
+				GBankClassic_Output:Response("Test module not loaded")
+
 				return
 			end
-			if GBankClassic_Database:ResetDeltaMetrics(guild) then
-				GBankClassic_Output:Response("Delta metrics reset")
+
+			arg = arg and arg:trim():lower() or ""
+
+			if arg == "" or arg == "all" then
+				GBankClassic_Tests:RunAllTests()
+			elseif arg == "help" then
+				GBankClassic_Output:Response("GBankClassic test commands:")
+				GBankClassic_Output:Response("  /bank test - Run all tests")
+				GBankClassic_Output:Response("  /bank test all - Run all tests")
+				GBankClassic_Output:Response("  /bank test <test-name> - Run specific test")
+				GBankClassic_Output:Response("  /bank test help - Show this help")
 			else
-				GBankClassic_Output:Response("Failed to reset metrics")
+				GBankClassic_Tests:RunTest(arg)
 			end
 		end,
 	},
 	{
-		name = "requestlog",
-		usage = "[N|all]",
-		help = "print the request log, optionally limited to N entries",
+		name = "versions",
+		help = "show addon versions of online guild members",
 		expert = true,
-		handler = function(arg1)
-			GBankClassic_Guild:PrintRequestLog(arg1)
+		handler = function()
+			Chat:PrintVersions()
 		end,
 	},
 	{
@@ -1167,154 +1237,34 @@ local COMMAND_REGISTRY = {
 				GBankClassic_Output:Response("Debug: off (log level: " .. levelName .. ")")
 			else
 				-- Save current level before entering debug mode
-				preDebugLogLevel = GBankClassic_Options.db.global.bank["logLevel"]
+				preDebugLogLevel = GBankClassic_Options:GetLogLevel()
 				GBankClassic_Output:SetLevel(LOG_LEVEL.DEBUG)
 				GBankClassic_Options.db.global.bank["logLevel"] = LOG_LEVEL.DEBUG
 				GBankClassic_Output:Response("Debug: on (log level: Debug)")
 			end
 		end,
 	},
-	{
-		name = "debugtab",
-		help = "create a dedicated chat tab for debug output",
-		expert = true,
-		handler = function()
-			if GBankClassic_Output:CreateDebugTab() then
-				GBankClassic_Output:Response("Debug output will now appear in 'GBankClassicDebug' tab")
-				GBankClassic_Output:Response("Use /bank debug to enable debug logging")
-			end
-		end,
-	},
-	{
-		name = "debugtabremove",
-		help = "remove the GBankClassicDebug chat tab",
-		expert = true,
-		handler = function()
-			GBankClassic_Output:RemoveDebugTab()
-		end,
-	},
-	{
-		name = "debuglog",
-		usage = "[N] [filter]",
-		help = "export last N debug log entries (default 500), optionally filtered by keyword",
-		expert = true,
-		handler = function(arg1)
-			local args = arg1 and arg1:trim() or ""
-			local count, filter = 500, nil
-
-			-- Parse arguments: first is count, rest is filter
-			if args ~= "" then
-				local firstSpace = args:find(" ")
-				if firstSpace then
-					count = tonumber(args:sub(1, firstSpace - 1)) or 500
-					filter = args:sub(firstSpace + 1):trim()
-					if filter == "" then filter = nil end
-				else
-					count = tonumber(args) or 500
-				end
-			end
-
-			local log, matchCount = GBankClassic_Output:ExportPersistentLogCompact(count, filter)
-			if log == "" then
-				GBankClassic_Output:Response("No debug log entries found")
-			else
-				if filter then
-					GBankClassic_Output:Response("Last %d debug log entries (filtered: '%s', %d matches):", count, filter, matchCount)
-				else
-					GBankClassic_Output:Response("Last %d debug log entries:", count)
-				end
-				GBankClassic_Output:Response(log)
-			end
-		end,
-	},
-	{
-		name = "debuglogclear",
-		help = "clear all persistent debug log entries",
-		expert = true,
-		handler = function()
-			GBankClassic_Output:ClearPersistentLog()
-		end,
-	},
-	{
-		name = "debuglogsave",
-		help = "manually save debug log to SavedVariables (normally done on logout)",
-		expert = true,
-		handler = function()
-			GBankClassic_Output:SavePersistentLog()
-			GBankClassic_Output:Response("Persistent debug log saved")
-		end,
-	},
-	{
-		name = "debuglogstats",
-		help = "show statistics about the persistent debug log",
-		expert = true,
-		handler = function()
-			local count = #GBankClassic_Output.persistentLog
-			if count == 0 then
-				GBankClassic_Output:Response("No debug log entries")
-				return
-			end
-
-			local oldest = GBankClassic_Output.persistentLog[1]
-			local newest = GBankClassic_Output.persistentLog[count]
-			local oldestTime = date("%Y-%m-%d %H:%M:%S", oldest.timestamp)
-			local newestTime = date("%Y-%m-%d %H:%M:%S", newest.timestamp)
-			local ageSeconds = newest.timestamp - oldest.timestamp
-			local ageDays = ageSeconds / 86400
-
-			GBankClassic_Output:Response("Debug log: %d entries", count)
-			GBankClassic_Output:Response("Oldest: %s", oldestTime)
-			GBankClassic_Output:Response("Newest: %s", newestTime)
-			GBankClassic_Output:Response("Span: %.1f days", ageDays)
-			GBankClassic_Output:Response("Max entries: %d", GBankClassic_Output.persistentLogMaxEntries)
-			GBankClassic_Output:Response("Max age: %d days", GBankClassic_Output.persistentLogMaxAge / 86400)
-		end,
-	},
-	{
-		name = "test",
-		help = "run automated delta sync tests (use 'test help' for options)",
-		expert = true,
-		handler = function(arg)
-			if not GBankClassic_Tests then
-				GBankClassic_Output:Response("Test module not loaded")
-				return
-			end
-
-			arg = arg and arg:trim():lower() or ""
-
-			if arg == "" or arg == "all" then
-				GBankClassic_Tests:RunAllTests()
-			elseif arg == "help" then
-				GBankClassic_Output:Response("GBank Test Commands:")
-				GBankClassic_Output:Response("  /bank test - Run all tests")
-				GBankClassic_Output:Response("  /bank test all - Run all tests")
-				GBankClassic_Output:Response("  /bank test <test-name> - Run specific test")
-				GBankClassic_Output:Response("  /bank test help - Show this help")
-			else
-				GBankClassic_Tests:RunTest(arg)
-			end
-		end,
-	},
 	{
 		name = "debugdump",
 		handler = function()
-			local G = GBankClassic_Guild
-			if not G or not G.Info or not G.Info.alts then
-				GBankClassic_Output:Response("no alts table available")
+			local GBankClassic_Guild = GBankClassic_Guild
+			if not GBankClassic_Guild or not GBankClassic_Guild.Info or not GBankClassic_Guild.Info.alts then
+				GBankClassic_Output:Response("No alts table available")
+
 				return
 			end
-			GBankClassic_Output:Response("Listing Info.alts keys:")
+			GBankClassic_Output:Response("Listing keys in alts table:")
 			local i = 0
-			for k, v in pairs(G.Info.alts) do
+			for k, v in pairs(GBankClassic_Guild.Info.alts) do
 				i = i + 1
 				GBankClassic_Output:Response(i, tostring(k), type(v))
 				if i >= 200 then
-					GBankClassic_Output:Response("truncated at 200 entries")
+					GBankClassic_Output:Response("Truncated at 200 entries")
 					break
 				end
 			end
 			if i == 0 then
-				GBankClassic_Output:Response("no entries")
+				GBankClassic_Output:Response("No entries")
 			end
 		end,
 	},
@@ -1349,7 +1299,7 @@ local HELP_INSTRUCTIONS = {
 	},
 }
 
-function GBankClassic_Chat:ChatCommand(input)
+function Chat:ChatCommand(input)
 	if input == nil or input == "" then
 		GBankClassic_UI_Inventory:Toggle()
 	else
@@ -1359,14 +1309,14 @@ function GBankClassic_Chat:ChatCommand(input)
 			handler(arg1)
 		else
 			GBankClassic_Output:Response("Unknown command: ", prefix)
-			GBankClassic_Chat:ShowHelp()
+			self:ShowHelp()
 		end
 	end
 
 	return false
 end
 
-function GBankClassic_Chat:ShowHelp()
+function Chat:ShowHelp()
 	local H = HELP_COLOR.HEADER
 	local C = HELP_COLOR.COMMAND
 	local R = HELP_COLOR.RESET
@@ -1401,13 +1351,14 @@ function GBankClassic_Chat:ShowHelp()
 	end
 end
 
-function GBankClassic_Chat:ProcessQueue()
+function Chat:ProcessQueue()
 	if IsInRaid() then
 		return
 	end
 
     if #self.sync_queue == 0 then
         self.is_syncing = false
+		
         return
     end
 
@@ -1421,22 +1372,21 @@ function GBankClassic_Chat:ProcessQueue()
 		GBankClassic_Guild:SendAltData(name)
 	end
 
-	GBankClassic_Chat:ReprocessQueue()
+	self:ReprocessQueue()
 end
 
-function GBankClassic_Chat:ReprocessQueue()
+function Chat:ReprocessQueue()
     GBankClassic_Core:ScheduleTimer(function(...)
-        GBankClassic_Chat:OnTimer()
+        self:OnTimer()
     end, TIMER_INTERVALS.ALT_DATA_QUEUE_RETRY)
 end
 
-function GBankClassic_Chat:OnTimer()
-    GBankClassic_Chat:ProcessQueue()
+function Chat:OnTimer()
+    self:ProcessQueue()
 end
 
-function GBankClassic_Chat:PrintVersions()
+function Chat:PrintVersions()
 	-- Get our own version
-    local GetAddOnMetadata = GetAddOnMetadata or C_AddOns.GetAddOnMetadata
 	local myVersion = GetAddOnMetadata("GBankClassic", "Version") or "unknown"
 	local myPlayer = GBankClassic_Guild:GetPlayer()
 
@@ -1444,21 +1394,11 @@ function GBankClassic_Chat:PrintVersions()
 	local versions = {}
 
 	-- Add ourselves
-	table.insert(versions, {
-		name = myPlayer,
-		version = myVersion,
-		seen = time(),
-		isSelf = true,
-	})
+	table.insert(versions, { name = myPlayer, version = myVersion, seen = time(), isSelf = true })
 
 	-- Add tracked guild members
 	for name, info in pairs(self.guild_versions) do
-		table.insert(versions, {
-			name = name,
-			version = tostring(info.version),
-			seen = info.seen,
-			isSelf = false,
-		})
+		table.insert(versions, { name = name, version = tostring(info.version), seen = info.seen, isSelf = false })
 	end
 
 	-- Sort by version (descending), then by name
@@ -1493,7 +1433,7 @@ function GBankClassic_Chat:PrintVersions()
 	end
 end
 
-function GBankClassic_Chat:PrintDeltaStats()
+function Chat:PrintDeltaStats()
 	local guild = GBankClassic_Guild:GetGuild()
 	if not guild then
 		GBankClassic_Output:Response("Not in a guild")
@@ -1529,12 +1469,8 @@ function GBankClassic_Chat:PrintDeltaStats()
 
 	if totalBytes > 0 then
 		GBankClassic_Output:Response("|cffffff00Bandwidth:|r")
-		GBankClassic_Output:Response("  Delta syncs: %s (%.1f%%)",
-			formatBytes(deltaBytes),
-			(deltaBytes / totalBytes) * 100)
-		GBankClassic_Output:Response("  Full syncs:  %s (%.1f%%)",
-			formatBytes(fullBytes),
-			(fullBytes / totalBytes) * 100)
+		GBankClassic_Output:Response("  Delta syncs: %s (%.1f%%)", formatBytes(deltaBytes), (deltaBytes / totalBytes) * 100)
+		GBankClassic_Output:Response("  Full syncs:  %s (%.1f%%)", formatBytes(fullBytes), (fullBytes / totalBytes) * 100)
 		GBankClassic_Output:Response("  Total sent:  %s", formatBytes(totalBytes))
 
 		-- Estimate bandwidth saved (assume delta would have been full sync)
@@ -1546,8 +1482,7 @@ function GBankClassic_Chat:PrintDeltaStats()
 			local saved = estimatedFullBytes - deltaBytes
 			if saved > 0 then
 				local reduction = (saved / estimatedFullBytes) * 100
-				GBankClassic_Output:Response("  |cff00ff00Saved: ~%s (%.1f%% reduction)|r",
-					formatBytes(saved), reduction)
+				GBankClassic_Output:Response("  |cff00ff00Saved: ~%s (%.1f%% reduction)|r", formatBytes(saved), reduction)
 			end
 		end
 		GBankClassic_Output:Response("")
@@ -1566,12 +1501,12 @@ function GBankClassic_Chat:PrintDeltaStats()
 		GBankClassic_Output:Response("  Full sync fallbacks: %d", fullSyncFallbacks)
 
 		local successRate = (deltasApplied / totalOps) * 100
-		local rateColor = "|cff00ff00" -- green
+		local rateColor = "|cff00ff00" -- Green
 		if successRate < 95 then
-			rateColor = "|cffffff00" -- yellow
+			rateColor = "|cffffff00" -- Yellow
 		end
 		if successRate < 80 then
-			rateColor = "|cffff0000" -- red
+			rateColor = "|cffff0000" -- Red
 		end
 		GBankClassic_Output:Response("  Success rate:        %s%.1f%%|r", rateColor, successRate)
 		GBankClassic_Output:Response("")
@@ -1599,7 +1534,7 @@ function GBankClassic_Chat:PrintDeltaStats()
 end
 
 -- Print recent delta errors and failure counts
-function GBankClassic_Chat:PrintDeltaErrors()
+function Chat:PrintDeltaErrors()
 	local guild = GBankClassic_Guild:GetGuild()
 	if not guild then
 		GBankClassic_Output:Response("Not in a guild")
@@ -1658,17 +1593,12 @@ function GBankClassic_Chat:PrintDeltaErrors()
 
 	-- Print summary
 	local totalErrors = #(errors.lastErrors or {})
-	local totalAlts = 0
-	if errors.failureCounts then
-		for _ in pairs(errors.failureCounts) do
-			totalAlts = totalAlts + 1
-		end
-	end
+	local totalAlts = errors.failureCounts and GBankClassic_Globals:Count(errors.failureCounts) or 0
 	GBankClassic_Output:Response("|cffffff00Summary:|r %d error(s) tracked, %d alt(s) affected", totalErrors, totalAlts)
 end
 
 -- Print stored delta chain history
-function GBankClassic_Chat:PrintDeltaHistory()
+function Chat:PrintDeltaHistory()
 	local guild = GBankClassic_Guild:GetGuild()
 	if not guild then
 		GBankClassic_Output:Response("Not in a guild")
@@ -1721,145 +1651,19 @@ function GBankClassic_Chat:PrintDeltaHistory()
 				-- Delta is nested: historyEntry.delta.changes
 				local changes = delta.delta and delta.delta.changes or nil
 				if changes then
-					if changes.bank then changeCount = changeCount + 1 end
-					if changes.bags then changeCount = changeCount + 1 end
-					if changes.money then changeCount = changeCount + 1 end
-				end
-
-				GBankClassic_Output:Response(
-					"  %d. v%dv%d (%d change(s), %s)",
-					i,
-					delta.baseVersion or 0,
-					delta.version or 0,
-					changeCount,
-					ageStr
-				)
-			end
-		end
-	end
-end
-
-function GBankClassic_Chat:PrintProtocolInfo()
-	local guild = GBankClassic_Guild:GetGuild()
-	if not guild then
-		GBankClassic_Output:Response("Not in a guild")
-
-		return
-	end
-
-	GBankClassic_Output:Response("|cff00ffffProtocol Version Distribution|r")
-	GBankClassic_Output:Response("")
-
-	-- Get guild delta support
-	local support = GBankClassic_Database:GetGuildDeltaSupport(guild)
-	local threshold = PROTOCOL.DELTA_SUPPORT_THRESHOLD
-
-	-- Count versions
-	local db = GBankClassic_Database.db.factionrealm[guild]
-	if not db or not db.guildProtocolVersions then
-		GBankClassic_Output:Response("No protocol data available")
-        
-		return
-	end
-
-	local now = GetServerTime()
-	local onlineV1 = 0
-	local onlineV2 = 0
-	local allTimeV1 = 0
-	local allTimeV2 = 0
-	local recentMembers = {}
-
-	for sender, info in pairs(db.guildProtocolVersions) do
-		if info then
-			local version = info.version or 1
-			local isOnline = info.lastSeen and (now - info.lastSeen) < 600
-
-			-- All time counts
-			if version >= 2 then
-				allTimeV2 = allTimeV2 + 1
-			else
-				allTimeV1 = allTimeV1 + 1
-			end
-
-			-- Online counts (last 10 minutes)
-			if isOnline then
-				if version >= 2 then
-					onlineV2 = onlineV2 + 1
-				else
-					onlineV1 = onlineV1 + 1
+					if changes.bank then
+						changeCount = changeCount + 1
+					end
+					if changes.bags then
+						changeCount = changeCount + 1
+					end
+					if changes.money then
+						changeCount = changeCount + 1
+					end
 				end
-			end
-
-			-- Track recent members for display
-			if isOnline then
-				table.insert(recentMembers, {
-					name = sender,
-					version = version,
-					lastSeen = info.lastSeen,
-				})
-			end
-		end
-	end
-
-	-- Sort recent members by last seen
-	table.sort(recentMembers, function(a, b)
-		return a.lastSeen > b.lastSeen
-	end)
-
-	-- Display online distribution
-	local totalOnline = onlineV1 + onlineV2
-	if totalOnline > 0 then
-		GBankClassic_Output:Response("|cffffff00Online (last 10 minutes):|r")
-		GBankClassic_Output:Response("  Protocol v2 (delta): %d (%.1f%%)", onlineV2, (onlineV2 / totalOnline) * 100)
-		GBankClassic_Output:Response("  Protocol v1 (full):  %d (%.1f%%)", onlineV1, (onlineV1 / totalOnline) * 100)
-		GBankClassic_Output:Response("  Total online: %d", totalOnline)
-		GBankClassic_Output:Response("")
-	end
 
-	-- Display all-time distribution
-	local totalAllTime = allTimeV1 + allTimeV2
-	if totalAllTime > 0 then
-		GBankClassic_Output:Response("|cffffff00All time:|r")
-		GBankClassic_Output:Response("  Protocol v2: %d", allTimeV2)
-		GBankClassic_Output:Response("  Protocol v1: %d", allTimeV1)
-		GBankClassic_Output:Response("")
-	end
-
-	-- Display threshold status
-	local statusIcon = support >= threshold and "|cff00ff00|r" or "|cffff0000|r"
-	local statusText = support >= threshold and "enabled" or "disabled"
-	GBankClassic_Output:Response("%s Delta sync %s (%.1f%% %s %.0f%% threshold)",
-		statusIcon, statusText, support * 100,
-		support >= threshold and "" or "<",
-		threshold * 100)
-
-	-- Display recent members
-	if #recentMembers > 0 then
-		GBankClassic_Output:Response("")
-		GBankClassic_Output:Response("|cffffff00Recently seen members:|r")
-		local shown = 0
-		for _, member in ipairs(recentMembers) do
-			if shown >= 10 then
-				GBankClassic_Output:Response("  ... and %d more", #recentMembers - shown)
-				break
+				GBankClassic_Output:Response("  %d. v%d (%d change(s), %s)", i, delta.version or 0, changeCount, ageStr)
 			end
-
-			local age = ""
-			local seconds = now - member.lastSeen
-			if seconds < 60 then
-				age = "now"
-			elseif seconds < 3600 then
-				age = string.format("%dm ago", math.floor(seconds / 60))
-			else
-				age = string.format("%dh ago", math.floor(seconds / 3600))
-			end
-
-			GBankClassic_Output:Response("  %s: v%d (%s)", member.name, member.version, age)
-			shown = shown + 1
 		end
 	end
-
-	if totalOnline == 0 and totalAllTime == 0 then
-		GBankClassic_Output:Response("No protocol version data available")
-	end
 end
\ No newline at end of file
diff --git a/Modules/Constants.lua b/Modules/Constants.lua
index ee0f38e..c69511f 100644
--- a/Modules/Constants.lua
+++ b/Modules/Constants.lua
@@ -15,11 +15,11 @@ TIMER_INTERVALS = {
 
 -- Log levels (lower = more verbose)
 LOG_LEVEL = {
-	DEBUG = 1,       -- development/troubleshooting details
-	INFO = 2,        -- sync status, normal operations
-	WARN = 3,        -- something unexpected but recoverable
-	ERROR = 4,       -- something failed
-	RESPONSE = 5,    -- response to user commands (always shown)
+	DEBUG = 1,       -- Development/troubleshooting details
+	INFO = 2,        -- Sync status, normal operations
+	WARN = 3,        -- Something unexpected but recoverable
+	ERROR = 4,       -- Something failed
+	RESPONSE = 5,    -- Response to user commands (always shown)
 }
 
 -- Debug categories for filtering
@@ -31,22 +31,45 @@ DEBUG_CATEGORY = {
 	CHUNK = "CHUNK",             -- Data synchronization operations specific to chunk sending
 	CACHE = "CACHE",             -- Cache operations (guild roster cache, etc.)
 	WHISPER = "WHISPER",         -- Whisper sends, skips, and online checks
+	-- REQUESTS = "REQUESTS",       -- Request system activity and updates
 	UI = "UI",                   -- UI operations, window opens/closes
 	PROTOCOL = "PROTOCOL",       -- Protocol version negotiation
 	DATABASE = "DATABASE",       -- Database operations, SavedVariables
 	EVENTS = "EVENTS",           -- WoW event handling
+	INVENTORY = "INVENTORY",	 -- Inventory (bags, bank, mail) scanning and tracking
+	MAIL = "MAIL",               -- Mail inventory scanning and tracking
+	ITEM = "ITEM",               -- Item loading, validation, and processing
+	-- FULFILL = "FULFILL",		 -- Request fullfillment by guild bank alts
+	SEARCH = "SEARCH",			 -- Search operations
 }
 
+-- -- Request storage settings
+-- REQUEST_LOG = {
+-- 	EXPIRY_SECONDS = 30 * 24 * 60 * 60,      -- 30 days: completed/cancelled requests and tombstones removed after this
+-- 	PRUNE_INTERVAL = 300,                    -- 5 minutes: minimum interval between automatic prunes
+-- }
+
+-- -- Request sync throttling settings
+-- REQUESTS_SYNC = {
+-- 	-- Short values for quick testing; production values should be higher.
+-- 	INDEX_QUERY_COOLDOWN = 60,         -- Seconds between index queries (global and per-sender)
+-- 	INDEX_INFLIGHT_TIMEOUT = 30,       -- Seconds before in-flight index sync is considered stale
+-- }
+
 -- Communication prefix descriptions for debug logging
 COMM_PREFIX_DESCRIPTIONS = {
 	["gbank-v"] = "(Version)",
 	["gbank-dv"] = "(Delta version)",
-	["gbank-d"] = "(Data - No links)",
-	["gbank-dd"] = "(Delta data - No links)",
-	["gbank-dr"] = "(Delta range request)",
-	["gbank-dc"] = "(Delta chain)",
+	["gbank-dv2"] = "(Delta version - Aggregate items)",
+	["gbank-d"] = "(Data - No links)", -- togbank-d3 (we're not using togbank-d)
+	["gbank-dd"] = "(Delta data - No links)", -- togbank-d4 (we're not using togbank-d2)
+	-- ["gbank-dr"] = "(Delta range request)",
+	-- ["gbank-dc"] = "(Delta chain)",
 	["gbank-r"] = "(Query)",
 	["gbank-rr"] = "(Query reply)",
+	-- ["gbank-rq"] = "(Request query)",
+	-- ["gbank-rd"] = "(Request data)",
+	-- ["gbank-rm"] = "(Request mutations)",
 	["gbank-state"] = "(State summary)",
 	["gbank-nochange"] = "(No change)",
 	["gbank-h"] = "(Hello)",
@@ -61,18 +84,8 @@ COMM_PREFIX_DESCRIPTIONS = {
 PROTOCOL = {
 	VERSION = 2,                    -- Current protocol version (bump for breaking changes)
 	SUPPORTS_DELTA = true,          -- This client supports delta updates
-	MIN_DELTA_SIZE_RATIO = 0.3,     -- Only use delta if <30% of full sync size
 	DELTA_SNAPSHOT_MAX_AGE = 3600,  -- 1 hour: snapshots older than this are invalid
-	DELTA_SUPPORT_THRESHOLD = 0.05, -- Use delta if >5% of online guild supports it (lowered for testing: 1 of 14 = 7.1%)
 	DELTA_HISTORY_MAX_COUNT = 10,   -- Keep last N deltas per alt (memory limit)
-	DELTA_HISTORY_MAX_AGE = 3600,   -- 1 hour: purge deltas older than this
 	DELTA_CHAIN_MAX_HOPS = 30,      -- Max deltas in one chain request (increased for testing)
 	DELTA_CHAIN_MAX_SIZE = 5000,    -- If chain >5KB, fall back to full sync
-}
-
--- Feature flags (for easy enable/disable during development/testing)
-FEATURES = {
-	DELTA_ENABLED = true,           -- Enable delta sync protocol
-	FORCE_DELTA_SYNC = false,       -- Force delta sync (bypass thresholds) for testing
-	FORCE_FULL_SYNC = false,        -- Force full sync (disable delta) for testing
 }
\ No newline at end of file
diff --git a/Modules/Database.lua b/Modules/Database.lua
index 5b9c351..cfdd92e 100644
--- a/Modules/Database.lua
+++ b/Modules/Database.lua
@@ -1,6 +1,13 @@
-GBankClassic_Database = {}
+GBankClassic_Database = GBankClassic_Database or {}
 
-function GBankClassic_Database:Init()
+local Database = GBankClassic_Database
+
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("LibStub", "GetServerTime")
+local LibStub = upvalues.LibStub
+local GetServerTime = upvalues.GetServerTime
+
+function Database:Init()
     self.db = LibStub("AceDB-3.0"):New("GBankClassicDB", {
 		global = {
 			debugCategories = {
@@ -11,16 +18,22 @@ function GBankClassic_Database:Init()
 				CHUNK = false,
 				CACHE = false,
 				WHISPER = false,
+				-- REQUESTS = false,
 				UI = false,
 				PROTOCOL = false,
 				DATABASE = false,
 				EVENTS = false,
+				INVENTORY = false,
+				MAIL = false,
+				ITEM = false,
+				-- FULFILL = false,
+				SEARCH = false,
 			},
 		},
 	})
 end
 
-function GBankClassic_Database:Reset(name)
+function Database:Reset(name)
 	if not name then
 		return
 	end
@@ -29,6 +42,12 @@ function GBankClassic_Database:Reset(name)
         name = name,
         roster = {},
         alts = {},
+		-- requests = {},
+		-- requestsVersion = 0,
+		-- requestsTombstones = {},
+		-- settings = {
+		-- 	maxRequestPercent = 100, -- Default to no limit
+		-- },
 		deltaSnapshots = {},
 		deltaHistory = {},
 		guildProtocolVersions = {},
@@ -49,7 +68,7 @@ function GBankClassic_Database:Reset(name)
 	GBankClassic_Output:Response("Reset database")
 end
 
-function GBankClassic_Database:ResetPlayer(name, player)
+function Database:ResetPlayer(name, player)
 	if not name then
 		return
 	end
@@ -62,23 +81,111 @@ function GBankClassic_Database:ResetPlayer(name, player)
 
     self.db.factionrealm[name].alts[player] = {}
 
-    GBankClassic_Core:Print("Reset player database")
+    GBankClassic_Core:Response("Reset player database")
 end
 
-function GBankClassic_Database:Load(name)
+function Database:Load(name)
 	if not name then
 		return
 	end
 
     local db = self.db.factionrealm[name]
 
-    if db == nil or db.roster == nil then
-        GBankClassic_Database:Reset(name)
+	-- Only reset if there's truly no data (nil). Otherwise initialize missing fields.
+	-- This prevents data loss when some fields are missing but others (like requests) exist.
+	if db == nil then
+        self:Reset(name)
         db = self.db.factionrealm[name]
-    elseif db.name == nil then
-        db.name = name
+    else
+		-- Initialize missing fields without wiping existing data
+		if db.name == nil then
+			db.name = name
+		end
+		if db.roster == nil then
+			db.roster = {}
+		end
+		if db.alts == nil then
+			db.alts = {}
+		end
     end
 
+	-- Migrate old alt data to ensure slots fields exist
+	-- Characters may have bank/bags without slots
+	if db.alts then
+		for name, alt in pairs(db.alts) do
+			if type(alt) == "table" then
+				if alt.bank and not alt.bank.slots then
+					alt.bank.slots = { count = 0, total = 0 }
+					GBankClassic_Output:Debug("DATABASE", "Migrated alt data: initialized bank.slots for %s", name)
+				end
+				if alt.bags and not alt.bags.slots then
+					alt.bags.slots = { count = 0, total = 0 }
+					GBankClassic_Output:Debug("DATABASE", "Migrated alt data: initialized bags.slots for %s", name)
+				end
+				-- Compute inventory hash for alts that don't have one
+				-- This enables pull-based protocol for existing alt data
+				if not alt.inventoryHash and alt.bank and alt.bags then
+					local money = alt.money or 0
+					alt.inventoryHash = GBankClassic_DeltaComms:ComputeInventoryHash(alt.bank, alt.bags, money)
+				GBankClassic_Output:Debug("DATABASE", "Migrated alt data: computed inventory hash for %s (hash=%d)", name, alt.inventoryHash)
+				end
+				-- Recalculate aggregated items from bank/bags/mail with corrected aggregate function
+				-- This fixes item count duplication without requiring a full scan
+				-- Clear and rebuild alt.items on every load to prevent accumulation
+				if (alt.bank and alt.bank.items) or (alt.bags and alt.bags.items) or (alt.mail and alt.mail.items) then
+					-- Guild bank alt with bank/bags - force reconstruct from sources
+					-- Log sample counts before clearing
+					if alt.items and #alt.items > 0 then
+						local beforeSample = {}
+						for i = 1, math.min(5, #alt.items) do
+							local item = alt.items[i]
+							if item then
+								table.insert(beforeSample, string.format("%s:%d", item.ID or "?", item.Count or 0))
+							end
+						end
+						GBankClassic_Output:Debug("DATABASE", "Before clear - guild bank alt %s alt.items: %s", name, table.concat(beforeSample, ", "))
+					end
+
+					alt.items = nil -- Clear corrupted data
+					GBankClassic_Bank:RecalculateAggregatedItems(alt)
+
+					-- Log sample counts after recalculation
+					if alt.items and #alt.items > 0 then
+						local afterSample = {}
+						for i = 1, math.min(5, #alt.items) do
+							local item = alt.items[i]
+							if item then
+								table.insert(afterSample, string.format("%s:%d", item.ID or "?", item.Count or 0))
+							end
+						end
+						GBankClassic_Output:Debug("DATABASE", "After recalc - guild bank alt %s alt.items: %s", name, table.concat(afterSample, ", "))
+					end
+
+					GBankClassic_Output:Debug("DATABASE", "Forced recalculation for guild bank alt %s from bank/bags/mail", name)
+				elseif alt.items then
+					-- Synced alt - force deduplicate
+					-- Do not merge mail here - alt.items from sync already includes mail from sender's scan
+					local aggregated = GBankClassic_Item:Aggregate(alt.items, nil)
+					alt.items = {}
+					for _, item in pairs(aggregated) do
+						table.insert(alt.items, item)
+					end
+					GBankClassic_Output:Debug("DATABASE", "Forced deduplication for synced guild bank alt %s: %d items", name, #alt.items)
+				end
+			end
+		end
+	end
+
+	-- if not db.requests then
+	-- 	db.requests = {}
+	-- end
+	-- if not db.requestsVersion then
+	-- 	db.requestsVersion = 0
+	-- end
+	-- if not db.requestsTombstones then
+	-- 	db.requestsTombstones = {}
+	-- end
+
 	if not db.deltaSnapshots then
 		db.deltaSnapshots = {}
 	end
@@ -111,7 +218,7 @@ end
 -- Snapshot management functions
 
 -- Save a snapshot of alt data for future delta computation
-function GBankClassic_Database:SaveSnapshot(name, altName, altData)
+function Database:SaveSnapshot(name, altName, altData)
 	if not name or not altName or not altData then
 		return false
 	end
@@ -123,7 +230,7 @@ function GBankClassic_Database:SaveSnapshot(name, altName, altData)
 
 	-- Create a deep copy with timestamp
 	db.deltaSnapshots[altName] = {
-		data = GBankClassic_Database:DeepCopy(altData),
+		data = self:DeepCopy(altData),
 		timestamp = GetServerTime(),
 	}
 
@@ -131,7 +238,7 @@ function GBankClassic_Database:SaveSnapshot(name, altName, altData)
 end
 
 -- Retrieve a snapshot of alt data for delta computation
-function GBankClassic_Database:GetSnapshot(name, altName)
+function Database:GetSnapshot(name, altName)
 	if not name or not altName then
 		return nil
 	end
@@ -151,6 +258,7 @@ function GBankClassic_Database:GetSnapshot(name, altName)
 	if age > PROTOCOL.DELTA_SNAPSHOT_MAX_AGE then
 		-- Snapshot expired, remove it
 		db.deltaSnapshots[altName] = nil
+
 		return nil
 	end
 
@@ -158,6 +266,7 @@ function GBankClassic_Database:GetSnapshot(name, altName)
 	if not self:ValidateSnapshot(snapshot.data) then
 		-- Corrupted snapshot, remove it
 		db.deltaSnapshots[altName] = nil
+		
 		return nil
 	end
 
@@ -165,7 +274,7 @@ function GBankClassic_Database:GetSnapshot(name, altName)
 end
 
 -- Validate snapshot structure
-function GBankClassic_Database:ValidateSnapshot(snapshot)
+function Database:ValidateSnapshot(snapshot)
 	if not snapshot or type(snapshot) ~= "table" then
 		return false
 	end
@@ -198,57 +307,8 @@ function GBankClassic_Database:ValidateSnapshot(snapshot)
 	return true
 end
 
--- Get the age of a snapshot in seconds
-function GBankClassic_Database:GetSnapshotAge(name, altName)
-	if not name or not altName then
-		return nil
-	end
-
-	local db = self.db.factionrealm[name]
-	if not db or not db.deltaSnapshots then
-		return nil
-	end
-
-	local snapshot = db.deltaSnapshots[altName]
-	if not snapshot or not snapshot.timestamp then
-		return nil
-	end
-
-	return GetServerTime() - snapshot.timestamp
-end
-
--- Clean up old snapshots (older than DELTA_SNAPSHOT_MAX_AGE)
-function GBankClassic_Database:CleanupOldSnapshots(name)
-	if not name then
-		return 0
-	end
-
-	local db = self.db.factionrealm[name]
-	if not db or not db.deltaSnapshots then
-		return 0
-	end
-
-	local currentTime = GetServerTime()
-	local removed = 0
-	for altName, snapshot in pairs(db.deltaSnapshots) do
-		if snapshot and snapshot.timestamp then
-			local age = currentTime - snapshot.timestamp
-			if age > PROTOCOL.DELTA_SNAPSHOT_MAX_AGE then
-				db.deltaSnapshots[altName] = nil
-				removed = removed + 1
-			end
-		else
-			-- Malformed snapshot, remove it
-			db.deltaSnapshots[altName] = nil
-			removed = removed + 1
-		end
-	end
-
-	return removed
-end
-
 -- Deep copy function for snapshot creation
-function GBankClassic_Database:DeepCopy(obj)
+function Database:DeepCopy(obj)
 	if type(obj) ~= "table" then
 		return obj
 	end
@@ -264,8 +324,8 @@ end
 -- Delta history management
 
 -- Save a delta to history for potential chain replay
-function GBankClassic_Database:SaveDeltaHistory(name, altName, baseVersion, version, delta)
-	if not name or not altName or not baseVersion or not version or not delta then
+function Database:SaveDeltaHistory(name, altName, previousVersion, version, delta)
+	if not name or not altName or not previousVersion or not version or not delta then
 		return false
 	end
 
@@ -283,12 +343,7 @@ function GBankClassic_Database:SaveDeltaHistory(name, altName, baseVersion, vers
 	end
 
 	-- Add delta to history
-	table.insert(db.deltaHistory[altName], {
-		baseVersion = baseVersion,
-		version = version,
-		delta = self:DeepCopy(delta), -- Deep copy to prevent mutation
-		timestamp = GetServerTime()
-	})
+	table.insert(db.deltaHistory[altName], { previousVersion = previousVersion, version = version, delta = self:DeepCopy(delta), timestamp = GetServerTime() })
 
 	-- Enforce max count limit (keep most recent)
 	local maxCount = PROTOCOL.DELTA_HISTORY_MAX_COUNT or 10
@@ -300,7 +355,7 @@ function GBankClassic_Database:SaveDeltaHistory(name, altName, baseVersion, vers
 end
 
 -- Get delta history for an alt within a version range
-function GBankClassic_Database:GetDeltaHistory(name, altName, fromVersion, toVersion)
+function Database:GetDeltaHistory(name, altName, fromVersion, toVersion)
 	if not name or not altName then
 		return nil
 	end
@@ -315,12 +370,8 @@ function GBankClassic_Database:GetDeltaHistory(name, altName, fromVersion, toVer
 	local currentVersion = fromVersion
 
 	for _, deltaEntry in ipairs(db.deltaHistory[altName]) do
-		if deltaEntry.baseVersion == currentVersion and deltaEntry.version <= toVersion then
-			table.insert(chain, {
-				baseVersion = deltaEntry.baseVersion,
-				version = deltaEntry.version,
-				delta = deltaEntry.delta
-			})
+		if deltaEntry.previousVersion == currentVersion and deltaEntry.version <= toVersion then
+			table.insert(chain, { previousVersion = deltaEntry.previousVersion, version = deltaEntry.version, delta = deltaEntry.delta })
 			currentVersion = deltaEntry.version
 
 			-- Stop if we've reached the target
@@ -338,54 +389,10 @@ function GBankClassic_Database:GetDeltaHistory(name, altName, fromVersion, toVer
 	return chain
 end
 
--- Clean up old delta history (older than DELTA_HISTORY_MAX_AGE)
-function GBankClassic_Database:CleanupDeltaHistory(name)
-	if not name then
-		return 0
-	end
-
-	local db = self.db.factionrealm[name]
-	if not db or not db.deltaHistory then
-		return 0
-	end
-
-	local currentTime = GetServerTime()
-	local maxAge = PROTOCOL.DELTA_HISTORY_MAX_AGE or 3600
-	local totalRemoved = 0
-	for altName, history in pairs(db.deltaHistory) do
-		if type(history) == "table" then
-			-- Remove old entries
-			local i = 1
-			while i <= #history do
-				if history[i] and history[i].timestamp then
-					local age = currentTime - history[i].timestamp
-					if age > maxAge then
-						table.remove(history, i)
-						totalRemoved = totalRemoved + 1
-					else
-						i = i + 1
-					end
-				else
-					-- Malformed entry
-					table.remove(history, i)
-					totalRemoved = totalRemoved + 1
-				end
-			end
-
-			-- Remove empty histories
-			if #history == 0 then
-				db.deltaHistory[altName] = nil
-			end
-		end
-	end
-
-	return totalRemoved
-end
-
 -- Protocol version tracking
 
 -- Update protocol version for a guild member
-function GBankClassic_Database:UpdatePeerProtocol(name, sender, protocolVersion, supportsDelta)
+function Database:UpdatePeerProtocol(name, sender, protocolVersion, supportsDelta)
 	if not name or not sender then
 		return false
 	end
@@ -405,7 +412,7 @@ function GBankClassic_Database:UpdatePeerProtocol(name, sender, protocolVersion,
 end
 
 -- Get protocol version for a guild member
-function GBankClassic_Database:GetPeerProtocol(name, sender)
+function Database:GetPeerProtocol(name, sender)
 	if not name or not sender then
 		return nil
 	end
@@ -418,42 +425,10 @@ function GBankClassic_Database:GetPeerProtocol(name, sender)
 	return db.guildProtocolVersions[sender]
 end
 
--- Calculate percentage of online guild members supporting delta
-function GBankClassic_Database:GetGuildDeltaSupport(name)
-	if not name then
-		return 0
-	end
-
-	local db = self.db.factionrealm[name]
-	if not db or not db.guildProtocolVersions then
-		return 0
-	end
-
-	local total = 0
-	local supporting = 0
-	local currentTime = GetServerTime()
-
-	-- Only count members seen in last 10 minutes (considered online)
-	for _, info in pairs(db.guildProtocolVersions) do
-		if info and info.lastSeen and (currentTime - info.lastSeen) < 600 then
-			total = total + 1
-			if info.supportsDelta then
-				supporting = supporting + 1
-			end
-		end
-	end
-
-	if total == 0 then
-		return 0
-	end
-
-	return supporting / total
-end
-
 -- Delta metrics
 
 -- Record bytes sent via delta protocol
-function GBankClassic_Database:RecordDeltaSent(name, bytes)
+function Database:RecordDeltaSent(name, bytes)
 	if not name or not bytes then
 		return
 	end
@@ -465,7 +440,7 @@ function GBankClassic_Database:RecordDeltaSent(name, bytes)
 end
 
 -- Record bytes sent via full sync protocol
-function GBankClassic_Database:RecordFullSyncSent(name, bytes)
+function Database:RecordFullSyncSent(name, bytes)
 	if not name or not bytes then
 		return
 	end
@@ -477,7 +452,7 @@ function GBankClassic_Database:RecordFullSyncSent(name, bytes)
 end
 
 -- Record successful delta application
-function GBankClassic_Database:RecordDeltaApplied(name)
+function Database:RecordDeltaApplied(name)
 	if not name then
 		return
 	end
@@ -489,7 +464,7 @@ function GBankClassic_Database:RecordDeltaApplied(name)
 end
 
 -- Record failed delta application
-function GBankClassic_Database:RecordDeltaFailed(name)
+function Database:RecordDeltaFailed(name)
 	if not name then
 		return
 	end
@@ -501,7 +476,7 @@ function GBankClassic_Database:RecordDeltaFailed(name)
 end
 
 -- Record delta computation time
-function GBankClassic_Database:RecordDeltaComputeTime(name, milliseconds)
+function Database:RecordDeltaComputeTime(name, milliseconds)
 	if not name or not milliseconds then
 		return
 	end
@@ -514,7 +489,7 @@ function GBankClassic_Database:RecordDeltaComputeTime(name, milliseconds)
 end
 
 -- Record delta application time
-function GBankClassic_Database:RecordDeltaApplyTime(name, milliseconds)
+function Database:RecordDeltaApplyTime(name, milliseconds)
 	if not name or not milliseconds then
 		return
 	end
@@ -527,7 +502,7 @@ function GBankClassic_Database:RecordDeltaApplyTime(name, milliseconds)
 end
 
 -- Reset delta metrics (for testing or cleanup)
-function GBankClassic_Database:ResetDeltaMetrics(name)
+function Database:ResetDeltaMetrics(name)
 	if not name then
 		return false
 	end
@@ -553,7 +528,7 @@ function GBankClassic_Database:ResetDeltaMetrics(name)
 end
 
 -- Record fallback to full sync
-function GBankClassic_Database:RecordFullSyncFallback(name)
+function Database:RecordFullSyncFallback(name)
 	if not name then
 		return
 	end
@@ -565,7 +540,7 @@ function GBankClassic_Database:RecordFullSyncFallback(name)
 end
 
 -- Get delta metrics
-function GBankClassic_Database:GetDeltaMetrics(name)
+function Database:GetDeltaMetrics(name)
 	if not name then
 		return nil
 	end
diff --git a/Modules/DeltaComms.lua b/Modules/DeltaComms.lua
index 8f0b652..2f00948 100644
--- a/Modules/DeltaComms.lua
+++ b/Modules/DeltaComms.lua
@@ -1,12 +1,18 @@
--- Handles all delta synchronization communication and protocol logic
--- This includes delta validation, computation, application, error tracking, and protocol coordination
+GBankClassic_DeltaComms = GBankClassic_DeltaComms or {}
 
-GBankClassic_DeltaComms = {}
+local DeltaComms = GBankClassic_DeltaComms
 
--- VALIDATION FUNCTIONS --
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("GetServerTime", "debugprofilestop", "UnitName", "GetNormalizedRealmName")
+local GetServerTime = upvalues.GetServerTime
+local debugprofilestop = upvalues.debugprofilestop
+local UnitName = upvalues.UnitName
+local GetNormalizedRealmName = upvalues.GetNormalizedRealmName
+
+-- Validation functions --
 
 -- Validate that a delta structure is well-formed
-function GBankClassic_DeltaComms:ValidateDeltaStructure(delta)
+function DeltaComms:ValidateDeltaStructure(delta)
 	if not delta or type(delta) ~= "table" then
 		return false, "delta is not a table"
 	end
@@ -56,7 +62,7 @@ function GBankClassic_DeltaComms:ValidateDeltaStructure(delta)
 end
 
 -- Validate an item delta structure (added/modified/removed)
-function GBankClassic_DeltaComms:ValidateItemDelta(itemDelta)
+function DeltaComms:ValidateItemDelta(itemDelta)
 	if not itemDelta or type(itemDelta) ~= "table" then
 		return false, "itemDelta is not a table"
 	end
@@ -66,6 +72,7 @@ function GBankClassic_DeltaComms:ValidateItemDelta(itemDelta)
 		if type(itemDelta.added) ~= "table" then
 			return false, "added is not a table"
 		end
+
 		for _, item in pairs(itemDelta.added) do
 			if type(item) ~= "table" then
 				return false, "added item is not a table"
@@ -73,10 +80,9 @@ function GBankClassic_DeltaComms:ValidateItemDelta(itemDelta)
 			if not item.ID or type(item.ID) ~= "number" then
 				return false, "added item missing or invalid ID"
 			end
-			if not item.Link or type(item.Link) ~= "string" then
-				return false, "added item missing or invalid link"
+			if item.Link and type(item.Link) ~= "string" then
+				return false, "added item has invalid link"
 			end
-			-- slot is optional (merged items don't have slots)
 		end
 	end
 
@@ -85,6 +91,7 @@ function GBankClassic_DeltaComms:ValidateItemDelta(itemDelta)
 		if type(itemDelta.modified) ~= "table" then
 			return false, "modified is not a table"
 		end
+
 		for _, item in pairs(itemDelta.modified) do
 			if type(item) ~= "table" then
 				return false, "modified item is not a table"
@@ -92,10 +99,9 @@ function GBankClassic_DeltaComms:ValidateItemDelta(itemDelta)
 			if not item.ID or type(item.ID) ~= "number" then
 				return false, "modified item missing or invalid ID"
 			end
-			if not item.Link or type(item.Link) ~= "string" then
-				return false, "modified item missing or invalid link"
+			if item.Link and type(item.Link) ~= "string" then
+				return false, "modified item has invalid link"
 			end
-			-- slot is optional (merged items don't have slots)
 		end
 	end
 
@@ -104,6 +110,7 @@ function GBankClassic_DeltaComms:ValidateItemDelta(itemDelta)
 		if type(itemDelta.removed) ~= "table" then
 			return false, "removed is not a table"
 		end
+
 		for _, item in pairs(itemDelta.removed) do
 			if type(item) ~= "table" then
 				return false, "removed item is not a table"
@@ -117,89 +124,52 @@ function GBankClassic_DeltaComms:ValidateItemDelta(itemDelta)
 	return true
 end
 
--- Sanitize a delta structure by removing malformed data
-function GBankClassic_DeltaComms:SanitizeDelta(delta)
-	if not delta or type(delta) ~= "table" then
-		return nil
-	end
-
-	-- Create sanitized copy
-	local sanitized = {
-		type = delta.type,
-		name = delta.name,
-		version = delta.version,
-		changes = {},
-	}
-
-	if not delta.changes or type(delta.changes) ~= "table" then
-		return sanitized
-	end
-
-	local changes = delta.changes
-
-	-- Sanitize money
-	if changes.money and type(changes.money) == "number" then
-		sanitized.changes.money = changes.money
-	end
-
-	-- Sanitize bank delta
-	if changes.bank and type(changes.bank) == "table" then
-		sanitized.changes.bank = self:SanitizeItemDelta(changes.bank)
-	end
-
-	-- Sanitize bags delta
-	if changes.bags and type(changes.bags) == "table" then
-		sanitized.changes.bags = self:SanitizeItemDelta(changes.bags)
-	end
-
-	return sanitized
-end
-
--- Sanitize an item delta structure
-function GBankClassic_DeltaComms:SanitizeItemDelta(itemDelta)
-	local sanitized = {
-		added = {},
-		modified = {},
-		removed = {},
-	}
-
-	-- Sanitize added items
-	if itemDelta.added and type(itemDelta.added) == "table" then
-		for _, item in pairs(itemDelta.added) do
-			if type(item) == "table" and item.ID and item.slot then
-				table.insert(sanitized.added, item)
+-- Compute a hash of inventory state to detect actual changes
+-- Only updates version timestamps when this hash changes
+function DeltaComms:ComputeInventoryHash(bank, bags, mailOrMoney, money)
+	-- Handle multiple calling conventions:
+	-- 2.6.0+ (aggregated): ComputeInventoryHash(items, nil, nil, money) - items is direct array
+	-- Pre 2.6.0: ComputeInventoryHash(bank, bags, money) - bank/bags have .items, no mail
+	
+	-- Detect aggregated call: first param is array, second is nil
+	if bank and type(bank) == "table" and bags == nil and mailOrMoney == nil then
+		-- Bank is actually the aggregated items array, money is the 4th param
+		local items = bank
+		local actualMoney = money or 0
+		
+		local parts = {}
+		table.insert(parts, tostring(actualMoney))
+		
+		-- Hash aggregated items directly
+		local function hashItems(itemsArray)
+			if not itemsArray or type(itemsArray) ~= "table" then
+				return ""
 			end
-		end
-	end
 
-	-- Sanitize modified items
-	if itemDelta.modified and type(itemDelta.modified) == "table" then
-		for _, item in pairs(itemDelta.modified) do
-			if type(item) == "table" and item.slot then
-				table.insert(sanitized.modified, item)
+			local sorted = {}
+			for _, item in ipairs(itemsArray) do
+				if item and item.ID then
+					table.insert(sorted, string.format("%d:%d", item.ID, item.Count or 0))
+				end
 			end
-		end
-	end
+			table.sort(sorted)
 
-	-- Sanitize removed slots
-	if itemDelta.removed and type(itemDelta.removed) == "table" then
-		for _, slot in pairs(itemDelta.removed) do
-			if type(slot) == "number" then
-				table.insert(sanitized.removed, slot)
-			end
+			return table.concat(sorted, ",")
 		end
-	end
-
-	return sanitized
-end
+		
+		table.insert(parts, "I:" .. hashItems(items))
+		local combined = table.concat(parts, "|")
 
--- Compute a hash of inventory state to detect actual changes
--- Only updates version timestamps when this hash changes
-function GBankClassic_DeltaComms:ComputeInventoryHash(bank, bags, money)
+		return GBankClassic_Core:Checksum(combined)
+	end
+	
+	-- Legacy calling convention: ComputeInventoryHash(bank, bags, money)
+	-- Parameter mailOrMoney is actually money (number), no mail parameter exists
+	local actualMoney = mailOrMoney or 0
 	local parts = {}
 
 	-- Include money
-	table.insert(parts, tostring(money or 0))
+	table.insert(parts, tostring(actualMoney))
 
 	-- Helper to hash an items array
 	local function hashItems(items)
@@ -215,6 +185,7 @@ function GBankClassic_DeltaComms:ComputeInventoryHash(bank, bags, money)
 			end
 		end
 		table.sort(sorted)
+
 		return table.concat(sorted, ",")
 	end
 
@@ -243,30 +214,10 @@ function GBankClassic_DeltaComms:ComputeInventoryHash(bank, bags, money)
 	return sum
 end
 
--- DELTA PROTOCOL FUNCTIONS --
-
--- Check if delta sync should be used
-function GBankClassic_DeltaComms:ShouldUseDelta()
-	-- Check force flags first (for testing)
-	if FEATURES and FEATURES.FORCE_DELTA_SYNC then
-		return true
-	end
-
-	-- Check feature flags
-	if not FEATURES or not FEATURES.DELTA_ENABLED then
-		return false
-	end
-	if FEATURES.FORCE_FULL_SYNC then
-		return false
-	end
-
-	-- Delta protocol always enabled if feature flag is on
-	-- No guild support threshold - clients will use delta if both sides support it
-	return PROTOCOL.SUPPORTS_DELTA
-end
+-- Delta protocol functions --
 
 -- Get peer protocol capabilities
-function GBankClassic_DeltaComms:GetPeerCapabilities(guildName, sender)
+function DeltaComms:GetPeerCapabilities(guildName, sender)
 	if not guildName or not sender then
 		return nil
 	end
@@ -275,13 +226,16 @@ function GBankClassic_DeltaComms:GetPeerCapabilities(guildName, sender)
 end
 
 -- Strip links from delta for bandwidth savings
-function GBankClassic_DeltaComms:StripDeltaLinks(delta)
+function DeltaComms:StripDeltaLinks(delta)
 	if not delta or not delta.changes then
 		return nil
 	end
 
 	local function stripItemArray(items)
-		if not items then return nil end
+		if not items then
+			return nil
+		end
+
 		local stripped = {}
 		for _, item in ipairs(items) do
 			local strippedItem = {
@@ -294,6 +248,7 @@ function GBankClassic_DeltaComms:StripDeltaLinks(delta)
 			end
 			table.insert(stripped, strippedItem)
 		end
+
 		return stripped
 	end
 
@@ -330,10 +285,10 @@ function GBankClassic_DeltaComms:StripDeltaLinks(delta)
 	return strippedDelta
 end
 
--- DELTA COMPUTATION FUNCTIONS --
+-- Delta computation functions --
 
 -- Compare two items for equality
-function GBankClassic_DeltaComms:ItemsEqual(item1, item2)
+function DeltaComms:ItemsEqual(item1, item2)
 	if not item1 and not item2 then
 		return true
 	end
@@ -373,7 +328,7 @@ function GBankClassic_DeltaComms:ItemsEqual(item1, item2)
 end
 
 -- Extract only the fields that changed between two items
-function GBankClassic_DeltaComms:GetChangedFields(oldItem, newItem)
+function DeltaComms:GetChangedFields(oldItem, newItem)
 	-- Always include ID and link for identification (merged items use these as keys)
 	local changes = {
 		ID = newItem.ID,
@@ -394,7 +349,7 @@ function GBankClassic_DeltaComms:GetChangedFields(oldItem, newItem)
 end
 
 -- Build a slot-indexed lookup table from items array
-function GBankClassic_DeltaComms:BuildItemIndex(items)
+function DeltaComms:BuildItemIndex(items)
 	local index = {}
 	if not items then
 		return index
@@ -411,7 +366,7 @@ function GBankClassic_DeltaComms:BuildItemIndex(items)
 end
 
 -- Compute delta between old and new item sets
-function GBankClassic_DeltaComms:ComputeItemDelta(oldItems, newItems)
+function DeltaComms:ComputeItemDelta(oldItems, newItems)
 	local delta = { added = {}, modified = {}, removed = {} }
 
 	oldItems = oldItems or {}
@@ -448,59 +403,44 @@ function GBankClassic_DeltaComms:ComputeItemDelta(oldItems, newItems)
 end
 
 -- Compute full delta for an alt
-function GBankClassic_DeltaComms:ComputeDelta(guildName, altName, currentAlt)
-	return GBankClassic_Performance:Track("ComputeDelta", function()
-		if not guildName or not altName or not currentAlt then
-			return nil
-		end
+function DeltaComms:ComputeDelta(guildName, altName, currentAlt)
+	if not guildName or not altName or not currentAlt then
+		return nil
+	end
 
-		-- Get previous snapshot
-		local previous = GBankClassic_Database:GetSnapshot(guildName, altName)
-		if not previous then
-			return nil
-		end
+	-- Get previous snapshot
+	local previous = GBankClassic_Database:GetSnapshot(guildName, altName)
+	if not previous then
+		return nil
+	end
 
-		-- Build delta structure
-		-- In pull-based protocol, receiver states what they have
-		local delta = {
-			type = "alt-delta",
-			name = altName,
-			version = currentAlt.version or GetServerTime(),
-			changes = {},
-		}
+	-- Build delta structure
+	-- In pull-based protocol, receiver states what they have
+	local delta = {
+		type = "alt-delta",
+		name = altName,
+		version = currentAlt.version or GetServerTime(),
+		changes = {},
+	}
 
-		-- Money change
-		if currentAlt.money ~= previous.money then
-			delta.changes.money = currentAlt.money
-		end
+	-- Money change
+	if currentAlt.money ~= previous.money then
+		delta.changes.money = currentAlt.money
+	end
 
-		-- Bank items delta
-		local previousBankItems = previous.bank and previous.bank.items or {}
-		local currentBankItems = currentAlt.bank and currentAlt.bank.items or {}
-
-		-- Bag items delta
-		local previousBagItems = previous.bags and previous.bags.items or {}
-		local currentBagItems = currentAlt.bags and currentAlt.bags.items or {}
-
-		-- Log item counts for both bank and bags
-		GBankClassic_Output:Debug(
-			"DELTA",
-			"Comparing %s: previous bank has %d items, bags have %d items; current bank has %d items, bags have %d items",
-			altName,
-			#previousBankItems,
-			#previousBagItems,
-			#currentBankItems,
-			#currentBagItems
-		)
-		delta.changes.bank = self:ComputeItemDelta(previousBankItems, currentBankItems)
-		delta.changes.bags = self:ComputeItemDelta(previousBagItems, currentBagItems)
-
-		return delta
-	end)
+	-- Items delta (aggregated bank + bags + mail)
+	local previousItems = previous.items or {}
+	local currentItems = currentAlt.items or {}
+
+	-- Log item counts
+	GBankClassic_Output:Debug("DELTA", "Comparing %s: previous aggregation has %d items, current aggregation has %d items", altName, #previousItems, #currentItems)
+	delta.changes.items = self:ComputeItemDelta(previousItems, currentItems)
+
+	return delta
 end
 
 -- Estimate serialized size of a data structure
-function GBankClassic_DeltaComms:EstimateSize(data)
+function DeltaComms:EstimateSize(data)
 	if not data then
 		return 0
 	end
@@ -512,7 +452,7 @@ function GBankClassic_DeltaComms:EstimateSize(data)
 end
 
 -- Check if delta has any actual changes
-function GBankClassic_DeltaComms:DeltaHasChanges(delta)
+function DeltaComms:DeltaHasChanges(delta)
 	if not delta or not delta.changes then
 		return false
 	end
@@ -524,16 +464,9 @@ function GBankClassic_DeltaComms:DeltaHasChanges(delta)
 		return true
 	end
 
-	-- Check bank changes
-	if changes.bank then
-		if next(changes.bank.added) or next(changes.bank.modified) or next(changes.bank.removed) then
-			return true
-		end
-	end
-
-	-- Check bag changes
-	if changes.bags then
-		if next(changes.bags.added) or next(changes.bags.modified) or next(changes.bags.removed) then
+	-- Check items changes
+	if changes.items then
+		if next(changes.items.added) or next(changes.items.modified) or next(changes.items.removed) then
 			return true
 		end
 	end
@@ -541,10 +474,10 @@ function GBankClassic_DeltaComms:DeltaHasChanges(delta)
 	return false
 end
 
--- DELTA APPLICATION FUNCTIONS --
+-- Delta application functions --
 
 -- Apply item delta to an items table
-function GBankClassic_DeltaComms:ApplyItemDelta(items, delta)
+function DeltaComms:ApplyItemDelta(items, delta)
 	if not items or not delta then
 		return false
 	end
@@ -601,108 +534,123 @@ function GBankClassic_DeltaComms:ApplyItemDelta(items, delta)
 end
 
 -- Apply a delta to alt data
-function GBankClassic_DeltaComms:ApplyDelta(guildInfo, altName, deltaData, sender)
-	return GBankClassic_Performance:Track("ApplyDelta", function()
-		if not guildInfo then
-			return ADOPTION_STATUS.IGNORED
-		end
+function DeltaComms:ApplyDelta(guildInfo, altName, deltaData, sender)
+	if not guildInfo then
+		return ADOPTION_STATUS.IGNORED
+	end
 
-		local applyStart = debugprofilestop()
-		local norm = GBankClassic_Guild:NormalizeName(altName)
-		local current = guildInfo.alts[norm]
+	local applyStart = debugprofilestop()
+	local norm = GBankClassic_Guild:NormalizeName(altName)
+	local current = guildInfo.alts[norm]
 
-		-- Validate base version matches
-		if not current then
-			-- No existing data, request full sync
+	-- Validate base version matches
+	if not current then
+		-- No existing data, request full sync (but only if not already pending)
+		local hasPending = GBankClassic_Guild.pending_sync and GBankClassic_Guild.pending_sync.alts and GBankClassic_Guild.pending_sync.alts[norm]
+		if not hasPending then
 			local errorMsg = string.format("No existing data for %s", norm)
 			GBankClassic_Output:Debug("DELTA", errorMsg .. ", requesting full sync")
 			self:RecordDeltaError(guildInfo.name, norm, "NO_DATA", errorMsg)
 			GBankClassic_Guild:QueryAlt(nil, norm, nil)
-			if guildInfo and guildInfo.name then
-				GBankClassic_Database:RecordDeltaFailed(guildInfo.name)
-			end
+		else
+			GBankClassic_Output:Debug("DELTA", "No data for %s but full sync already pending, skipping duplicate request", norm)
+		end
 
-			return ADOPTION_STATUS.INVALID
+		if guildInfo and guildInfo.name then
+			GBankClassic_Database:RecordDeltaFailed(guildInfo.name)
 		end
 
-		-- Apply changes (wrapped in pcall for safety)
-		local success, err = pcall(function()
-			local changes = deltaData.changes
+		return ADOPTION_STATUS.INVALID
+	end
 
-			if changes.money then
-				current.money = changes.money
-			end
+	-- Protect guild bank alt data as source of truth
+	-- Non-guild bank alts accept all deltas (they're not the authority)
+	local player = UnitName("player")
+	local realm = GetNormalizedRealmName()
+	local playerFull = player .. "-" .. realm
+	local playerNorm = GBankClassic_Guild:NormalizeName(playerFull)
+	local playerIsGuildBankAlt = GBankClassic_Guild:IsBank(playerNorm)
+	if playerIsGuildBankAlt then
+		-- We are a guild bank alt - protect our own data and other guild bank alt data
 
-			-- Apply bank item changes
-			if changes.bank then
-				if not current.bank then
-					current.bank = { items = {} }
-				end
-				if not current.bank.items then
-					current.bank.items = {}
-				end
-				self:ApplyItemDelta(current.bank.items, changes.bank)
-			end
+		-- If this delta is about US, reject it (we are the source of truth for our own data)
+		if norm == playerNorm then
+			local errorMsg = string.format("Rejected delta from %s about ourselves (guild bank alt is source of truth for own data)", sender or "unknown")
+			GBankClassic_Output:Debug("DELTA", "%s", errorMsg)
 
-			-- Apply bag item changes
-			if changes.bags then
-				if not current.bags then
-					current.bags = { items = {} }
-				end
-				if not current.bags.items then
-					current.bags.items = {}
-				end
-				self:ApplyItemDelta(current.bags.items, changes.bags)
-			end
+			return ADOPTION_STATUS.UNAUTHORIZED
+		end
+		
+		-- Also protect other guild bank alt data from non-guild bank alt updates
+		local currentIsGuildBankAlt = GBankClassic_Guild:IsBank(norm)
+		local senderNorm = sender and GBankClassic_Guild:NormalizeName(sender) or nil
+		local senderIsGuildBankAlt = senderNorm and GBankClassic_Guild:IsBank(senderNorm) or false
+		if currentIsGuildBankAlt and not senderIsGuildBankAlt then
+			-- Reject: non-guild bank alt trying to update guild bank alt data
+			local errorMsg = string.format("Rejected delta from non-guild bank alt %s for guild bank alt %s (guild bank alts are source of truth)", sender or "unknown", norm)
+			GBankClassic_Output:Debug("DELTA", "%s", errorMsg)
 
-			-- Update version
-			current.version = deltaData.version
-		end)
+			return ADOPTION_STATUS.UNAUTHORIZED
+		end
+	end
 
-		if not success then
-			-- Delta application failed, request full sync
-			local errorMsg = string.format("Delta application error: %s", tostring(err))
-			GBankClassic_Output:Error("Failed to apply delta for %s: %s", norm, tostring(err))
-			self:RecordDeltaError(guildInfo.name, norm, "APPLICATION_ERROR", errorMsg)
-			GBankClassic_Guild:QueryAlt(nil, norm, nil)
-			if guildInfo and guildInfo.name then
-				GBankClassic_Database:RecordDeltaFailed(guildInfo.name)
-			end
+	-- Apply changes (wrapped in pcall for safety)
+	local success, err = pcall(function()
+		local changes = deltaData.changes
 
-			return ADOPTION_STATUS.INVALID
+		if changes.money then
+			current.money = changes.money
 		end
 
-		-- Save new snapshot for future deltas
-		if guildInfo and guildInfo.name then
-			GBankClassic_Database:SaveSnapshot(guildInfo.name, norm, current)
-			GBankClassic_Database:RecordDeltaApplied(guildInfo.name)
-
-			-- Record apply time
-			local applyTime = debugprofilestop() - applyStart
-			GBankClassic_Database:RecordDeltaApplyTime(guildInfo.name, applyTime)
-			GBankClassic_Output:Debug(
-				"DELTA",
-				" Applied delta for %s (v%dv%d) in %.2fms",
-				norm,
-				deltaData.version,
-				applyTime
-			)
+		-- Apply item changes (aggregated bank + bags + mail)
+		if changes.items then
+			if not current.items then
+				current.items = {}
+			end
+			self:ApplyItemDelta(current.items, changes.items)
 		end
 
-		-- Reset error count on successful application
-		self:ResetDeltaErrorCount(guildInfo.name, norm)
+		-- Update version
+		current.version = deltaData.version
+	end)
 
-		-- Trigger UI refresh if Inventory window is open
-		if GBankClassic_UI_Inventory and GBankClassic_UI_Inventory.isOpen then
-			GBankClassic_UI_Inventory:DrawContent()
+	if not success then
+		-- Delta application failed, request full sync
+		local errorMsg = string.format("Delta application ERROR: %s", tostring(err))
+		GBankClassic_Output:Error("Failed to apply delta for %s: %s", norm, tostring(err))
+		self:RecordDeltaError(guildInfo.name, norm, "APPLICATION_ERROR", errorMsg)
+		GBankClassic_Guild:QueryAlt(nil, norm, nil)
+		if guildInfo and guildInfo.name then
+			GBankClassic_Database:RecordDeltaFailed(guildInfo.name)
 		end
 
-		return ADOPTION_STATUS.ADOPTED
-	end)
+		return ADOPTION_STATUS.INVALID
+	end
+
+	-- Save new snapshot for future deltas
+	if guildInfo and guildInfo.name then
+		GBankClassic_Database:SaveSnapshot(guildInfo.name, norm, current)
+		GBankClassic_Database:RecordDeltaApplied(guildInfo.name)
+
+		-- Record apply time
+		local applyTime = debugprofilestop() - applyStart
+		GBankClassic_Database:RecordDeltaApplyTime(guildInfo.name, applyTime)
+		GBankClassic_Output:Debug("DELTA", " Applied delta for %s (v%d) in %.2fms", norm, deltaData.version, applyTime)
+	end
+
+	-- Reset error count on successful application
+	self:ResetDeltaErrorCount(guildInfo.name, norm)
+
+	-- Trigger UI refresh if inventory window is open
+	if GBankClassic_UI_Inventory and GBankClassic_UI_Inventory.isOpen then
+		GBankClassic_UI_Inventory:DrawContent()
+	end
+
+	return ADOPTION_STATUS.ADOPTED
 end
 
 -- Apply a chain of deltas sequentially
-function GBankClassic_DeltaComms:ApplyDeltaChain(guildInfo, altName, deltaChain)
+function DeltaComms:ApplyDeltaChain(guildInfo, altName, deltaChain)
 	if not altName or not deltaChain or type(deltaChain) ~= "table" or #deltaChain == 0 then
 		return ADOPTION_STATUS.INVALID
 	end
@@ -718,13 +666,7 @@ function GBankClassic_DeltaComms:ApplyDeltaChain(guildInfo, altName, deltaChain)
 
 	-- Validate chain
 	if #deltaChain > (PROTOCOL.DELTA_CHAIN_MAX_HOPS or 10) then
-		GBankClassic_Output:Debug(
-			"DELTA",
-			"Delta chain too long for %s (%d hops > %d max)",
-			norm,
-			#deltaChain,
-			PROTOCOL.DELTA_CHAIN_MAX_HOPS or 10
-		)
+		GBankClassic_Output:Debug("DELTA", "Delta chain too long for %s (%d hops > %d max)", norm, #deltaChain, PROTOCOL.DELTA_CHAIN_MAX_HOPS or 10)
 
 		return ADOPTION_STATUS.INVALID
 	end
@@ -732,13 +674,7 @@ function GBankClassic_DeltaComms:ApplyDeltaChain(guildInfo, altName, deltaChain)
 	-- Estimate total chain size
 	local totalSize = self:EstimateSize(deltaChain)
 	if totalSize > (PROTOCOL.DELTA_CHAIN_MAX_SIZE or 5000) then
-		GBankClassic_Output:Debug(
-			"DELTA",
-			"Delta chain too large for %s (%d bytes > %d max), requesting full sync",
-			norm,
-			totalSize,
-			PROTOCOL.DELTA_CHAIN_MAX_SIZE or 5000
-		)
+		GBankClassic_Output:Debug("DELTA", "Delta chain too large for %s (%d bytes > %d max), requesting full sync", norm, totalSize, PROTOCOL.DELTA_CHAIN_MAX_SIZE or 5000)
 		GBankClassic_Guild:QueryAlt(nil, norm, nil)
 
 		return ADOPTION_STATUS.INVALID
@@ -758,34 +694,21 @@ function GBankClassic_DeltaComms:ApplyDeltaChain(guildInfo, altName, deltaChain)
 
 		local status = self:ApplyDelta(guildInfo, altName, deltaData)
 		if status ~= ADOPTION_STATUS.ADOPTED then
-			GBankClassic_Output:Debug(
-				"DELTA",
-				"Failed to apply delta chain for %s at hop %d (v%dv%d)",
-				norm,
-				i,
-				deltaEntry.version
-			)
+			GBankClassic_Output:Debug("DELTA", "Failed to apply delta chain for %s at hop %d (v%d)", norm, i, deltaEntry.version)
 
 			return status
 		end
 	end
 
 	local chainTime = debugprofilestop() - chainStart
-	GBankClassic_Output:Debug(
-		"DELTA",
-		" Applied delta chain for %s (%d hops, v%dv%d) in %.2fms",
-		norm,
-		#deltaChain,
-		deltaChain[#deltaChain].version,
-		chainTime
-	)
+	GBankClassic_Output:Debug("DELTA", " Applied delta chain for %s (%d hops, v%d) in %.2fms", norm, #deltaChain, deltaChain[#deltaChain].version, chainTime)
 
 	return ADOPTION_STATUS.ADOPTED
 end
 
--- ERROR TRACKING FUNCTIONS --
+-- Error tracking functions --
 
-function GBankClassic_DeltaComms:RecordDeltaError(guildName, altName, errorType, errorMessage)
+function DeltaComms:RecordDeltaError(guildName, altName, errorType, errorMessage)
 	local error = {
 		altName = altName,
 		errorType = errorType,
@@ -814,24 +737,17 @@ function GBankClassic_DeltaComms:RecordDeltaError(guildName, altName, errorType,
 			-- Notify user if repeated failures (3+ failures for same alt) and player is online
 			if db.deltaErrors.failureCounts[altName] >= 3 and not db.deltaErrors.notifiedAlts[altName] then
 				if GBankClassic_Guild:IsPlayerOnline(altName) then
-					GBankClassic_Output:Warn(
-						"Repeated delta sync failures for %s. Falling back to full sync.",
-						altName
-					)
+					GBankClassic_Output:Warn("Repeated delta sync failures for %s. Falling back to full sync.", altName)
 					db.deltaErrors.notifiedAlts[altName] = true
 				end
 			end
+
 			return
 		end
 	end
 
 	-- Fallback: Use temporary in-memory storage
-	GBankClassic_Output:Debug(
-		"DELTA",
-		"Using temporary error storage for %s (%s): Guild.Info not initialized",
-		altName or "unknown",
-		errorType or "unknown"
-	)
+	GBankClassic_Output:Debug("DELTA", "Using temporary error storage for %s (%s): initialization issue", altName or "unknown", errorType or "unknown")
 
 	if not GBankClassic_Guild.tempDeltaErrors then
 		GBankClassic_Guild.tempDeltaErrors = {
@@ -864,7 +780,7 @@ function GBankClassic_DeltaComms:RecordDeltaError(guildName, altName, errorType,
 end
 
 -- Reset failure count for an alt (called on successful sync)
-function GBankClassic_DeltaComms:ResetDeltaErrorCount(guildName, altName)
+function DeltaComms:ResetDeltaErrorCount(guildName, altName)
 	if not altName then
 		return
 	end
@@ -893,26 +809,8 @@ function GBankClassic_DeltaComms:ResetDeltaErrorCount(guildName, altName)
 	end
 end
 
--- Get recent delta errors
-function GBankClassic_DeltaComms:GetRecentDeltaErrors(guildName)
-	-- Return from database if available
-	if guildName then
-		local db = GBankClassic_Database.db.factionrealm[guildName]
-		if db and db.deltaErrors then
-			return db.deltaErrors.lastErrors
-		end
-	end
-
-	-- Fallback to temporary storage
-	if GBankClassic_Guild.tempDeltaErrors then
-		return GBankClassic_Guild.tempDeltaErrors.lastErrors
-	end
-
-	return {}
-end
-
 -- Get failure count for an alt
-function GBankClassic_DeltaComms:GetDeltaFailureCount(guildName, altName)
+function DeltaComms:GetDeltaFailureCount(guildName, altName)
 	-- Check database first if available
 	if guildName then
 		local db = GBankClassic_Database.db.factionrealm[guildName]
@@ -930,7 +828,7 @@ function GBankClassic_DeltaComms:GetDeltaFailureCount(guildName, altName)
 end
 
 -- Clear error counters for all offline players (called on roster update)
-function GBankClassic_DeltaComms:ClearOfflineErrorCounters(guildName)
+function DeltaComms:ClearOfflineErrorCounters(guildName)
 	if not guildName then
 		return
 	end
@@ -949,59 +847,10 @@ function GBankClassic_DeltaComms:ClearOfflineErrorCounters(guildName)
 	end
 end
 
--- PULL-BASED PROTOCOL FUNCTIONS --
-
--- Request a chain of deltas to catch up from an old version
-function GBankClassic_DeltaComms:RequestDeltaChain(guildName, altName, fromVersion, toVersion, sender)
-	if not altName or not fromVersion or not toVersion or not sender then
-		return false
-	end
-
-	-- Validate request parameters
-	if fromVersion >= toVersion then
-		GBankClassic_Output:Debug("DELTA", "Invalid delta chain request: fromVersion >= toVersion")
-		return false
-	end
-
-	-- Check if sender is online before attempting WHISPER (DELTA-008)
-	if not GBankClassic_Guild:IsPlayerOnline(sender) then
-		GBankClassic_Output:Debug(
-			"DELTA",
-			"Cannot request delta chain for %s from %s - sender is offline",
-			altName,
-			sender
-		)
-		return false
-	end
-
-	-- Note: We don't check version gap age here - if we have the deltas, we use them.
-	-- The delta history cleanup (DELTA_HISTORY_MAX_AGE) handles storage limits.
-	-- If we can't build the chain, BuildDeltaChain will return nil and we'll fall back.
-
-	-- Send delta range request
-	local requestData = {
-		altName = altName,
-		fromVersion = fromVersion,
-		toVersion = toVersion
-	}
-
-	local serialized = GBankClassic_Core:SerializeWithChecksum(requestData)
-	GBankClassic_Core:SendWhisper("gbank-dr", serialized, sender, "ALERT")
-
-	GBankClassic_Output:Debug(
-		"DELTA",
-		"Requesting delta chain for %s from v%d to v%d from %s",
-		altName,
-		fromVersion,
-		toVersion,
-		sender
-	)
-
-	return true
-end
+-- Pull-based protocol functions --
 
 -- Fast-fill missing alts using pull-based protocol
-function GBankClassic_DeltaComms:FastFillMissingAlts(guildInfo)
+function DeltaComms:FastFillMissingAlts(guildInfo)
 	if not guildInfo then
 		return
 	end
diff --git a/Modules/Events.lua b/Modules/Events.lua
index 0e8eba2..6b015d5 100644
--- a/Modules/Events.lua
+++ b/Modules/Events.lua
@@ -1,21 +1,17 @@
-GBankClassic_Events = {}
+GBankClassic_Events = GBankClassic_Events or {}
 
-function GBankClassic_Events:RegisterMessage(message, callback)
-	if not callback then
-		callback = message
-	end
-    GBankClassic_Core:RegisterMessage(message, callback)
-end
+local Events = GBankClassic_Events
+local bagUpdateTimer = nil
 
-function GBankClassic_Events:SendMessage(message, ...)
-    GBankClassic_Core:SendMessage(message, ...)
-end
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("hooksecurefunc", "GuildRoster", "IsInRaid", "MailFrame", "NewTimer")
+local hooksecurefunc = upvalues.hooksecurefunc
+local GuildRoster = upvalues.GuildRoster
+local IsInRaid = upvalues.IsInRaid
+local MailFrame = upvalues.MailFrame
+local NewTimer = upvalues.NewTimer
 
-function GBankClassic_Events:UnregisterMessage(message)
-    GBankClassic_Core:UnregisterMessage(message)
-end
-
-function GBankClassic_Events:RegisterEvent(event, callback)
+function Events:RegisterEvent(event, callback)
 	if not callback then
 		callback = event
 	end
@@ -24,11 +20,11 @@ function GBankClassic_Events:RegisterEvent(event, callback)
     end)
 end
 
-function GBankClassic_Events:UnregisterEvent(...)
+function Events:UnregisterEvent(...)
     GBankClassic_Core:UnregisterEvent(...)
 end
 
-function GBankClassic_Events:RegisterEvents()
+function Events:RegisterEvents()
 	if GBankClassic_Bank.eventsRegistered then
 		return
 	end
@@ -51,18 +47,57 @@ function GBankClassic_Events:RegisterEvents()
     self:RegisterEvent("MERCHANT_CLOSED")
     self:RegisterEvent("BAG_UPDATE")
     self:RegisterEvent("PLAYER_REGEN_DISABLED")
+	-- self:RegisterEvent("MAIL_SEND_SUCCESS")
 
     hooksecurefunc("ChatEdit_InsertLink", function(link)
         GBankClassic_UI:OnInsertLink(link)
     end)
 
+	-- -- Hook MailFrame visibility changes directly for more reliable detection
+	-- if MailFrame and not MailFrame.gbankHooked then
+	-- 	MailFrame.gbankHooked = true
+	-- 	MailFrame:HookScript("OnShow", function()
+	-- 		GBankClassic_Mail.isOpen = true
+	-- 		After(0.1, function()
+	-- 			if GBankClassic_UI_Requests.isOpen then
+	-- 				GBankClassic_UI_Requests:DrawContent()
+	-- 			end
+	-- 		end)
+	-- 	end)
+	-- 	MailFrame:HookScript("OnHide", function()
+	-- 		GBankClassic_Mail.isOpen = false
+	-- 		After(0.1, function()
+	-- 			if GBankClassic_UI_Requests.isOpen then
+	-- 				GBankClassic_UI_Requests:DrawContent()
+	-- 			end
+	-- 		end)
+	-- 	end)
+	-- end
+
+	-- -- Hook the send mail tab to auto-open requests window for bank alts
+	-- if MailFrameTab2 and not MailFrameTab2.gbankHooked then
+	-- 	MailFrameTab2.gbankHooked = true
+	-- 	MailFrameTab2:HookScript("OnClick", function()
+	-- 		local player = GBankClassic_Guild:GetNormalizedPlayer()
+	-- 		if player and GBankClassic_Guild:IsBank(player) then
+	-- 			After(0.1, function()
+	-- 				if GBankClassic_UI_Requests.isOpen then
+	-- 					GBankClassic_UI_Requests:DrawContent()
+	-- 				else
+	-- 					GBankClassic_UI_Requests:Open()
+	-- 				end
+	-- 			end)
+	-- 		end
+	-- 	end)
+	-- end
+
 	self:SetTimer()
 	self:SetShareTimer()
 
     GBankClassic_Bank.eventsRegistered = true
 end
 
-function GBankClassic_Events:UnregisterEvents()
+function Events:UnregisterEvents()
 	if not GBankClassic_Bank.eventsRegistered then
 		return
 	end
@@ -87,31 +122,32 @@ function GBankClassic_Events:UnregisterEvents()
     self:UnregisterEvent("MERCHANT_CLOSED")
     self:UnregisterEvent("BAG_UPDATE")
     self:UnregisterEvent("PLAYER_REGEN_DISABLED")
+	-- self:UnregisterEvent("MAIL_SEND_SUCCESS")
 end
 
-function GBankClassic_Events:SetTimer()
+function Events:SetTimer()
 	GBankClassic_Core:ScheduleTimer(function(...)
-		GBankClassic_Events:OnTimer()
+		self:OnTimer()
 	end, TIMER_INTERVALS.ROSTER_AND_ALT_SYNC)
 end
 
-function GBankClassic_Events:OnTimer()
-	GBankClassic_Events:Sync()
+function Events:OnTimer()
+	self:Sync()
 	self:SetTimer()
 end
 
-function GBankClassic_Events:SetShareTimer()
+function Events:SetShareTimer()
 	GBankClassic_Core:ScheduleTimer(function(...)
-		GBankClassic_Events:OnShareTimer()
+		self:OnShareTimer()
 	end, TIMER_INTERVALS.VERSION_BROADCAST)
 end
 
-function GBankClassic_Events:OnShareTimer()
-	GBankClassic_Guild:Share("reply")
+function Events:OnShareTimer()
+	GBankClassic_Guild:Share("reply", "version")
 	self:SetShareTimer()
 end
 
-function GBankClassic_Events:Sync(priority)
+function Events:Sync(priority)
 	local guild = GBankClassic_Guild:GetGuild()
 	if not guild then
 		return
@@ -131,17 +167,13 @@ function GBankClassic_Events:Sync(priority)
 end
 
 -- Delta-specific version broadcast
-function GBankClassic_Events:SyncDeltaVersion(priority)
+-- Guild bankt alts send both gbank-dv (old) and gbank-dv2 (new) messages for compatibility
+function Events:SyncDeltaVersion(priority)
 	local guild = GBankClassic_Guild:GetGuild()
 	if not guild then
 		return
 	end
 
-	-- Only broadcast delta version if we support delta
-	if not GBankClassic_Guild:ShouldUseDelta() then
-		return
-	end
-
 	local version = GBankClassic_Guild:GetVersion()
 	if version == nil then
 		return
@@ -150,37 +182,63 @@ function GBankClassic_Events:SyncDeltaVersion(priority)
 		return
 	end
 
-	-- Include banker status for pull-based protocol
+	-- Include guild bank alt status for pull-based protocol
 	local player = GBankClassic_Guild:GetNormalizedPlayer()
 	local isGuildBankAlt = player and GBankClassic_Guild:IsBank(player) or false
 	version.isGuildBankAlt = isGuildBankAlt
 
+	-- gbank-dv2 for new clients (with aggregated items hash)
 	local data = GBankClassic_Core:SerializeWithChecksum(version)
-	-- Use provided priority or default to NORMAL for automatic timer-based syncs
+	GBankClassic_Core:SendCommMessage("gbank-dv2", data, "Guild", nil, priority or "NORMAL")
+	
+	-- Old clients will compute hash from their legacy alt.bank/alt.bags structure
+	-- New clients ignore gbank-dv, so no conflict
 	GBankClassic_Core:SendCommMessage("gbank-dv", data, "Guild", nil, priority or "NORMAL")
 end
 
-function GBankClassic_Events:PLAYER_LOGIN(_)
+function Events:PLAYER_LOGIN(_)
 	GBankClassic_Guild:GetPlayer()
 end
 
-function GBankClassic_Events:PLAYER_LOGOUT(_)
-	-- Save persistent debug log to SavedVariables
-	GBankClassic_Output:SavePersistentLog()
+function Events:PLAYER_LOGOUT(_)
+	-- Check if mail field exists before logout
+	local player = GBankClassic_Guild:GetNormalizedPlayer()
+	GBankClassic_Output:Debug("MAIL", "========================================")
+	GBankClassic_Output:Debug("MAIL", "Checking mail at logout for: %s", player)
+	if GBankClassic_Guild.Info and GBankClassic_Guild.Info.alts and GBankClassic_Guild.Info.alts[player] then
+		local alt = GBankClassic_Guild.Info.alts[player]
+		if alt.mail then
+			local mailCount = alt.mail.items and #alt.mail.items or 0
+			
+			GBankClassic_Output:Debug("MAIL", "Mail field exists with %d items", mailCount)
+			GBankClassic_Output:Debug("MAIL", "  version: %s (type: %s)", tostring(alt.mail.version), type(alt.mail.version))
+			GBankClassic_Output:Debug("MAIL", "  lastScan: %s (type: %s)", tostring(alt.mail.lastScan), type(alt.mail.lastScan))
+			GBankClassic_Output:Debug("MAIL", "  slots type: %s", type(alt.mail.slots))
+			if alt.mail.slots then
+				GBankClassic_Output:Debug("MAIL", "  slots.count: %s", tostring(alt.mail.slots.count))
+			end
+			-- Check for metatables or functions that would prevent serialization
+			if getmetatable(alt.mail) then
+				GBankClassic_Output:Debug("MAIL", "WARNING: alt.mail has a metatable!")
+			end
+		else
+			GBankClassic_Output:Debug("MAIL", "Mail field missing!")
+		end
+	else
+		GBankClassic_Output:Debug("MAIL", "Alt data not found")
+	end
+	GBankClassic_Output:Debug("MAIL", "========================================")
 end
 
-function GBankClassic_Events:PLAYER_ENTERING_WORLD(_)
-	GBankClassic_Performance:RecordEvent("PLAYER_ENTERING_WORLD")
+function Events:PLAYER_ENTERING_WORLD(_)
     -- Request initial guild roster update on world enter
-	local GuildRoster = GuildRoster or C_GuildInfo.GuildRoster
-    if GuildRoster then
-        GuildRoster()
-    end
+	GuildRoster()
+	
 	-- Initialize cache immediately in case GUILD_ROSTER_UPDATE is delayed
 	GBankClassic_Guild:RefreshOnlineCache()
 end
 
-function GBankClassic_Events:GUILD_RANKS_UPDATE(_)
+function Events:GUILD_RANKS_UPDATE(_)
 	local guild = GBankClassic_Guild:GetGuild()
 	if not guild then
 		return
@@ -207,8 +265,7 @@ function GBankClassic_Events:GUILD_RANKS_UPDATE(_)
 	end
 end
 
-function GBankClassic_Events:GUILD_ROSTER_UPDATE(_)
-	GBankClassic_Performance:RecordEvent("GUILD_ROSTER_UPDATE")
+function Events:GUILD_ROSTER_UPDATE(_)
     -- Refresh online members cache when roster updates
 	GBankClassic_Guild:RefreshOnlineCache()
 	-- Invalidate banks cache when roster updates
@@ -217,93 +274,102 @@ function GBankClassic_Events:GUILD_ROSTER_UPDATE(_)
 	GBankClassic_Guild:RebuildGuildBankAltsRoster()
 	-- Clear delta error counters for offline players
 	GBankClassic_DeltaComms:ClearOfflineErrorCounters(GBankClassic_Guild.Info and GBankClassic_Guild.Info.name)
+	-- -- Refresh the requests UI to update guild bank alt controls (like highlight checkbox)
+	-- GBankClassic_Guild:RefreshRequestsUI()
 end
 
-function GBankClassic_Events:GUILD_RANKS_UPDATE(_)
-	local guild = GBankClassic_Guild:GetGuild()
-	if not guild then
-		return
-	end
-
-    if GBankClassic_Guild:Init(guild) then
-        GBankClassic_Options:InitGuild()
-        
-		if IsInRaid() then
-			GBankClassic_Output:Debug("EVENTS", "GUILD_RANKS_UPDATE: ignoring guild ranks cleanup (in raid)")
-
-			return
-		end
-        
-		local cleaned = GBankClassic_Guild:CleanupMalformedAlts()
-		if cleaned and cleaned > 0 then
-			GBankClassic_Output:Info("Cleaned %d malformed alt entries from saved database", cleaned)
-		end
-        
-        if GBankClassic_UI_Inventory.isOpen then
-            GBankClassic_UI_Inventory:DrawContent()
-        end
-    end
-end
-
-function GBankClassic_Events:BANKFRAME_OPENED(_)
+function Events:BANKFRAME_OPENED(_)
     GBankClassic_Bank:OnUpdateStart()
 end
 
-function GBankClassic_Events:BANKFRAME_CLOSED(_)
+function Events:BANKFRAME_CLOSED(_)
     GBankClassic_Bank:OnUpdateStop()
 end
 
-function GBankClassic_Events:MAIL_SHOW(_)
+function Events:MAIL_SHOW(_)
+	GBankClassic_Output:Debug("MAIL", "MAIL_SHOW event fired")
     GBankClassic_Bank:OnUpdateStart()
+	GBankClassic_MailInventory.hasUpdated = true
+	GBankClassic_Output:Debug("MAIL", "MailInventory.hasUpdated set to %s", tostring(GBankClassic_MailInventory.hasUpdated))
     GBankClassic_Mail.isOpen = true
+	-- GBankClassic_Mail:InitSendHook()
     GBankClassic_Mail:Check()
+	
+	-- Hook MailFrame OnHide to detect when mail closes (MAIL_CLOSED event may not fire reliably)
+	if not MailFrame.GBankHooked then
+		MailFrame:HookScript("OnHide", function()
+			GBankClassic_Output:Debug("MAIL", "MailFrame OnHide fired (mailbox closed)")
+			self:MAIL_CLOSED()
+		end)
+		MailFrame.GBankHooked = true
+		GBankClassic_Output:Debug("MAIL", "Hooked MailFrame OnHide")
+	end
 end
 
-function GBankClassic_Events:MAIL_INBOX_UPDATE(_)
+function Events:MAIL_INBOX_UPDATE(_)
     GBankClassic_Mail:Scan()
 end
 
-function GBankClassic_Events:MAIL_CLOSED(_)
+function Events:MAIL_CLOSED(_)
+	GBankClassic_Output:Debug("MAIL", "MAIL_CLOSED event fired")
     GBankClassic_Mail.isOpen = false
     GBankClassic_Mail.isScanning = false
+	GBankClassic_Output:Debug("MAIL", "Calling Bank:OnUpdateStop()")
     GBankClassic_Bank:OnUpdateStop()
+	GBankClassic_Output:Debug("MAIL", "Bank:OnUpdateStop() completed")
     GBankClassic_UI_Mail:Close()
+	-- -- Refresh requests UI to update fulfill button states
+	-- -- Delay slightly to ensure MailFrame state is updated
+	-- After(0.1, function()
+	-- 	if GBankClassic_UI_Requests.isOpen then
+	-- 		GBankClassic_UI_Requests:DrawContent()
+	-- 	end
+	-- end)
 end
 
-function GBankClassic_Events:TRADE_SHOW(_)
+-- function Events:MAIL_SEND_SUCCESS(_)
+-- 	GBankClassic_Output:Debug("MAIL", "MAIL_SEND_SUCCESS event fired")
+-- 	-- Safety: ensure hook is registered when mail UI is opened
+-- 	GBankClassic_Mail:InitSendHook()
+-- 	GBankClassic_Mail:ApplyPendingSend()
+-- end
+
+function Events:TRADE_SHOW(_)
     GBankClassic_Bank:OnUpdateStart()
 end
 
-function GBankClassic_Events:TRADE_CLOSED(_)
+function Events:TRADE_CLOSED(_)
     GBankClassic_Bank:OnUpdateStop()
 end
 
-function GBankClassic_Events:AUCTION_HOUSE_SHOW(_)
+function Events:AUCTION_HOUSE_SHOW(_)
     GBankClassic_Bank:OnUpdateStart()
 end
 
-function GBankClassic_Events:AUCTION_HOUSE_CLOSED(_)
+function Events:AUCTION_HOUSE_CLOSED(_)
     GBankClassic_Bank:OnUpdateStop()
 end
 
-function GBankClassic_Events:MERCHANT_SHOW(_)
+function Events:MERCHANT_SHOW(_)
     GBankClassic_Bank:OnUpdateStart()
 end
 
-function GBankClassic_Events:MERCHANT_CLOSED(_)
+function Events:MERCHANT_CLOSED(_)
     GBankClassic_Bank:OnUpdateStop()
 end
 
-local bagUpdateTimer = nil
-function GBankClassic_Events:BAG_UPDATE(_)
-    if bagUpdateTimer then return end
-    bagUpdateTimer = C_Timer.NewTimer(2, function()
+function Events:BAG_UPDATE(_)
+    if bagUpdateTimer then
+		return
+	end
+	
+    bagUpdateTimer = NewTimer(2, function()
         GBankClassic_Bank:Scan()
         bagUpdateTimer = nil
     end)
 end
 
-function GBankClassic_Events:PLAYER_REGEN_DISABLED(_)
+function Events:PLAYER_REGEN_DISABLED(_)
     if GBankClassic_Options:GetCombatHide() then
         GBankClassic_UI_Inventory:Close()
     end
diff --git a/Modules/Guild.lua b/Modules/Guild.lua
index 12befb3..743cab0 100644
--- a/Modules/Guild.lua
+++ b/Modules/Guild.lua
@@ -1,24 +1,41 @@
-GBankClassic_Guild = {}
+GBankClassic_Guild = GBankClassic_Guild or {}
 
-GBankClassic_Guild.Info = nil
+local Guild = GBankClassic_Guild
 
--- Cache of online guild members (updated via GUILD_ROSTER_UPDATE)
--- Avoids stale data from GuildRoster() which only requests an update
-GBankClassic_Guild.onlineMembers = {}
-
--- Cache of guild guild bank alts (updated via GUILD_ROSTER_UPDATE)
--- Prevents iterating through entire guild roster on every IsBank() call
-GBankClassic_Guild.banksCache = nil
-
--- Temporary in-memory error storage for when Guild.Info is not initialized
-GBankClassic_Guild.tempDeltaErrors = {
+Guild.Info = nil
+Guild.onlineMembers = {}
+Guild.banksCache = nil
+Guild.tempDeltaErrors = {
 	lastErrors = {},
 	failureCounts = {},
 	notifiedAlts = {},
 }
 
--- Migrate temporary errors to database once Guild.Info is initialized
-function GBankClassic_Guild:MigrateTempErrors()
+local PENDING_SYNC_TTL_SECONDS = 180
+
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("wipe")
+local wipe = upvalues.wipe
+local upvalues = Globals.GetUpvalues("GetNormalizedRealmName", "UnitName", "NewTicker", "IsInGuild", "GetGuildInfo", "GetNumGuildMembers", "GetGuildRosterInfo", "GetAddOnMetadata", "GetServerTime", "GetTime", "GetItemInfo", "After", "debugprofilestop", "CanViewOfficerNote")
+local GetNormalizedRealmName = upvalues.GetNormalizedRealmName
+local UnitName = upvalues.UnitName
+local NewTicker = upvalues.NewTicker
+local IsInGuild = upvalues.IsInGuild
+local GetGuildInfo = upvalues.GetGuildInfo
+local GetNumGuildMembers = upvalues.GetNumGuildMembers
+local GetGuildRosterInfo = upvalues.GetGuildRosterInfo
+local GetAddOnMetadata = upvalues.GetAddOnMetadata
+local GetServerTime = upvalues.GetServerTime
+local GetTime = upvalues.GetTime
+local GetItemInfo = upvalues.GetItemInfo
+local After = upvalues.After
+local debugprofilestop = upvalues.debugprofilestop
+local CanViewOfficerNote = upvalues.CanViewOfficerNote
+local upvalues = Globals.GetUpvalues("Item")
+local Item = upvalues.Item
+
+-- Migrate temporary errors to database once GBankClassic_Guild.Info is initialized
+function Guild:MigrateTempErrors()
 	if not self.Info or not self.Info.name then
 		return
 	end
@@ -63,26 +80,21 @@ function GBankClassic_Guild:MigrateTempErrors()
 end
 
 -- Record a delta error with details (persisted to database or temp storage)
-function GBankClassic_Guild:RecordDeltaError(altName, errorType, errorMessage)
+function Guild:RecordDeltaError(altName, errorType, errorMessage)
 	return GBankClassic_DeltaComms:RecordDeltaError(self.Info and self.Info.name, altName, errorType, errorMessage)
 end
 
 -- Reset failure count for an alt (called on successful sync)
-function GBankClassic_Guild:ResetDeltaErrorCount(altName)
+function Guild:ResetDeltaErrorCount(altName)
 	return GBankClassic_DeltaComms:ResetDeltaErrorCount(self.Info and self.Info.name, altName)
 end
 
--- Get recent delta errors
-function GBankClassic_Guild:GetRecentDeltaErrors()
-	return GBankClassic_DeltaComms:GetRecentDeltaErrors(self.Info and self.Info.name)
-end
-
 -- Get failure count for an alt
-function GBankClassic_Guild:GetDeltaFailureCount(altName)
+function Guild:GetDeltaFailureCount(altName)
 	return GBankClassic_DeltaComms:GetDeltaFailureCount(self.Info and self.Info.name, altName)
 end
 
-function GetPlayerWithNormalizedRealm(name)
+local function getPlayerWithNormalizedRealm(name)
 	if string.match(name, "(.*)%-(.*)") then
 		return name
 	end
@@ -90,12 +102,12 @@ function GetPlayerWithNormalizedRealm(name)
 	return name .. "-" .. GetNormalizedRealmName("player")
 end
 
-local function NormalizePlayerName(name)
+local function normalizePlayerName(name)
 	if not name then
 		return nil
 	end
 
-	if _G.type(name) ~= "string" then
+	if type(name) ~= "string" then
 		name = tostring(name)
 	end
 
@@ -125,16 +137,16 @@ local function NormalizePlayerName(name)
 	end
 
 	-- If helper exists, use it
-	if GetPlayerWithNormalizedRealm then
-		return GetPlayerWithNormalizedRealm(normalized)
+	if getPlayerWithNormalizedRealm then
+		return getPlayerWithNormalizedRealm(normalized)
 	end
 
 	-- Fallback: append current realm
 	return normalized .. "-" .. GetNormalizedRealmName("player")
 end
-GBankClassic_Guild.NormalizePlayerName = NormalizePlayerName
+Guild.NormalizePlayerName = normalizePlayerName
 
-function GBankClassic_Guild:NormalizeName(name)
+function Guild:NormalizeName(name)
 	if not name then
 		return nil
 	end
@@ -147,48 +159,55 @@ function GBankClassic_Guild:NormalizeName(name)
 	return name
 end
 
-function GBankClassic_Guild:GetNormalizedPlayer(name)
+function Guild:GetNormalizedPlayer(name)
 	return self:NormalizeName(name or self:GetPlayer())
 end
 
-function GBankClassic_Guild:GetPlayer()
+function Guild:GetPlayer()
+    -- Return cached player if available
     if GBankClassic_Bank.player then
         return GBankClassic_Bank.player
     end
 
-    -- The below code should never be called, but is here for safety
-    local function try()
-        local name, realm = UnitName("player"), GetNormalizedRealmName()
-        if name and realm then
-            GBankClassic_Bank.player = name .. "-" .. realm
+    -- Try to get player info immediately
+    local name, realm = UnitName("player"), GetNormalizedRealmName()
+    if name and realm then
+        GBankClassic_Bank.player = name .. "-" .. realm
 
-            return true
-        end
-    end
-    if try() then
         return GBankClassic_Bank.player
     end
-    local count, max, delay = 0, 10, 15
-	local timer
-    timer = C_Timer.NewTicker(delay, function()
-        count = count + 1
-        if try() or count >= max then
-            if timer then
+
+    -- If player info not yet available, set up background retry (happens once)
+    if not self._playerRetryScheduled then
+        self._playerRetryScheduled = true
+        local retryCount = 0
+        local maxRetries = 20
+        local timer
+        timer = NewTicker(0.5, function()
+            retryCount = retryCount + 1
+            local name, realm = UnitName("player"), GetNormalizedRealmName()
+            if name and realm then
+                GBankClassic_Bank.player = name .. "-" .. realm
                 timer:Cancel()
+                self._playerRetryScheduled = false
+            elseif retryCount >= maxRetries then
+                timer:Cancel()
+                self._playerRetryScheduled = false
             end
-        end
-    end)
-  
-    return nil
+        end)
+    end
+
+    -- Always return a value (cached or fallback)
+    return GBankClassic_Bank.player or "Unknown-Unknown"
 end
 
-function GBankClassic_Guild:GetGuild()
+function Guild:GetGuild()
     return IsInGuild("player") and GetGuildInfo("player") or nil
 end
 
 -- Check if a player is in the current guild roster
 -- Returns true if the player is a member of the current guild
-function GBankClassic_Guild:IsInCurrentGuildRoster(playerName)
+function Guild:IsInCurrentGuildRoster(playerName)
 	if not playerName then
 		return false
 	end
@@ -198,9 +217,6 @@ function GBankClassic_Guild:IsInCurrentGuildRoster(playerName)
 	end
 
 	local normPlayer = self:NormalizeName(playerName)
-
-    local GetNumGuildMembers = GetNumGuildMembers or C_GuildInfo.GetNumGuildMembers
-    local GetGuildRosterInfo = GetGuildRosterInfo or C_GuildInfo.GetGuildRosterInfo
 	for i = 1, GetNumGuildMembers() do
 		local rosterName = GetGuildRosterInfo(i)
 		if rosterName then
@@ -214,9 +230,7 @@ function GBankClassic_Guild:IsInCurrentGuildRoster(playerName)
 	return false
 end
 
-function GBankClassic_Guild:GetPlayerInfo(name)
-    local GetNumGuildMembers = GetNumGuildMembers or C_GuildInfo.GetNumGuildMembers
-    local GetGuildRosterInfo = GetGuildRosterInfo or C_GuildInfo.GetGuildRosterInfo
+function Guild:GetPlayerInfo(name)
     for i = 1, GetNumGuildMembers() do
         local playerRealm, _, _, _, _, _, _, _, _, _, class = GetGuildRosterInfo(i)
         if playerRealm == name then
@@ -227,7 +241,7 @@ function GBankClassic_Guild:GetPlayerInfo(name)
     return nil
 end
 
-function GBankClassic_Guild:Reset(name)
+function Guild:Reset(name)
 	if not name then
 		return
 	end
@@ -235,14 +249,14 @@ function GBankClassic_Guild:Reset(name)
     GBankClassic_UI_Inventory:Close()
     GBankClassic_Database:Reset(name)
     self.Info = GBankClassic_Database:Load(name)
+	-- self:EnsureRequestsInitialized()
 	self:MigrateTempErrors()
 end
 
-function GBankClassic_Guild:Init(name)
+function Guild:Init(name)
 	if not name then
 		return false
 	end
-
 	if self.Info and self.Info.name == name then
 		return false
 	end
@@ -252,6 +266,7 @@ function GBankClassic_Guild:Init(name)
 
     self.Info = GBankClassic_Database:Load(name)
 	if self.Info then
+		-- self:EnsureRequestsInitialized()
 		self:MigrateTempErrors()
 		self:RebuildGuildBankAltsRoster()
 
@@ -263,7 +278,7 @@ function GBankClassic_Guild:Init(name)
     return true
 end
 
-function GBankClassic_Guild:CleanupMalformedAlts()
+function Guild:CleanupMalformedAlts()
 	if not self.Info or not self.Info.alts then
 		return 0
 	end
@@ -271,24 +286,18 @@ function GBankClassic_Guild:CleanupMalformedAlts()
     local cleaned = 0
     for name, alt in pairs(self.Info.alts) do
         local remove = false
-        if _G.type(alt) ~= "table" then
+        if type(alt) ~= "table" then
             remove = true
         else
             -- Ensure version is present, but malformed nested fields are problematic
-            if alt.bank and _G.type(alt.bank) == "table" and alt.bank.items then
-                for k, v in pairs(alt.bank.items) do
-                    if not v or _G.type(v) ~= "table" or not v.ID then
-                        alt.bank.items[k] = nil
-                    end
-                end
-            end
-            if alt.bags and _G.type(alt.bags) == "table" and alt.bags.items then
-                for k, v in pairs(alt.bags.items) do
-                    if not v or _G.type(v) ~= "table" or not v.ID then
-                        alt.bags.items[k] = nil
-                    end
-                end
-            end
+			if alt.items then
+				-- alt.items should be an array or a map of items with ID fields; remove any empty entries
+				for k, v in pairs(alt.items) do
+					if not v or type(v) ~= "table" or not v.ID then
+						alt.items[k] = nil
+					end
+				end
+			end
             -- If after cleaning the alt has no meaningful fields (no version, no money, no items), remove it
 			local hasData = false
 			if alt.version then
@@ -297,10 +306,7 @@ function GBankClassic_Guild:CleanupMalformedAlts()
 			if alt.money then
 				hasData = true
 			end
-			if alt.bank and next(alt.bank.items or {}) then
-				hasData = true
-			end
-			if alt.bags and next(alt.bags.items or {}) then
+			if alt.items and next(alt.items) then
 				hasData = true
 			end
 			if not hasData then
@@ -319,7 +325,7 @@ function GBankClassic_Guild:CleanupMalformedAlts()
     if self.Info.roster and self.Info.roster.alts then
         local new_alts = {}
         for _, v in pairs(self.Info.roster.alts) do
-            if _G.type(v) == "string" and v ~= "" then
+            if type(v) == "string" and v ~= "" then
                 table.insert(new_alts, v)
             end
         end
@@ -329,7 +335,7 @@ function GBankClassic_Guild:CleanupMalformedAlts()
     return cleaned
 end
 
-function GBankClassic_Guild:GetBanks()
+function Guild:GetBanks()
 	-- Return cached banks list if available
 	if self.banksCache ~= nil then
 		return self.banksCache
@@ -337,12 +343,10 @@ function GBankClassic_Guild:GetBanks()
 
 	-- Build banks list
     local banks = {}
-    local GetNumGuildMembers = GetNumGuildMembers or C_GuildInfo.GetNumGuildMembers
-    local GetGuildRosterInfo = GetGuildRosterInfo or C_GuildInfo.GetGuildRosterInfo
     for i = 1, GetNumGuildMembers() do
-        local name, _, _, _, _, _, publicNote, officer_note, _, _, _ = GetGuildRosterInfo(i)
+        local name, _, _, _, _, _, publicNote, officer_note = GetGuildRosterInfo(i)
         if publicNote ~= nil or officer_note ~= nil then
-            if string.match(publicNote, "(.*)gbank(.*)") or string.match(officer_note, "(.*)gbank(.*)") then
+            if (publicNote and string.match(publicNote, "(.*)gbank(.*)")) or (officer_note and string.match(officer_note, "(.*)gbank(.*)")) then
                 table.insert(banks, name)
             end
         end
@@ -353,27 +357,26 @@ function GBankClassic_Guild:GetBanks()
 		self.banksCache = nil
 		return nil
 	end
+
 	self.banksCache = banks
 
 	return banks
 end
 
 -- Invalidate the banks cache (call when guild roster changes)
-function GBankClassic_Guild:InvalidateBanksCache()
+function Guild:InvalidateBanksCache()
 	self.banksCache = nil
 end
 
 -- Rebuild roster of guild bank alts from local guild notes (no network communication needed)
 -- Called automatically on GUILD_ROSTER_UPDATE event
--- Note: this will be incomplete for players without access to view officer notes where gbank can also be maintained
-function GBankClassic_Guild:RebuildGuildBankAltsRoster()
+-- This will be incomplete for players without access to view officer notes where gbank can also be maintained
+function Guild:RebuildGuildBankAltsRoster()
 	if not self.Info then
 		return
 	end
 
 	local banks = {}
-    local GetNumGuildMembers = GetNumGuildMembers or C_GuildInfo.GetNumGuildMembers
-    local GetGuildRosterInfo = GetGuildRosterInfo or C_GuildInfo.GetGuildRosterInfo
 	for i = 1, GetNumGuildMembers() do
 		local name, _, _, _, _, _, publicNote, officer_note = GetGuildRosterInfo(i)
 		if name and (publicNote or officer_note) then
@@ -389,11 +392,11 @@ function GBankClassic_Guild:RebuildGuildBankAltsRoster()
 	
 	if oldRoster ~= newRoster then
 		self.Info.roster.alts = banks
-		GBankClassic_Output:Debug("ROSTER", "Rebuilt banker roster from guild notes: %d bankers", #banks)
+		GBankClassic_Output:Debug("ROSTER", "Rebuilt guild bank alt roster from guild notes: %d guild bank alts", #banks)
 	end
 end
 
-function GBankClassic_Guild:GetRosterAlts()
+function Guild:GetRosterAlts()
 	if not self.Info then
 		return nil
 	end
@@ -403,7 +406,7 @@ function GBankClassic_Guild:GetRosterAlts()
 
 	if roster and roster.alts then
 		for _, v in pairs(roster.alts) do
-			if _G.type(v) == "string" and v ~= "" then
+			if type(v) == "string" and v ~= "" then
 				table.insert(list, v)
 			end
 		end
@@ -414,7 +417,7 @@ function GBankClassic_Guild:GetRosterAlts()
 	end
 
 	for name, alt in pairs(self.Info.alts or {}) do
-		if _G.type(alt) == "table" then
+		if type(alt) == "table" then
 			table.insert(list, name)
 		end
 	end
@@ -429,16 +432,16 @@ end
 -- Request missing guild bank alts on UI open
 -- Compares roster guild bank alts against local alt data and queries for missing guild bank alts
 -- Use current guild roster instead of cached roster to prevent requesting data for guild bank alts from other guilds
-function GBankClassic_Guild:FastFillMissingAlts()
+function Guild:FastFillMissingAlts()
 	return GBankClassic_DeltaComms:FastFillMissingAlts(self.Info)
 end
 
-function GBankClassic_Guild:IsBank(player)
+function Guild:IsBank(player)
 	if not player then
 		return false
 	end
 
-    local banks = GBankClassic_Guild:GetBanks()
+    local banks = self:GetBanks()
 	if banks == nil then
 		return false
 	end
@@ -455,34 +458,11 @@ function GBankClassic_Guild:IsBank(player)
     return isBank
 end
 
-function GBankClassic_Guild:GetAnyGuildBankAlt()
-	local banks = self:GetBanks()
-	if not banks or #banks == 0 then
-		return nil
-	end
-
-	-- Return the first guild bank alt (normalized)
-	return self:NormalizeName(banks[1])
-end
-
-function GBankClassic_Guild:CheckVersion(version)
-	if self.Info then
-		return false
-	end
-
-	if version > self.Info.roster.version then
-		return false
-	end
-
-	return true
-end
-
-function GBankClassic_Guild:GetVersion()
+function Guild:GetVersion()
 	if not self.Info then
 		return nil
 	end
 
-    local GetAddOnMetadata = GetAddOnMetadata or C_AddOns.GetAddOnMetadata
     local versionInfo = GetAddOnMetadata("GBankClassic", "Version"):gsub("%.", "")
     local versionNumber = tonumber(versionInfo)
     local data = {
@@ -496,13 +476,18 @@ function GBankClassic_Guild:GetVersion()
     if self.Info.name then
         data.name = self.Info.name
     end
-
     if self.Info.roster.version then
         data.roster = self.Info.roster.version
     end
 
+	-- -- Include request sync summary (version + hash) in version broadcasts.
+	-- data.requests = {
+	-- 	version = self:GetRequestsVersion(),
+	-- 	hash = self:GetRequestsHash(),
+	-- }
+
     for k, v in pairs(self.Info.alts) do
-        if _G.type(v) == "table" and v.version then
+        if type(v) == "table" and v.version then
 			-- Send hash only in delta-enabled mode (backwards compatibility)
 			if PROTOCOL.SUPPORTS_DELTA and v.inventoryHash then
 				data.alts[k] = {
@@ -521,12 +506,11 @@ function GBankClassic_Guild:GetVersion()
     return data
 end
 
-local PENDING_SYNC_TTL_SECONDS = 180
-
-function GBankClassic_Guild:MarkPendingSync(syncType, sender, name)
+function Guild:MarkPendingSync(syncType, sender, name)
 	if not syncType or not sender then
 		return
 	end
+
 	local now = GetServerTime()
 	local normSender = self:NormalizeName(sender)
 	if not self.pending_sync then
@@ -540,21 +524,21 @@ function GBankClassic_Guild:MarkPendingSync(syncType, sender, name)
 	end
 
 	if syncType == "roster" then
-		if self.pending_sync.roster then
+		if self.pending_sync.roster and normSender then
 			self.pending_sync.roster[normSender] = now
 		end
 	elseif syncType == "alt" and name then
 		local normName = self:NormalizeName(name)
-		if self.pending_sync.alts and not self.pending_sync.alts[normName] then
+		if self.pending_sync.alts and normName and not self.pending_sync.alts[normName] then
 			self.pending_sync.alts[normName] = {}
 		end
-		if self.pending_sync.alts and self.pending_sync.alts[normName] then
+		if self.pending_sync.alts and normName and normSender and self.pending_sync.alts[normName] then
 			self.pending_sync.alts[normName][normSender] = now
 		end
 	end
 end
 
-function GBankClassic_Guild:ConsumePendingSync(syncType, sender, name)
+function Guild:ConsumePendingSync(syncType, sender, name)
 	if not syncType or not sender then
 		return false
 	end
@@ -564,7 +548,7 @@ function GBankClassic_Guild:ConsumePendingSync(syncType, sender, name)
 	end
 
 	local now = GetServerTime()
-	local normSender = self:NormalizeName(sender)
+	local normSender = self:NormalizeName(sender) or ""
 	if syncType == "roster" then
 		local roster = self.pending_sync.roster
 		local ts = roster and roster[normSender]
@@ -580,7 +564,7 @@ function GBankClassic_Guild:ConsumePendingSync(syncType, sender, name)
 		return false
 	end
 	if syncType == "alt" and name then
-		local normName = self:NormalizeName(name)
+		local normName = self:NormalizeName(name) or ""
 		local alts = self.pending_sync.alts and self.pending_sync.alts[normName]
 		local ts = alts and alts[normSender]
 		if ts and now - ts <= PENDING_SYNC_TTL_SECONDS then
@@ -602,7 +586,7 @@ function GBankClassic_Guild:ConsumePendingSync(syncType, sender, name)
 	return false
 end
 
-function GBankClassic_Guild:QueryRoster(player, version)
+function Guild:QueryRoster(player, version)
 	self.hasRequested = true
 	if self.requestCount == nil then
 		self.requestCount = 1
@@ -614,7 +598,7 @@ function GBankClassic_Guild:QueryRoster(player, version)
 	GBankClassic_Core:SendCommMessage("gbank-r", data, "Guild", nil, "NORMAL")
 end
 
-function GBankClassic_Guild:QueryAlt(player, name, version)
+function Guild:QueryAlt(player, name, version)
 	self.hasRequested = true
 	if self.requestCount == nil then
 		self.requestCount = 1
@@ -626,13 +610,13 @@ function GBankClassic_Guild:QueryAlt(player, name, version)
 	GBankClassic_Core:SendCommMessage("gbank-r", data, "Guild", nil, "NORMAL")
 end
 
--- Pull-based query - WHISPER to guild bank alt if known, GUILD if unknown
-function GBankClassic_Guild:QueryAltPullBased(name)
+-- Pull-based query - whisper to guild bank alt if known, send to guild otherwise
+function Guild:QueryAltPullBased(name)
 	if not name then
 		return
 	end
 
-	local norm = self:NormalizeName(name)
+	local norm = self:NormalizeName(name) or ""
 	self.hasRequested = true
 	if self.requestCount == nil then
 		self.requestCount = 1
@@ -644,7 +628,7 @@ function GBankClassic_Guild:QueryAltPullBased(name)
 	self._lastQueryTime = self._lastQueryTime or {}
 	local now = GetTime()
 	local last = self._lastQueryTime[norm] or 0
-	local cooldown = 15 -- seconds
+	local cooldown = 15 -- Seconds
 	if now - last < cooldown then
 		GBankClassic_Output:Debug("SYNC", "QueryAltPullBased: Skipping %s due to cooldown (%.2fs remaining)", norm, cooldown - (now - last))
 
@@ -674,21 +658,21 @@ function GBankClassic_Guild:QueryAltPullBased(name)
 	local data = GBankClassic_Core:SerializeWithChecksum(request)
 
 	if guildBankAlt and (GetServerTime() - mostRecent) < 600 and self:IsPlayerOnline(guildBankAlt) then
-		-- Guild bank alt known, seen recently (within 10 min), AND currently online - WHISPER directly
-		GBankClassic_Output:DebugComm("SENDING WHISPER: gbank-r to %s for alt %s", guildBankAlt, norm)
-		GBankClassic_Output:Debug("SYNC", "Pull-based query for %s (WHISPER to guild bank alt %s)", norm, guildBankAlt)
+		-- Guild bank alt known, seen recently (within 10 min), and currently online - whisper directly
+		GBankClassic_Output:DebugComm("Sending whisper: gbank-r to %s for alt %s", guildBankAlt, norm)
+		GBankClassic_Output:Debug("SYNC", "Pull-based query for %s (whisper to guild bank alt %s)", norm, guildBankAlt)
 		GBankClassic_Core:SendWhisper("gbank-r", data, guildBankAlt, "NORMAL")
 		self:MarkPendingSync("alt", guildBankAlt, norm)
 	else
-		-- No known guild bank alt, stale, or offline - broadcast on GUILD
-		GBankClassic_Output:DebugComm("SENDING GUILD BROADCAST: gbank-r for alt %s (no online guild bank alt)", norm)
-		GBankClassic_Output:Debug("SYNC", "Pull-based query for %s (GUILD broadcast, no online guild bank alt)", norm)
+		-- No known guild bank alt, stale, or offline - broadcast to guild
+		GBankClassic_Output:DebugComm("Sending guild broadcast: gbank-r for alt %s (no online guild bank alt)", norm)
+		GBankClassic_Output:Debug("SYNC", "Pull-based query for %s (guild broadcast, no online guild bank alt)", norm)
 		GBankClassic_Core:SendCommMessage("gbank-r", data, "GUILD", nil, "NORMAL")
 		self:MarkPendingSync("alt", nil, norm)
 	end
 end
 
-function GBankClassic_Guild:SendRosterData()
+function Guild:SendRosterData()
 	if not self.Info then
 		return
 	end
@@ -697,41 +681,15 @@ function GBankClassic_Guild:SendRosterData()
 	GBankClassic_Core:SendCommMessage("gbank-d", data, "Guild", nil, "BULK")
 end
 
-function GBankClassic_Guild:ReceiveRosterData(roster)
-	if not self.Info then
-		return
-	end
-
-	if self.Info.roster.version and roster.version and roster.version < self.Info.roster.version then
-		return
-	end
-
-	if self.hasRequested then
-		if self.requestCount == nil then
-			self.requestCount = 0
-		else
-			self.requestCount = self.requestCount - 1
-		end
-		if self.requestCount == 0 then
-			self.hasRequested = false
-			GBankClassic_Output:Info("Sync completed.")
-		end
-	end
-
-	self.Info.roster = roster
-end
-
-function GBankClassic_Guild:SenderHasGbankNote(sender)
+function Guild:SenderHasGbankNote(sender)
 	if not sender then
 		return false
 	end
 
-    local GetNumGuildMembers = GetNumGuildMembers or C_GuildInfo.GetNumGuildMembers
-    local GetGuildRosterInfo = GetGuildRosterInfo or C_GuildInfo.GetGuildRosterInfo
     for i = 1, GetNumGuildMembers() do
         local playerRealm, _, _, _, _, _, publicNote, officer_note = GetGuildRosterInfo(i)
         if playerRealm then
-            local norm = NormalizePlayerName(playerRealm)
+            local norm = self:NormalizeName(playerRealm)
             if norm == sender then
                 if (publicNote and string.match(publicNote, "(.*)gbank(.*)")) or (officer_note and string.match(officer_note, "(.*)gbank(.*)")) then
                     return true
@@ -745,14 +703,10 @@ end
 
 -- Refresh the online members cache from current guild roster
 -- Called automatically when GUILD_ROSTER_UPDATE event fires
-function GBankClassic_Guild:RefreshOnlineCache()
-	local startTime = debugprofilestop()
-
+function Guild:RefreshOnlineCache()
 	self.onlineMembers = self.onlineMembers or {}
 	wipe(self.onlineMembers)
 
-    local GetNumGuildMembers = GetNumGuildMembers or C_GuildInfo.GetNumGuildMembers
-    local GetGuildRosterInfo = GetGuildRosterInfo or C_GuildInfo.GetGuildRosterInfo
 	for i = 1, GetNumGuildMembers() do
 		local name, _, _, _, _, _, _, _, isOnline = GetGuildRosterInfo(i)
 		if name and isOnline then
@@ -763,20 +717,15 @@ function GBankClassic_Guild:RefreshOnlineCache()
 		end
 	end
 
-	local count = 0
-	for _ in pairs(self.onlineMembers) do
-		count = count + 1
-	end
-
-	local duration = debugprofilestop() - startTime
-	GBankClassic_Performance:RecordOperation("RefreshOnlineCache", duration)
+	local count = GBankClassic_Globals:Count(self.onlineMembers)
+	-- TODO, one or the other
 	GBankClassic_Output:Debug("CACHE", "Refreshed online cache: %d members online", count)
-	GBankClassic_Output:Debug("ROSTER", "[GUILD ROSTER] Refreshed online cache: %d members online", count)
+	GBankClassic_Output:Debug("ROSTER", "Refreshed online cache: %d members online", count)
 end
 
 -- Check if a player is currently online in the guild
 -- Uses cached roster data updated via GUILD_ROSTER_UPDATE event
-function GBankClassic_Guild:IsPlayerOnline(playerName)
+function Guild:IsPlayerOnline(playerName)
 	if not playerName then
 		return false
 	end
@@ -789,7 +738,7 @@ end
 -- Compute minimal state summary for pull-based protocol
 -- Returns {[itemID] = quantity} - no links, bags, slots, or metadata
 -- ~800 bytes for 100 items vs 5-7KB for full data
-function GBankClassic_Guild:ComputeStateSummary(name)
+function Guild:ComputeStateSummary(name)
 	if not name then
 		return nil
 	end
@@ -798,12 +747,7 @@ function GBankClassic_Guild:ComputeStateSummary(name)
 
 	-- If we don't have data for this alt, return a "no data" summary
 	if not self.Info or not self.Info.alts or not self.Info.alts[norm] then
-		return {
-			version = 0,
-			hash = nil,
-			money = 0,
-			items = {}
-		}
+		return { version = 0, hash = nil, money = 0, items = {} }
 	end
 
 	local alt = self.Info.alts[norm]
@@ -816,7 +760,10 @@ function GBankClassic_Guild:ComputeStateSummary(name)
 
 	-- Aggregate items by ID (combine bank + bags)
 	local function addItems(items)
-		if not items then return end
+		if not items then
+			return
+		end
+
 		for _, item in ipairs(items) do
 			if item and item.ID then
 				local id = tostring(item.ID)
@@ -826,21 +773,18 @@ function GBankClassic_Guild:ComputeStateSummary(name)
 		end
 	end
 
-	if alt.bank and alt.bank.items then
-		addItems(alt.bank.items)
-	end
-	if alt.bags and alt.bags.items then
-		addItems(alt.bags.items)
+	if alt.items then
+		addItems(alt.items)
 	end
 
 	return summary
 end
 
 -- Send state summary to responder (step 4 of pull-based flow)
-function GBankClassic_Guild:SendStateSummary(name, target)
-	GBankClassic_Output:DebugComm("SendStateSummary CALLED: name=%s, target=%s", tostring(name), tostring(target))
+function Guild:SendStateSummary(name, target)
+	GBankClassic_Output:DebugComm("SendStateSummary called: name=%s, target=%s", tostring(name), tostring(target))
 	if not name or not target then
-		GBankClassic_Output:DebugComm("SendStateSummary EARLY RETURN: missing params")
+		GBankClassic_Output:DebugComm("SendStateSummary early return: missing params")
 
 		return
 	end
@@ -860,32 +804,21 @@ function GBankClassic_Guild:SendStateSummary(name, target)
 	}
 
 	local data = GBankClassic_Core:SerializeWithChecksum(message)
-	GBankClassic_Output:DebugComm("SENDING STATE SUMMARY via WHISPER to %s for %s (%d bytes, hash=%s)", target, name, #data, tostring(summary.hash))
+	GBankClassic_Output:DebugComm("Sending state summary via whisper to %s for %s (%d bytes, hash=%s)", target, name, #data, tostring(summary.hash))
 	if not GBankClassic_Core:SendWhisper("gbank-state", data, target, "NORMAL") then
 		return
 	end
 
-	local itemCount = 0
-	for _ in pairs(summary.items) do
-        itemCount = itemCount + 1
-    end
-
-	GBankClassic_Output:Debug(
-		"SYNC",
-		"Sent state summary for %s to %s (%d unique items, %d bytes)",
-		name,
-		target,
-		itemCount,
-		string.len(data)
-	)
+	local itemCount = GBankClassic_Globals:Count(summary.items)
+	GBankClassic_Output:Debug("SYNC", "Sent state summary for %s to %s (%d unique items, %d bytes)", name, target, itemCount, string.len(data))
 end
 
 -- Respond to state summary (step 5 & 6 of pull-based flow)
 -- Compare requester's state with our data and send appropriate response
-function GBankClassic_Guild:RespondToStateSummary(name, summary, requester)
-	GBankClassic_Output:DebugComm("RespondToStateSummary CALLED: name=%s, requester=%s", tostring(name), tostring(requester))
+function Guild:RespondToStateSummary(name, summary, requester)
+	GBankClassic_Output:DebugComm("RespondToStateSummary called: name=%s, requester=%s", tostring(name), tostring(requester))
 	if not name or not summary or not requester then
-		GBankClassic_Output:DebugComm("RespondToStateSummary EARLY RETURN: missing params")
+		GBankClassic_Output:DebugComm("RespondToStateSummary early return: missing params")
 		return
 	end
 
@@ -893,6 +826,7 @@ function GBankClassic_Guild:RespondToStateSummary(name, summary, requester)
 	if not self.Info or not self.Info.alts or not self.Info.alts[norm] then
 		GBankClassic_Output:DebugComm("RespondToStateSummary: No data for %s", norm)
 		GBankClassic_Output:Debug("SYNC", "Cannot respond to state summary for %s (no data)", norm)
+
 		return
 	end
 
@@ -900,7 +834,7 @@ function GBankClassic_Guild:RespondToStateSummary(name, summary, requester)
 	local requesterVersion = summary.version or 0
 	local currentVersion = currentAlt.version or 0
 
-	-- In delta mode, compare HASHES not versions
+	-- In delta mode, compare hashes not versions
 	local requesterHash = summary.hash or nil
 	local currentHash = currentAlt.inventoryHash or nil
 
@@ -909,7 +843,7 @@ function GBankClassic_Guild:RespondToStateSummary(name, summary, requester)
 	-- Track last sent hash per guild+alt+requester
 	self._lastSentState = self._lastSentState or {}
 	local key = norm .. ":" .. requester
-	local hashOrVersion = self:ShouldUseDelta() and (currentHash or 0) or currentVersion
+	local hashOrVersion = currentHash or 0
 	if self._lastSentState[key] == hashOrVersion then
 		GBankClassic_Output:DebugComm("RespondToStateSummary: already sent data to %s for %s (hash/version unchanged), skipping", requester, norm)
 		GBankClassic_Output:Debug("SYNC", "RespondToStateSummary: already sent data to %s for %s (hash/version unchanged), skipping", requester, norm)
@@ -917,176 +851,323 @@ function GBankClassic_Guild:RespondToStateSummary(name, summary, requester)
 		return
 	end
 
-	-- Delta mode - ONLY use hashes, no version fallback
-	if self:ShouldUseDelta() then
-		-- If current alt doesn't have a hash, send full data (might be from pre-hash version)
-		if not currentHash then
-			GBankClassic_Output:DebugComm("DELTA MODE: Current alt missing hash - sending full data for %s", norm)
-			GBankClassic_Output:Debug("SYNC", "Sending full data to %s for %s (responder has no hash)", requester, norm)
-			self:SendAltData(norm, requester)
-			self._lastSentState[key] = hashOrVersion
-
-			return
-		end
-
-		-- If requester has no hash (nil), they have no data - send everything
-		if not requesterHash then
-			GBankClassic_Output:DebugComm("DELTA MODE: REQUESTER HAS NO DATA (hash=nil) - sending full data for %s", norm)
-			GBankClassic_Output:Debug("SYNC", "Sending full data to %s for %s (requester has no data)", requester, norm)
-			self:SendAltData(norm, requester)
-			self._lastSentState[key] = hashOrVersion
-
-			return
-		end
+	-- Delta mode - only use hashes, no version fallback
+	-- If current alt doesn't have a hash, send full data (might be from pre-hash version)
+	if not currentHash then
+		GBankClassic_Output:DebugComm("Delta mode: Current alt missing hash - sending full data for %s", norm)
+		GBankClassic_Output:Debug("SYNC", "Sending full data to %s for %s (responder has no hash)", requester, norm)
+		self:SendAltData(norm, requester)
+		self._lastSentState[key] = hashOrVersion
 
-		if requesterHash == currentHash then
-			-- Hashes match - no changes needed
-			local noChangeMsg = {
-				type = "no-change",
-				name = norm,
-				version = currentVersion,
-				hash = currentHash,
-			}
-			local data = GBankClassic_Core:SerializeWithChecksum(noChangeMsg)
-			GBankClassic_Output:DebugComm("DELTA MODE: SENDING NO-CHANGE to %s for %s (hash match: %d)", requester, norm, currentHash)
-			if not GBankClassic_Core:SendWhisper("gbank-nochange", data, requester, "NORMAL") then
-				return
-			end
-			GBankClassic_Output:Debug("SYNC", "Sent no-change reply to %s for %s (hash=%d)", requester, norm, currentHash)
-			self._lastSentState[key] = hashOrVersion
+		return
+	end
 
-			return
-		else
-			-- Hashes differ - send data
-			GBankClassic_Output:DebugComm("DELTA MODE: HASH MISMATCH - calling SendAltData for %s (requester=%d, current=%d)", norm, requesterHash, currentHash)
-			GBankClassic_Output:Debug(
-				"SYNC",
-				"Sending data to %s for %s (hash mismatch: requester=%d, current=%d)",
-				requester,
-				norm,
-				requesterHash,
-				currentHash
-			)
-			self:SendAltData(norm, requester)
-			self._lastSentState[key] = hashOrVersion
+	-- If requester has no hash (nil), they have no data - send everything
+	if not requesterHash then
+		GBankClassic_Output:DebugComm("Delta mode: Requestor has no data (hash=nil) - sending full data for %s", norm)
+		GBankClassic_Output:Debug("SYNC", "Sending full data to %s for %s (requester has no data)", requester, norm)
+		self:SendAltData(norm, requester)
+		self._lastSentState[key] = hashOrVersion
 
-			return
-		end
+		return
 	end
 
-	-- Legacy mode: compare versions only
-	GBankClassic_Output:DebugComm("LEGACY MODE: Comparing versions")
-	if requesterVersion == currentVersion then
-		-- No changes - send no-change message
+	if requesterHash == currentHash then
+		-- Hashes match - no changes needed
 		local noChangeMsg = {
 			type = "no-change",
 			name = norm,
 			version = currentVersion,
+			hash = currentHash,
 		}
 		local data = GBankClassic_Core:SerializeWithChecksum(noChangeMsg)
-		GBankClassic_Output:DebugComm("SENDING NO-CHANGE to %s for %s (version match)", requester, norm)
+		GBankClassic_Output:DebugComm("Delta mode: Sending no-change to %s for %s (hash match: %d)", requester, norm, currentHash)
 		if not GBankClassic_Core:SendWhisper("gbank-nochange", data, requester, "NORMAL") then
 			return
 		end
-		GBankClassic_Output:Debug("SYNC", "Sent no-change reply to %s for %s (v%d)", requester, norm, currentVersion)
+
+		GBankClassic_Output:Debug("SYNC", "Sent no-change reply to %s for %s (hash=%d)", requester, norm, currentHash)
 		self._lastSentState[key] = hashOrVersion
 
 		return
-	end
+	else
+		-- Hashes differ - send data
+		GBankClassic_Output:DebugComm("Delta mode: Hash mismatch, calling SendAltData for %s (requester=%d, current=%d)", norm, requesterHash, currentHash)
+		GBankClassic_Output:Debug("SYNC", "Sending data to %s for %s (hash mismatch: requester=%d, current=%d)", requester, norm, requesterHash, currentHash)
+		self:SendAltData(norm, requester)
+		self._lastSentState[key] = hashOrVersion
 
-	-- Version mismatch - send full data
-	GBankClassic_Output:Debug("SYNC", "Sending data to %s for %s (version mismatch: requester=%d, current=%d)", requester, norm, requesterVersion, currentVersion)
-	self:SendAltData(norm, requester)
-	self._lastSentState[key] = hashOrVersion
+		return
+	end
 end
 
 -- Strip link fields from items for transmission (bandwidth optimization)
 -- Saves 60-80 bytes per item, receiver reconstructs with GetItemInfo()
-function GBankClassic_Guild:StripItemLinks(items)
+function Guild:StripItemLinks(items)
 	if not items then
 		return nil
 	end
 
 	local stripped = {}
 	for _, item in ipairs(items) do
-		table.insert(stripped, {
+		local strippedItem = {
 			ID = item.ID,
 			Count = item.Count
-		})
+		}
+
+		-- Preserve itemString for items with unique stats (suffixes, enchants, etc.)
+		-- Extract from link if available: |Hitem:itemString|h[Name]|h
+		if item.Link then
+			local itemString = string.match(item.Link, "item:([^|]+)")
+			if itemString then
+				strippedItem.ItemString = itemString
+			end
+		end
+
+		table.insert(stripped, strippedItem)
 	end
+
 	return stripped
 end
 
 -- Reconstruct link fields after receiving data
--- Calls GetItemInfo() to recreate links from ItemID
-function GBankClassic_Guild:ReconstructItemLinks(items)
-	if not items then
+-- Calls GetItemInfo() to recreate links from ItemID or ItemString
+-- Throttle UI refreshes to prevent stuttering when many items load async
+local lastUIRefresh = 0
+local function throttledUIRefresh()
+	local now = GetTime()
+	if now - lastUIRefresh < 0.5 then -- Throttle to max once per 0.5 seconds
 		return
 	end
 
-	local needsAsyncLoad = false
+	lastUIRefresh = now
 
-	for _, item in ipairs(items) do
+	-- Only refresh if UI is actually open
+	if GBankClassic_UI_Inventory and GBankClassic_UI_Inventory.isOpen then
+		GBankClassic_UI_Inventory:DrawContent()
+	end
+	if GBankClassic_UI_Search and GBankClassic_UI_Search.isOpen then
+		GBankClassic_UI_Search:DrawContent()
+	end
+end
+
+-- Queue system for batched item reconstruction
+local itemReconstructQueue = {}
+local isProcessingQueue = false
+local pendingAsyncLoads = 0 -- Track number of pending async loads
+local MAX_CONCURRENT_ASYNC = 3 -- Limit concurrent async operations
+local BATCH_SIZE = 10 -- Process 10 items at a time
+local BATCH_DELAY = 0.2 -- 0.2 second delay between batches (slower = smoother)
+
+local function processItemQueue()
+	if #itemReconstructQueue == 0 then
+		isProcessingQueue = false
+		
+		return
+	end
+
+	-- Process a batch of items
+	local processCount = math.min(BATCH_SIZE, #itemReconstructQueue)
+	local loadedAnyInBatch = false
+
+	for i = 1, processCount do
+		local item = table.remove(itemReconstructQueue, 1)
 		if item and item.ID and not item.Link then
-			-- Try to get link from item cache
-			local itemLink = select(2, GetItemInfo(item.ID))
-			if itemLink then
-				item.Link = itemLink
-			else
-				-- Item not in cache, use async loading
-				needsAsyncLoad = true
-				local itemObj = Item:CreateFromItemID(item.ID)
-				if itemObj then
-					itemObj:ContinueOnItemLoad(function()
-						local link = itemObj:GetItemLink()
-						if link then
-							item.Link = link
-							-- Refresh UI when link becomes available
-							if GBankClassic_UI_Inventory and GBankClassic_UI_Inventory.isOpen then
-								GBankClassic_UI_Inventory:DrawContent()
+			-- If we have an ItemString, use it to reconstruct full link
+			if item.ItemString then
+				local itemName = GetItemInfo(item.ID)
+				if itemName then
+					item.Link = string.format("|cffffffff|Hitem:%s|h[%s]|h|r", item.ItemString, itemName)
+					loadedAnyInBatch = true
+				else
+					-- Item not in cache - only start async if under limit
+					if pendingAsyncLoads < MAX_CONCURRENT_ASYNC then
+						pendingAsyncLoads = pendingAsyncLoads + 1
+						local itemObj = Item:CreateFromItemID(item.ID)
+
+						-- Check itemObj state
+						GBankClassic_Output:Debug("ITEM", "ItemString item %d: itemObj=%s, itemObj.itemID=%s", item.ID or -1, tostring(itemObj), itemObj and tostring(itemObj.itemID) or "nil")
+
+						if itemObj and itemObj.itemID and itemObj.itemID == item.ID then
+							-- Item object is valid, try ContinueOnItemLoad with error protection
+							GBankClassic_Output:Debug("ITEM", "ItemString item %d passed validation, calling ContinueOnItemLoad", item.ID)
+							local success, err = pcall(function()
+								itemObj:ContinueOnItemLoad(function()
+									pendingAsyncLoads = pendingAsyncLoads - 1
+									local name = itemObj:GetItemName()
+									if name then
+										item.Link = string.format("|cffffffff|Hitem:%s|h[%s]|h|r", item.ItemString, name)
+										throttledUIRefresh()
+									end
+								end)
+							end)
+							if not success then
+								GBankClassic_Output:Debug("ITEM", "ContinueOnItemLoad crashed for ItemString item %d: %s", item.ID, tostring(err))
+								pendingAsyncLoads = pendingAsyncLoads - 1
 							end
+						else
+							-- Item object is nil or corrupted, skip
+							GBankClassic_Output:Debug("ITEM", "ItemString item %d failed validation, skipping", item.ID or -1)
+							pendingAsyncLoads = pendingAsyncLoads - 1
 						end
-					end)
+					else
+						-- Too many pending, requeue for later
+						table.insert(itemReconstructQueue, item)
+					end
 				end
 			end
 		end
 	end
 
-	-- If some links loaded immediately from cache, refresh UI now
-	if not needsAsyncLoad and GBankClassic_UI_Inventory and GBankClassic_UI_Inventory.isOpen then
-		GBankClassic_UI_Inventory:DrawContent()
+	-- Refresh UI if any items loaded synchronously in this batch
+	if loadedAnyInBatch then
+		throttledUIRefresh()
+	end
+
+	-- Schedule next batch
+	if #itemReconstructQueue > 0 then
+		After(BATCH_DELAY, processItemQueue)
+	else
+		isProcessingQueue = false
+	end
+end
+
+-- Reconstruct single item link (immediate, synchronous only)
+function Guild:ReconstructItemLink(item)
+	if not item or not item.ID or item.Link then
+		return
+	end
+
+	-- Try synchronous reconstruction from cache only
+	if item.ItemString then
+		local itemName = GetItemInfo(item.ID)
+		if itemName then
+			item.Link = string.format("|cffffffff|Hitem:%s|h[%s]|h|r", item.ItemString, itemName)
+		end
+	else
+		local itemLink = select(2, GetItemInfo(item.ID))
+		if itemLink then
+			item.Link = itemLink
+		end
+	end
+end
+
+-- Reconstruct link fields after receiving data
+-- Calls GetItemInfo() to recreate links from ItemID
+-- Queued/batched to prevent stuttering
+function Guild:ReconstructItemLinks(items)
+	if not items then
+		return
+	end
+
+	-- Add all items without links to queue for async loading
+	-- Items already in cache will load synchronously and won't need async
+	for _, item in ipairs(items) do
+		if item and item.ID and not item.Link then
+			table.insert(itemReconstructQueue, item)
+		end
+	end
+
+	-- Start processing queue if not already running
+	if not isProcessingQueue and #itemReconstructQueue > 0 then
+		isProcessingQueue = true
+		processItemQueue()
 	end
 end
 
 -- Strip links from entire alt structure before transmission
-function GBankClassic_Guild:StripAltLinks(alt)
+function Guild:StripAltLinks(alt)
 	if not alt then
 		return nil
 	end
 
+	-- Strip links from aggregate items
+	local strippedItems = self:StripItemLinks(alt.items)
+
+	-- Also strip links from legacy bank/bags fields for backward compatibility
+	-- Old clients can reconstruct links, new clients use alt.items
+	local strippedBank = nil
+	if alt.bank then
+		strippedBank = {
+			slots = alt.bank.slots,
+			items = self:StripItemLinks(alt.bank.items)
+		}
+	end
+
+	local strippedBags = nil
+	if alt.bags then
+		strippedBags = {
+			slots = alt.bags.slots,
+			items = self:StripItemLinks(alt.bags.items)
+		}
+	end
+
 	local stripped = {
 		version = alt.version,
 		money = alt.money,
-		bank = {
-			items = self:StripItemLinks(alt.bank and alt.bank.items),
-			numSlots = alt.bank and alt.bank.numSlots,
-			slotsFilled = alt.bank and alt.bank.slotsFilled
-		},
-		bags = {
-			items = self:StripItemLinks(alt.bags and alt.bags.items),
-			numSlots = alt.bags and alt.bags.numSlots,
-			slotsFilled = alt.bags and alt.bags.slotsFilled
-		}
+		inventoryHash = alt.inventoryHash,
+		items = strippedItems,
+		bank = strippedBank,
+		bags = strippedBags,
+		mail = alt.mail
 	}
+
 	return stripped
 end
 
 -- Strip links from delta changes structure (bandwidth optimization)
-function GBankClassic_Guild:StripDeltaLinks(delta)
+function Guild:StripDeltaLinks(delta)
 	return GBankClassic_DeltaComms:StripDeltaLinks(delta)
 end
 
-function GBankClassic_Guild:SendAltData(name, target)
+-- Ensure legacy fields (bank.items, bags.items) exist for backward compatibility with old clients
+-- New clients use alt.items, but old clients need bank.items and bags.items
+-- This also ensures mail items are included in legacy fields for old clients
+function Guild:EnsureLegacyFields(alt)
+	if not alt or not alt.items then
+		return alt
+	end
+
+	-- If no legacy fields exist, reconstruct from alt.items
+	if not alt.bank or not alt.bank.items then
+		GBankClassic_Output:Debug("SYNC", "Reconstructing legacy fields from alt.items for %s", alt.name or "unknown")
+
+		if not alt.bank then
+			alt.bank = {}
+		end
+		alt.bank.items = {}
+		-- Copy all items from alt.items to bank.items (includes mail)
+		for _, item in ipairs(alt.items) do
+			table.insert(alt.bank.items, item)
+		end
+
+		if not alt.bags then
+			alt.bags = {}
+		end
+		if not alt.bags.items then
+			alt.bags.items = {}
+		end
+
+		return alt
+	end
+
+	-- Legacy fields exist, but they don't include mail
+	-- DO not modify alt.bank.items directly - it corrupts the data!
+	-- Old clients will see mail items via alt.mail field, or can aggregate themselves
+	-- If needed, create temporary copies with mail included only for transmission
+
+	-- Ensure bags.items exists (even if empty)
+	if not alt.bags then
+		alt.bags = {}
+	end
+	if not alt.bags.items then
+		alt.bags.items = {}
+	end
+
+	return alt
+end
+
+function Guild:SendAltData(name, target)
 	if not name then
 		return
 	end
@@ -1099,53 +1180,56 @@ function GBankClassic_Guild:SendAltData(name, target)
 	local channel = target and "WHISPER" or "GUILD"
     local dest = target
 
-	-- Version is ONLY set by Bank:Scan() when inventory actually changes
+	-- Version is only set by Bank:Scan() when inventory actually changes
 	-- No longer bump version here - that caused version drift from communication
 
 	local currentAlt = self.Info.alts[norm]
+
+	-- Ensure legacy fields exist for backward compatibility with old clients
+	-- This ensures old clients that only read bank.items/bags.items still get data
+	self:EnsureLegacyFields(currentAlt) -- Modifies in place, no need to reassign
+
+	-- Log what we're about to send (all 3 arrays for backward compatibility)
+	local itemsCount = currentAlt.items and #currentAlt.items or 0
+	local bankCount = (currentAlt.bank and currentAlt.bank.items) and #currentAlt.bank.items or 0
+	local bagsCount = (currentAlt.bags and currentAlt.bags.items) and #currentAlt.bags.items or 0
+	GBankClassic_Output:Debug("SYNC", "Sending %s: alt.items=%d, alt.bank.items=%d (includes mail), alt.bags.items=%d", norm, itemsCount, bankCount, bagsCount)
+
+	-- Log sample counts from what we're about to send
+	if currentAlt.items and #currentAlt.items > 0 then
+		local sampleItems = {}
+		for i = 1, math.min(5, #currentAlt.items) do
+			local item = currentAlt.items[i]
+			if item then
+				table.insert(sampleItems, string.format("%s:%d", item.ID or "?", item.Count or 0))
+			end
+		end
+		GBankClassic_Output:Debug("SYNC", "First 5 items in alt.items being sent: %s", table.concat(sampleItems, ", "))
+	end
+
 	local useDelta = false
 	local deltaData = nil
 	local computeStart = debugprofilestop()
 
 	-- Check if delta sync should be used
 	-- No longer skip delta based on force flag (removed)
-	if self:ShouldUseDelta() then
-		deltaData = self:ComputeDelta(norm, currentAlt)
-		if deltaData and self:DeltaHasChanges(deltaData) then
-			local deltaSize = self:EstimateSize(deltaData)
-			local fullSize = self:EstimateSize({ type = "alt", name = norm, alt = currentAlt })
-
-			-- Use delta if significantly smaller OR if forced
-			local forceDelta = FEATURES and FEATURES.FORCE_DELTA_SYNC
-			if forceDelta or deltaSize < fullSize * PROTOCOL.MIN_DELTA_SIZE_RATIO then
-				useDelta = true
-				GBankClassic_Output:Debug(
-					"DELTA",
-					" Delta selected for %s: %d bytes vs %d bytes full (%.1f%% size, %.0f bytes saved)%s",
-					norm,
-					deltaSize,
-					fullSize,
-					(deltaSize / fullSize) * 100,
-					fullSize - deltaSize,
-					forceDelta and " [FORCED]" or ""
-				)
-			else
-				GBankClassic_Output:Debug(
-					"DELTA",
-					" Delta too large for %s: %d bytes vs %d bytes full (%.1f%% > %.0f%% threshold)",
-					norm,
-					deltaSize,
-					fullSize,
-					(deltaSize / fullSize) * 100,
-					PROTOCOL.MIN_DELTA_SIZE_RATIO * 100
-				)
-			end
+	deltaData = self:ComputeDelta(norm, currentAlt)
+	if deltaData and self:DeltaHasChanges(deltaData) then
+		local deltaSize = self:EstimateSize(deltaData)
+		local fullSize = self:EstimateSize({ type = "alt", name = norm, alt = currentAlt })
+
+		-- Always use delta if smaller
+		if deltaSize < fullSize then
+			useDelta = true
+			GBankClassic_Output:Debug("DELTA", " Delta selected for %s: %d bytes vs %d bytes full (%.1f%% size, %.0f bytes saved)", norm, deltaSize, fullSize, (deltaSize / fullSize) * 100, fullSize - deltaSize)
 		else
-			if deltaData then
-				GBankClassic_Output:Debug("DELTA", "No changes detected for %s (delta would be empty)", norm)
-			else
-				GBankClassic_Output:Debug("DELTA", "No previous snapshot for %s (first sync)", norm)
-			end
+			GBankClassic_Output:Debug("DELTA", " Delta larger than full for %s: %d bytes vs %d bytes full (%.1f%%), using full sync", norm, deltaSize, fullSize, (deltaSize / fullSize) * 100)
+		end
+	else
+		if deltaData then
+			GBankClassic_Output:Debug("DELTA", "No changes detected for %s (delta would be empty)", norm)
+		else
+			GBankClassic_Output:Debug("DELTA", "No previous snapshot for %s (first sync)", norm)
 		end
 	end
 
@@ -1171,26 +1255,19 @@ function GBankClassic_Guild:SendAltData(name, target)
 		GBankClassic_Output:Debug("DELTA", "Sent delta update for %s via gbank-dd (no links)", norm)
 
 		-- Track metrics using the size of the format we're using
-		local serialized = deltaNoLinks
-		GBankClassic_Output:Debug("DELTA", "Final delta size: %d bytes", string.len(serialized or ""))
+		local totalSize = (deltaNoLinks and string.len(deltaNoLinks) or 0)
+		GBankClassic_Output:Debug("DELTA", "Final delta size: %d bytes total", totalSize)
 
 		-- Track metrics
 		if self.Info and self.Info.name then
-			GBankClassic_Database:RecordDeltaSent(self.Info.name, string.len(serialized or ""))
+			GBankClassic_Database:RecordDeltaSent(self.Info.name, totalSize)
 		end
 
 		-- Save delta to history for potential chain replay
-		-- Use previous.version for baseVersion in history (delta no longer includes it)
 		if self.Info and self.Info.name and deltaData.version and deltaData.changes then
 			local previous = GBankClassic_Database:GetSnapshot(self.Info.name, norm)
-			local baseVer = previous and previous.version or 0
-			GBankClassic_Database:SaveDeltaHistory(
-				self.Info.name,
-				norm,
-				baseVer,
-				deltaData.version,
-				deltaData
-			)
+			local previousVersion = previous and previous.version or 0
+			GBankClassic_Database:SaveDeltaHistory(self.Info.name, norm, previousVersion, deltaData.version, deltaData)
 		end
 
 		-- Save snapshot for next delta
@@ -1207,17 +1284,10 @@ function GBankClassic_Guild:SendAltData(name, target)
 
 			-- Save delta to history even when falling back to full sync
 			-- This allows chain replay to work for offline players even when deltas were too large
-			-- Use previous.version for baseVersion in history (delta no longer includes it)
 			if self.Info and self.Info.name and deltaData.version and deltaData.changes then
 				local previous = GBankClassic_Database:GetSnapshot(self.Info.name, norm)
-				local baseVer = previous and previous.version or 0
-				GBankClassic_Database:SaveDeltaHistory(
-					self.Info.name,
-					norm,
-					baseVer,
-					deltaData.version,
-					deltaData
-				)
+				local previousVersion = previous and previous.version or 0
+				GBankClassic_Database:SaveDeltaHistory(self.Info.name, norm, previousVersion, deltaData.version, deltaData)
 			end
 		end
 
@@ -1227,7 +1297,7 @@ function GBankClassic_Guild:SendAltData(name, target)
 		-- New format (without links)
 		local strippedAlt = self:StripAltLinks(currentAlt)
 		dataNoLinks = GBankClassic_Core:SerializeWithChecksum({ type = "alt", name = norm, alt = strippedAlt })
-		GBankClassic_Output:DebugComm("SENDING RESPONSE: gbank-d for %s (%d bytes)", norm, #dataNoLinks)
+		GBankClassic_Output:DebugComm("Sending response: gbank-d for %s (%d bytes)", norm, #dataNoLinks)
 		if channel == "WHISPER" and dest then
 			GBankClassic_Core:SendWhisper("gbank-d", dataNoLinks, dest, "NORMAL", OnChunkSent)
 		else
@@ -1235,12 +1305,7 @@ function GBankClassic_Guild:SendAltData(name, target)
 		end
 
 		-- Log what was sent
-		GBankClassic_Output:Debug(
-			"SYNC",
-			"Sent full sync for %s: gbank-d (%d bytes without links)",
-			norm,
-			string.len(dataNoLinks or "")
-		)
+		GBankClassic_Output:Debug("SYNC", "Sent full sync for %s: gbank-d (%d bytes without links)", norm, string.len(dataNoLinks or ""))
 
 		-- Track metrics
 		if self.Info and self.Info.name then
@@ -1273,7 +1338,7 @@ local SEND_RESULT = {
 	GeneralError = 9,
 }
 
-local function GetSendResultName(result)
+local function getSendResultName(result)
 	if result == SEND_RESULT.Success or result == true then
         return "Success"
 	elseif result == SEND_RESULT.AddonMessageThrottle then
@@ -1332,7 +1397,7 @@ function OnChunkSent(arg, bytesSent, totalBytes, sendResult)
 
 	-- Print error on failed send
 	if not isSuccess then
-		local resultStr = GetSendResultName(sendResult)
+		local resultStr = getSendResultName(sendResult)
 		GBankClassic_Output:Debug("CHUNK","chunk %d/%d failed: %s", SendStats.chunksSent, totalChunks, resultStr, "Aborting send due to failure")
 		SendStats.abort = true
 
@@ -1341,25 +1406,18 @@ function OnChunkSent(arg, bytesSent, totalBytes, sendResult)
 
 	-- Show progress at start
 	if SendStats.chunksSent == 1 then
-		if not GBankClassic_Options:IsSyncProgressMuted() then
-			GBankClassic_Output:Debug("CHUNK", "Sharing guild bank data: %d bytes in ~%d chunks...", totalBytes, totalChunks)
-		end
+		GBankClassic_Output:Debug("CHUNK", "Sharing guild bank data: %d bytes in ~%d chunks...", totalBytes, totalChunks)
 	end
 
 	-- Completion summary
 	if bytesSent >= totalBytes then
 		local elapsed = GetTime() - (SendStats.startTime or GetTime())
-		local summary = string.format(
-			"Send complete: %d chunks, %d bytes in %.1fs",
-			SendStats.chunksSent, totalBytes, elapsed
-		)
+		local summary = string.format("Send complete: %d chunks, %d bytes in %.1fs", SendStats.chunksSent, totalBytes, elapsed)
 		if SendStats.failures > 0 or SendStats.throttled > 0 then
 			summary = summary .. string.format(" | failures: %d, throttled: %d", SendStats.failures, SendStats.throttled)
 		end
 
-		if not GBankClassic_Options:IsSyncProgressMuted() then
-			GBankClassic_Output:Debug("CHUNK", summary)
-		end
+		GBankClassic_Output:Debug("CHUNK", summary)
 
 		-- Warn on failures
 		if SendStats.failures > 0 then
@@ -1376,196 +1434,366 @@ function OnChunkSent(arg, bytesSent, totalBytes, sendResult)
 	end
 end
 
-function GBankClassic_Guild:ReceiveAltData(name, alt)
-	return GBankClassic_Performance:Track("ReceiveAltData", function()
-		if not self.Info then
-			return ADOPTION_STATUS.IGNORED
+function Guild:ReceiveAltData(name, alt, sender)
+	if not self.Info then
+		return ADOPTION_STATUS.IGNORED
+	end
+
+	-- Sanitize incoming alt data
+	local function sanitizeAlt(a)
+		if not a or type(a) ~= "table" then
+			return nil
 		end
 
-		-- Sanitize incoming alt data
-		local function sanitizeAlt(a)
-			if not a or _G.type(a) ~= "table" then
-				return nil
-			end
-			if a.bank and _G.type(a.bank) == "table" and a.bank.items then
-				for k, v in pairs(a.bank.items) do
-					if not v or _G.type(v) ~= "table" or not v.ID then
-						a.bank.items[k] = nil
-					end
+		-- Sanitize alt.items (array)
+		if a.items then
+			local cleaned = {}
+			for k, v in pairs(a.items) do
+				if v and type(v) == "table" and v.ID then
+					table.insert(cleaned, v)
 				end
 			end
-			if a.bags and _G.type(a.bags) == "table" and a.bags.items then
-				for k, v in pairs(a.bags.items) do
-					if not v or _G.type(v) ~= "table" or not v.ID then
-						a.bags.items[k] = nil
-					end
+			a.items = cleaned
+		end
+
+		-- Sanitize bank items (array) - compact after removing invalids
+		if a.bank and type(a.bank) == "table" and a.bank.items then
+			local cleaned = {}
+			for k, v in pairs(a.bank.items) do
+				if v and type(v) == "table" and v.ID then
+					table.insert(cleaned, v)
 				end
 			end
-			return a
+			a.bank.items = cleaned
 		end
 
-		alt = sanitizeAlt(alt)
-		if not alt then
-			return ADOPTION_STATUS.INVALID
+		-- Sanitize bag items (array) - compact after removing invalids
+		if a.bags and type(a.bags) == "table" and a.bags.items then
+			local cleaned = {}
+			local beforeCount = 0
+			local validCount = 0
+			local invalidCount = 0
+			for k, v in pairs(a.bags.items) do
+				beforeCount = beforeCount + 1
+				if v and type(v) == "table" and v.ID then
+					table.insert(cleaned, v)
+					validCount = validCount + 1
+				else
+					invalidCount = invalidCount + 1
+					GBankClassic_Output:Debug("SYNC", "  Sanitize: invalid bag item at [%s]: v=%s, type=%s, ID=%s", tostring(k), tostring(v), type(v), v and tostring(v.ID) or "nil")
+				end
+			end
+			GBankClassic_Output:Debug("SYNC", "Sanitized bags: before=%d, valid=%d, invalid=%d", beforeCount, validCount, invalidCount)
+			a.bags.items = cleaned
 		end
 
-		local norm = self:NormalizeName(name)
-		local existing = self.Info.alts[norm]
-		if existing and alt.version ~= nil and existing.version ~= nil and alt.version < existing.version then
-			return ADOPTION_STATUS.STALE
+		return a
+	end
+
+	alt = sanitizeAlt(alt)
+	if not alt then
+		return ADOPTION_STATUS.INVALID
+	end
+
+	-- Log what we received
+	GBankClassic_Output:Debug("SYNC", "ReceiveAltData for %s: alt.items=%d, alt.bank.items=%d, alt.bags.items=%d", name, GBankClassic_Globals:Count(alt.items), (alt.bank and alt.bank.items) and GBankClassic_Globals:Count(alt.bank.items) or 0, (alt.bags and alt.bags.items) and GBankClassic_Globals:Count(alt.bags.items) or 0)
+
+	-- Backward compatibility: Compute alt.items from sources if missing
+	-- This handles data from players who haven't rescanned after the aggregation update
+	-- Previously, only bank and bags were synced (mail was local-only)
+
+	-- Check if alt.items has any content (handles both array and key-value formats)
+	local function hasAnyItems(items)
+		if not items or type(items) ~= "table" then
+			return false
 		end
 
-		-- Accept incoming if newer version
-		-- If same version, accept the alt with more items
-		local function itemCount(a)
-			local c = 0
-			if a and a.bank and a.bank.items then
-				for _, v in pairs(a.bank.items) do
-					if v and v.ID then
-						c = c + 1
-					end
-				end
+		return next(items) ~= nil
+	end
+
+	local needsReconstruction = not hasAnyItems(alt.items)
+
+	if needsReconstruction then
+		local bankItems = (alt.bank and alt.bank.items) or {}
+		local bagItems = (alt.bags and alt.bags.items) or {}
+
+		GBankClassic_Output:Debug("SYNC", "Reconstructing alt.items for %s: bank=%d, bags=%d", name, #bankItems, #bagItems)
+
+		-- Aggregate bank + bags only (mail was never synced in old system)
+		if #bankItems > 0 or #bagItems > 0 then
+			local aggregated = GBankClassic_Item:Aggregate(bankItems, bagItems)
+			alt.items = {}
+			for _, item in pairs(aggregated) do
+				table.insert(alt.items, item)
 			end
-			if a and a.bags and a.bags.items then
-				for _, v in pairs(a.bags.items) do
-					if v and v.ID then
-						c = c + 1
-					end
+			GBankClassic_Output:Debug("SYNC", "Reconstructed alt.items for %s: %d items from bank+bags", name, #alt.items)
+		else
+			GBankClassic_Output:Debug("SYNC", "No items to reconstruct for %s (bank and bags both empty)", name)
+		end
+	else
+		-- alt.items exists, deduplicate and ensure array format
+		-- Items may have duplicates from corrupted syncs, so aggregate to dedupe
+		-- Log sample counts before deduplication
+		if alt.items and #alt.items > 0 then
+			local beforeSample = {}
+			for i = 1, math.min(5, #alt.items) do
+				local item = alt.items[i]
+				if item then
+					table.insert(beforeSample, string.format("%s:%d", item.ID or "?", item.Count or 0))
 				end
 			end
-			return c
+			GBankClassic_Output:Debug("SYNC", "Before dedupe - First 5 items received: %s", table.concat(beforeSample, ", "))
 		end
 
-		if existing and existing.version and alt.version and alt.version < existing.version then
-			-- Incoming is older; ignore
-			return ADOPTION_STATUS.STALE
-		elseif existing and existing.version and alt.version and alt.version == existing.version then
-			-- Tie-breaker: choose the one with more items
-			if itemCount(alt) <= itemCount(existing) then
-				return ADOPTION_STATUS.STALE
+		-- Check if we need to merge mail items into alt.items
+		-- Only merge if this is old data (no mailHash = created before mail sync existed)
+		-- If mailHash exists, alt.items already includes mail from sender's Bank:Scan()
+		local hasMailHash = alt.mailHash ~= nil
+		local mailItems = (alt.mail and alt.mail.items) or {}
+		local hasMailItems = mailItems and #mailItems > 0
+		local needsMailMerge = hasMailItems and not hasMailHash
+
+		if needsMailMerge then
+			GBankClassic_Output:Debug("SYNC", "Old data: Merging %d mail items into alt.items for %s (no mailHash)", #mailItems, name)
+			-- Aggregate alt.items with mail to ensure mail is included
+			local aggregated = GBankClassic_Item:Aggregate(alt.items, mailItems)
+			local arrayItems = {}
+			for _, item in pairs(aggregated) do
+				table.insert(arrayItems, item)
+			end
+			alt.items = arrayItems
+			GBankClassic_Output:Debug("SYNC", "Merged alt.items for %s: %d items (including mail)", name, #alt.items)
+		else
+			if hasMailHash then
+				GBankClassic_Output:Debug("SYNC", "New data: alt.items already includes mail (mailHash present) for %s", name)
 			end
+			-- No mail merge needed, just deduplicate
+			local aggregated = GBankClassic_Item:Aggregate(alt.items, nil)
+			local arrayItems = {}
+			for _, item in pairs(aggregated) do
+				table.insert(arrayItems, item)
+			end
+			alt.items = arrayItems
+			GBankClassic_Output:Debug("SYNC", "alt.items exists for %s, deduplicated and converted to array: %d items", name, #alt.items)
 		end
 
-		-- Check against existing alt data, but only if version exists
-		if self.Info.alts[name] and alt.version ~= nil and self.Info.alts[name].version ~= nil and alt.version < self.Info.alts[name].version then
-			return ADOPTION_STATUS.STALE
-		end
-		if self.hasRequested then
-			if self.requestCount == nil then
-				self.requestCount = 0
-			else
-				self.requestCount = self.requestCount - 1
-			end
-			if self.requestCount == 0 then
-				self.hasRequested = false
-				GBankClassic_Output:Info("Sync completed.")
+		-- Log sample counts after deduplication
+		if alt.items and #alt.items > 0 then
+			local afterSample = {}
+			for i = 1, math.min(5, #alt.items) do
+				local item = alt.items[i]
+				if item then
+					table.insert(afterSample, string.format("%s:%d", item.ID or "?", item.Count or 0))
+				end
 			end
+			GBankClassic_Output:Debug("SYNC", "After dedupe - First 5 items stored: %s", table.concat(afterSample, ", "))
 		end
+	end
+
+	local norm = self:NormalizeName(name) or ""
+	local existing = self.Info.alts[norm]
+	local senderNorm = sender and self:NormalizeName(sender) or nil
 
-		if not self.Info.alts then
-			self.Info.alts = {}
+	-- Guild bank alt protection logic
+	-- Rule 1: Never accept data about yourself (you are source of truth)
+	-- Rule 2: Guild bank alts only accept data about other guild bank alts from that guild bank alt
+	-- Rule 3: Non-guild bank alts accept data from anyone
+	local player = UnitName("player") .. "-" .. GetNormalizedRealmName()
+	local playerNorm = self:NormalizeName(player)
+	local isOwnData = playerNorm == norm
+	local targetIsGuildBankAlt = self:IsBank(norm)
+	local receiverIsGuildBankAlt = self:IsBank(playerNorm)
+
+	-- Rule 1: Reject data about ourselves (we already have our own current data)
+	if isOwnData then
+		GBankClassic_Output:Debug("SYNC", "Rejected alt data about ourselves (we are the source of truth)")
+		
+		return ADOPTION_STATUS.UNAUTHORIZED
+	end
+
+	-- Rule 2: Guild bank alt protection - only apply if WE are a guild bank alt protecting our data
+	-- Regular users should accept guild bank alt data from anyone
+	if receiverIsGuildBankAlt and targetIsGuildBankAlt then
+		-- We are a guild bank alt, and data is about a guild bank alt - only accept if sender is that guild bank alt
+		if senderNorm ~= norm then
+			GBankClassic_Output:Debug("SYNC", "Rejected data about guild bank alt %s from %s (guild bank alts only update themselves)", norm, senderNorm or "unknown")
+
+			return ADOPTION_STATUS.UNAUTHORIZED
 		end
-		self.Info.alts[norm] = alt
+		-- If we get here: senderNorm == norm (guild bank alt updating themselves) - ACCEPT
+		GBankClassic_Output:Debug("SYNC", "Accepting data about guild bank alt %s from themselves", norm)
+	end
+
+	-- Rule 3: Non-guild bank alts accept all data, non-guild bank alt data accepted from anyone
+	-- Version checking for all alts
+	if existing and alt.version ~= nil and existing.version ~= nil and alt.version < existing.version then
+		return ADOPTION_STATUS.STALE
+	end
+
+	-- Accept incoming if newer version
+	-- If same version, accept the alt with more items
+	local function itemCount(a)
+		local c = 0
+			if a and a.items then
+				for _, v in pairs(a.items) do
+				if v and v.ID then
+					c = c + 1
+				end
+			end
+		end
+		
+		return c
+	end
+
+	if existing and existing.version and alt.version and alt.version < existing.version then
+		-- Incoming is older; ignore
+		return ADOPTION_STATUS.STALE
+	elseif existing and existing.version and alt.version and alt.version == existing.version then
+		-- Tie-breaker: always accept
+		-- -- Tie-breaker: choose the one with more items
+		-- if itemCount(alt) <= itemCount(existing) then
+		-- 	return ADOPTION_STATUS.STALE
+		-- end
+	end
 
-		-- Reconstruct links for items (bandwidth optimization)
-		if alt.bank and alt.bank.items then
-			self:ReconstructItemLinks(alt.bank.items)
+	-- Check against existing alt data, but only if version exists
+	if self.Info.alts[name] and alt.version ~= nil and self.Info.alts[name].version ~= nil and alt.version < self.Info.alts[name].version then
+		return ADOPTION_STATUS.STALE
+	end
+	
+	if self.hasRequested then
+		if self.requestCount == nil then
+			self.requestCount = 0
+		else
+			self.requestCount = self.requestCount - 1
 		end
-		if alt.bags and alt.bags.items then
-			self:ReconstructItemLinks(alt.bags.items)
+		if self.requestCount == 0 then
+			self.hasRequested = false
+			GBankClassic_Output:Info("Sync completed.")
 		end
+	end
 
-		-- Reset error count on successful full sync
-		self:ResetDeltaErrorCount(norm)
+	if not self.Info.alts then
+		self.Info.alts = {}
+	end
 
-		return ADOPTION_STATUS.ADOPTED
-	end)
-end
+	-- Preserve mail field from existing data when incoming sync lacks it
+	-- Mail is now synced, but old clients don't include it in their syncs
+	-- Preserve locally-scanned mail data to maintain visibility for new clients
+	local existingMail = existing and existing.mail or nil
+	local incomingHasMail = alt.mail ~= nil
 
--- Protocol version helper functions
+	GBankClassic_Output:Debug("MAIL", "AdoptAltData for %s: existingMail=%s, incomingHasMail=%s", norm, existingMail and "YES" or "NO", tostring(incomingHasMail))
+	if existingMail then
+		GBankClassic_Output:Debug("MAIL", "  existingMail has %d items", existingMail.items and #existingMail.items or 0)
+	end
+	self.Info.alts[norm] = alt
+	GBankClassic_Output:Debug("MAIL", "Overwrote self.Info.alts[%s], mail field now: %s", norm, alt.mail and "EXISTS" or "GONE")
+
+	-- Restore preserved mail if we had it locally and incoming sync doesn't have it
+	-- This handles backward compatibility: new clients preserve mail when receiving from old clients
+	if existingMail and not incomingHasMail then
+		self.Info.alts[norm].mail = existingMail
+		local mailItemCount = existingMail.items and #existingMail.items or 0
+		GBankClassic_Output:Debug("MAIL", "Restored mail for %s (%d items) - incoming sync lacked mail", norm, mailItemCount)
+		GBankClassic_Output:Debug("MAIL", "Preserved mail data for %s (%d items, lastScan=%s) - backward compat", norm, mailItemCount, tostring(existingMail.lastScan))
 
--- Check if delta sync should be used
-function GBankClassic_Guild:ShouldUseDelta()
-	return GBankClassic_DeltaComms:ShouldUseDelta()
+		-- Re-aggregate alt.items to include the restored mail
+		-- The incoming alt.items doesn't have mail, so we need to merge it back in
+		if existingMail.items and #existingMail.items > 0 then
+			GBankClassic_Output:Debug("MAIL", "Merging %d restored mail items into alt.items for %s", #existingMail.items, norm)
+			local aggregated = GBankClassic_Item:Aggregate(self.Info.alts[norm].items, existingMail.items)
+			self.Info.alts[norm].items = {}
+			for _, item in pairs(aggregated) do
+				table.insert(self.Info.alts[norm].items, item)
+			end
+			GBankClassic_Output:Debug("MAIL", "Re-aggregated alt.items for %s: %d items (including restored mail)", norm, #self.Info.alts[norm].items)
+		end
+	elseif incomingHasMail then
+		GBankClassic_Output:Debug("MAIL", "Using incoming mail data for %s (new client sync)", norm)
+	end
+
+	-- Reset search data flag so inventory UI rebuilds search index (UI-008 fix)
+	if GBankClassic_UI_Inventory then
+		GBankClassic_UI_Inventory.searchDataBuilt = false
+	end
+
+	-- Reconstruct links for items (bandwidth optimization)
+	if alt.items then
+		self:ReconstructItemLinks(alt.bags.items)
+	end
+
+	-- Reset error count on successful full sync
+	self:ResetDeltaErrorCount(norm)
+
+	return ADOPTION_STATUS.ADOPTED
 end
 
+-- Protocol version helper functions
+
 -- Get peer protocol capabilities
-function GBankClassic_Guild:GetPeerCapabilities(sender)
+function Guild:GetPeerCapabilities(sender)
 	return GBankClassic_DeltaComms:GetPeerCapabilities(self.Info and self.Info.name, sender)
 end
 
 -- Compare two items for equality
-function GBankClassic_Guild:ItemsEqual(item1, item2)
+function Guild:ItemsEqual(item1, item2)
 	return GBankClassic_DeltaComms:ItemsEqual(item1, item2)
 end
 
 -- Extract only the fields that changed between two items
-function GBankClassic_Guild:GetChangedFields(oldItem, newItem)
+function Guild:GetChangedFields(oldItem, newItem)
 	return GBankClassic_DeltaComms:GetChangedFields(oldItem, newItem)
 end
 
 -- Build a slot-indexed lookup table from items array
-function GBankClassic_Guild:BuildItemIndex(items)
+function Guild:BuildItemIndex(items)
 	return GBankClassic_DeltaComms:BuildItemIndex(items)
 end
 
 -- Compute delta between old and new item sets
-function GBankClassic_Guild:ComputeItemDelta(oldItems, newItems)
+function Guild:ComputeItemDelta(oldItems, newItems)
 	return GBankClassic_DeltaComms:ComputeItemDelta(oldItems, newItems)
 end
 
 -- Compute full delta for an alt
-function GBankClassic_Guild:ComputeDelta(name, currentAlt)
+function Guild:ComputeDelta(name, currentAlt)
 	return GBankClassic_DeltaComms:ComputeDelta(self.Info and self.Info.name, name, currentAlt)
 end
 
 -- Estimate serialized size of a data structure
-function GBankClassic_Guild:EstimateSize(data)
+function Guild:EstimateSize(data)
 	return GBankClassic_DeltaComms:EstimateSize(data)
 end
 
 -- Check if delta has any actual changes
-function GBankClassic_Guild:DeltaHasChanges(delta)
+function Guild:DeltaHasChanges(delta)
 	return GBankClassic_DeltaComms:DeltaHasChanges(delta)
 end
 
 -- Apply item delta to an items table
-function GBankClassic_Guild:ApplyItemDelta(items, delta)
+function Guild:ApplyItemDelta(items, delta)
 	return GBankClassic_DeltaComms:ApplyItemDelta(items, delta)
 end
 
 -- Apply a delta to alt data
-function GBankClassic_Guild:ApplyDelta(name, deltaData, sender)
+function Guild:ApplyDelta(name, deltaData, sender)
 	return GBankClassic_DeltaComms:ApplyDelta(self.Info, name, deltaData, sender)
 end
 
--- Request a chain of deltas to catch up from an old version
-function GBankClassic_Guild:RequestDeltaChain(altName, fromVersion, toVersion, sender)
-	return GBankClassic_DeltaComms:RequestDeltaChain(self.Info and self.Info.name, altName, fromVersion, toVersion, sender)
-end
-
 -- Apply a chain of deltas sequentially
-function GBankClassic_Guild:ApplyDeltaChain(altName, deltaChain)
+function Guild:ApplyDeltaChain(altName, deltaChain)
 	return GBankClassic_DeltaComms:ApplyDeltaChain(self.Info, altName, deltaChain)
 end
 
-local function GetTableEntriesCount(a)
-    local b = 0
-    for c, d in pairs(a) do 
-        b = b + 1 
-    end
-
-    return b 
-end 
-
-function GBankClassic_Guild:Hello(type)
-	local addon_data = GBankClassic_Guild:GetVersion()
-	local current_data = GBankClassic_Guild.Info
+function Guild:Hello(type)
+	local addon_data = self:GetVersion()
+	local current_data = Guild.Info
 	if addon_data and current_data then
 		local roster_alts = ""
 		local guild_bank_alts = ""
-		local hello = "Hi! " .. GBankClassic_Guild:GetPlayer() .. " is using version " .. addon_data.addon .. "."
-		if GetTableEntriesCount(current_data.roster) > 0 and GetTableEntriesCount(current_data.alts) > 0 then
+		local hello = "Hi! " .. self:GetPlayer() .. " is using version " .. addon_data.addon .. "."
+		if GBankClassic_Globals:Count(current_data.roster) > 0 and GBankClassic_Globals:Count(current_data.alts) > 0 then
 			for _, v in pairs(current_data.roster.alts) do
 				if roster_alts ~= "" then
 					roster_alts = roster_alts .. ", "
@@ -1595,7 +1823,7 @@ function GBankClassic_Guild:Hello(type)
 				hello = hello .. "\n"
 				hello = hello
 					.. "I have guild bank data from "
-					.. GetTableEntriesCount(current_data.alts)
+					.. GBankClassic_Globals:Count(current_data.alts)
 					.. " alts"
 					.. guild_bank_alts
 					.. "."
@@ -1604,6 +1832,42 @@ function GBankClassic_Guild:Hello(type)
 			hello = hello .. " I know about 0 guild bank alts on the roster, and have guild bank data from 0 alts."
 		end
 
+		-- local pending_count = 0
+		-- local fulfilled_count = 0
+		-- local pending_banks = {}
+		-- for _, req in pairs(current_data.requests or {}) do
+		-- 	local clean = self:SanitizeRequest(req)
+		-- 	if clean and clean.item and clean.item ~= "" then
+		-- 		local qty = tonumber(clean.quantity or 0) or 0
+		-- 		local fulfilled = tonumber(clean.fulfilled or 0) or 0
+		-- 		if qty > 0 then
+		-- 			local is_fulfilled = clean.status == "fulfilled" or clean.status == "complete" or fulfilled >= qty
+		-- 			local is_pending = clean.status == "open" and fulfilled < qty
+		-- 			if is_fulfilled then
+		-- 				fulfilled_count = fulfilled_count + 1
+		-- 			elseif is_pending then
+		-- 				pending_count = pending_count + 1
+		-- 				if clean.bank and clean.bank ~= "" then
+		-- 					pending_banks[clean.bank] = true
+		-- 				end
+		-- 			end
+		-- 		end
+		-- 	end
+		-- end
+
+		-- local pending_bank_list = {}
+		-- for name in pairs(pending_banks) do
+		-- 	table.insert(pending_bank_list, name)
+		-- end
+		-- table.sort(pending_bank_list)
+
+		-- hello = hello .. "\n" .. string.format("I have %d pending item requests and %d fulfilled item requests.", pending_count, fulfilled_count)
+		-- if #pending_bank_list > 0 then
+		-- 	hello = hello .. "\n" .. "Pending requests for bank alts: " .. table.concat(pending_bank_list, ", ") .. "."
+		-- else
+		-- 	hello = hello .. "\n" .. "Pending requests for bank alts: none."
+		-- end
+
 		if type ~= "reply" then
 			GBankClassic_Output:Info(hello)
 		end
@@ -1616,15 +1880,14 @@ function GBankClassic_Guild:Hello(type)
 	end
 end
 
-function GBankClassic_Guild:Wipe(type)
-    local guild = GBankClassic_Guild:GetGuild()
-    local CanViewOfficerNote = CanViewOfficerNote or C_GuildInfo.CanViewOfficerNote
+function Guild:Wipe(type)
+    local guild = self:GetGuild()
 	if not guild and not CanViewOfficerNote() then
 		return
 	end
 
     local wipe = "I wiped all addon data from " .. guild .. "."
-    GBankClassic_Guild:Reset(guild)
+    self:Reset(guild)
 
 	local data = GBankClassic_Core:SerializeWithChecksum(wipe)
     if type ~= "reply" then
@@ -1634,25 +1897,26 @@ function GBankClassic_Guild:Wipe(type)
     end
 end
 
-function GBankClassic_Guild:WipeMine(type)
-    local guild = GBankClassic_Guild:GetGuild()
+function Guild:WipeMine()
+    local guild = self:GetGuild()
 	if not guild then
 		return
 	end
     
-    GBankClassic_Guild:Reset(guild)
+    self:Reset(guild)
 end
 
-function GBankClassic_Guild:Share(type)
-    local guild = GBankClassic_Guild:GetGuild()
+function Guild:Share(type, requestsMode)
+    local guild = self:GetGuild()
 	if not guild then
 		return
 	end
 
     self.Info = GBankClassic_Database:Load(guild)
-    local player = GBankClassic_Guild:GetPlayer()
-	local normPlayer = GBankClassic_Guild:GetNormalizedPlayer(player)
+    local player = self:GetPlayer()
+	local normPlayer = self:GetNormalizedPlayer(player)
     local share = "I'm sharing my bank data. Share yours please."
+	local mode = requestsMode or "snapshot"
 
     if not self.Info.alts[normPlayer] then
         if type ~= "reply" then
@@ -1662,12 +1926,20 @@ function GBankClassic_Guild:Share(type)
         end
     end
 
-	if self.Info.alts[normPlayer] and GBankClassic_Guild:IsBank(normPlayer) then
-		GBankClassic_Guild:SendAltData(normPlayer)
+	if self.Info.alts[normPlayer] and self:IsBank(normPlayer) then
+		self:SendAltData(normPlayer)
+	end
+
+	if mode == "snapshot" then
+		-- -- Share current requests state alongside bank data so everyone stays in sync
+		-- self:SendRequestsData()
+	elseif mode == "version" then
+		-- Lightweight ping; snapshots are sent only when queried.
+		self:SendRequestsVersionPing()
 	end
 
 	-- Broadcast delta version with hashes for pull-based protocol
-	-- Send BOTH legacy and delta version broadcasts
+	-- Send both legacy and delta version broadcasts
 	if GBankClassic_Events and GBankClassic_Events.Sync then
 		GBankClassic_Events:Sync()
 	end
@@ -1677,25 +1949,23 @@ function GBankClassic_Guild:Share(type)
 
 	local data = GBankClassic_Core:SerializeWithChecksum(share)
 	if type ~= "reply" then
-		-- Use NORMAL priority for share announcement so users are notified quickly
-		-- Actual data transfers (deltas/snapshots) use BULK to avoid network spam
+		-- Use normal priority for share announcement so users are notified quickly
+		-- Actual data transfers (deltas/snapshots) use bulk to avoid network spam
 		GBankClassic_Core:SendCommMessage("gbank-s", data, "Guild", nil, "NORMAL")
 	else
-		-- TODO: decide to remove?
 		GBankClassic_Core:SendCommMessage("gbank-sr", data, "Guild", nil, "NORMAL")
 	end
 end
 
-function GBankClassic_Guild:AuthorRosterData()
+function Guild:AuthorRosterData()
 	if not self.Info then
 		return
 	end
 
     local info = self.Info
     local isBank = false
-    local banks = GBankClassic_Guild:GetBanks()
-    local player = GBankClassic_Guild:GetPlayer()
-    local CanViewOfficerNote = CanViewOfficerNote or C_GuildInfo.CanViewOfficerNote
+    local banks = self:GetBanks()
+    local player = self:GetPlayer()
     if banks then
         for _, v in pairs(banks) do
             if v == player then
@@ -1705,17 +1975,17 @@ function GBankClassic_Guild:AuthorRosterData()
         end
     end
     if isBank or CanViewOfficerNote() then
-		if not info.roster then
+		if info and not info.roster then
 			info.roster = {}
 		end
-		if info.roster then
+		if info and info.roster then
 			info.roster.alts = banks
 			info.roster.version = GetServerTime()
 			if not banks then
 				info.roster.version = nil
 			end
 		end
-		GBankClassic_Guild:SendRosterData()
+		self:SendRosterData()
 		if banks then
 			local characterNames = {}
 			for _, bankChar in pairs(banks) do
@@ -1736,7 +2006,7 @@ function GBankClassic_Guild:AuthorRosterData()
 	end
 end
 
-function GBankClassic_Guild:SenderIsGM(player)
+function Guild:SenderIsGM(player)
 	if not player then
 		return false
 	end
@@ -1745,8 +2015,6 @@ function GBankClassic_Guild:SenderIsGM(player)
 		return false
 	end
 
-    local GetNumGuildMembers = GetNumGuildMembers or C_GuildInfo.GetNumGuildMembers
-    local GetGuildRosterInfo = GetGuildRosterInfo or C_GuildInfo.GetGuildRosterInfo
 	for i = 1, GetNumGuildMembers() do
 		local playerRealm, _, rankIndex = GetGuildRosterInfo(i)
 		if playerRealm then
diff --git a/Modules/Item.lua b/Modules/Item.lua
index a385d88..3b70aa5 100644
--- a/Modules/Item.lua
+++ b/Modules/Item.lua
@@ -1,66 +1,273 @@
-GBankClassic_Item = {}
+GBankClassic_Item = GBankClassic_Item or {}
+
+local Items = GBankClassic_Item
+
+-- Item classes that require link to be preserved (for suffix differentiation)
+local ITEM_CLASSES_NEEDING_LINK = {
+	[2] = true, -- Weapon
+	[4] = true, -- Armor (chest, legs, trinkets, rings, necks, etc)
+}
+
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("GetItemInfo", "GetTime", "GetItemInventoryTypeByID", "CreateFrame")
+local GetItemInfo = upvalues.GetItemInfo
+local GetTime = upvalues.GetTime
+local GetItemInventoryTypeByID = upvalues.GetItemInventoryTypeByID
+local CreateFrame = upvalues.CreateFrame
+local upvalues = Globals.GetUpvalues("Item")
+local Item = upvalues.Item
+local upvalues = Globals.GetUpvalues("UIParent")
+local UIParent = upvalues.UIParent
+local upvalues = Globals.GetUpvalues("ITEM_UNIQUE")
+local ITEM_UNIQUE = upvalues.ITEM_UNIQUE
+
+-- Check if an item needs its link preserved based on item class
+-- Gear (weapons/armor) can have random suffixes, so link is required
+-- Consumables and trade goods don't vary, so link can be stripped
+function Items:NeedsLink(itemLink)
+	if not itemLink then
+        return false
+    end
+
+	local _, _, _, _, _, itemClass = GetItemInfo(itemLink)
+
+	return ITEM_CLASSES_NEEDING_LINK[itemClass] == true
+end
+
+-- Get normalized item key for deduplication (strips unique instance ID)
+-- Items with same ID+suffix but different instance IDs will have same key
+-- Format: itemID:enchant:gem1:gem2:gem3:gem4:suffixID (7 parts)
+function Items:GetItemKey(link)
+	if not link or link == "" then
+		return ""
+	end
+	
+	local itemString = link:match("|Hitem:([^|]+)|h")
+	if not itemString then
+		itemString = link:match("item:([%d:]+)")
+	end
+	
+	if itemString then
+		-- Split into parts
+		local parts = {}
+		for part in string.gmatch(itemString, "([^:]+)") do
+			table.insert(parts, part)
+		end
+		
+		-- Keep first 7 parts only (strip uniqueID and specializationID)
+		if #parts >= 7 then
+			return "item:" .. table.concat({parts[1], parts[2], parts[3], parts[4], parts[5], parts[6], parts[7]}, ":")
+		else
+			return "item:" .. itemString
+		end
+	end
+	
+	return link
+end
+
+function Items:GetItems(items, callback)
+	if not items or type(items) ~= "table" then
+		callback({})
+
+		return
+	end
 
-function GBankClassic_Item:GetItems(items, callback)
     -- Only consider items that have a valid ID
     local total = 0
-    for _, item in pairs(items) do
-        if item and item.ID then
-            total = total + 1
-        end
-    end
+	local validItems = {}
+	for idx, item in pairs(items) do
+		-- Log every item we encounter to identify corrupted data
+		if not item then
+			GBankClassic_Output:Debug("ITEM", "Skipping nil item at index %s", tostring(idx))
+		elseif type(item) ~= "table" then
+			GBankClassic_Output:Debug("ITEM", "Skipping non-table item at index %s (type=%s)", tostring(idx), type(item))
+		elseif not item.ID then
+			GBankClassic_Output:Debug("ITEM", "Skipping item with nil ID at index %s", tostring(idx))
+		elseif type(item.ID) ~= "number" then
+			GBankClassic_Output:Debug("ITEM", "Skipping item with non-number ID at index %s (ID=%s, type=%s)", tostring(idx), tostring(item.ID), type(item.ID))
+		elseif item.ID <= 0 then
+			GBankClassic_Output:Debug("ITEM", "Skipping corrupted item with invalid ID at index %s (ID=%d)", tostring(idx), item.ID)
+		else
+			-- Valid item - add to processing list
+			total = total + 1
+			table.insert(validItems, { original = item, id = item.ID, link = item.Link })
+		end
+	end
 
     local list = {}
     local count = 0
+	local processed = 0 -- Track total items processed (success + failures)
+	local callbackFired = false -- Ensure callback only fires once
 
     -- If there are no valid items to load, return an empty list immediately
     if total == 0 then
         callback(list)
+
         return
     end
 
-    for _, item in pairs(items) do
-        if item and item.ID then
-            local itemData = Item:CreateFromItemID(item.ID)
-            itemData:ContinueOnItemLoad(function()
-                item.Info = self:GetInfo(item.ID, item.Link)
-				if item.Info then
-					table.insert(list, item)
+	-- Throttle UI refreshes to prevent stuttering when many items load async
+	local lastUIRefresh = 0
+	local function throttledUIRefresh()
+		local now = GetTime()
+		if now - lastUIRefresh < 0.5 then -- Throttle to max once per 0.5 seconds
+			return
+		end
+		lastUIRefresh = now
+
+		-- Only refresh if UI is actually open
+		if GBankClassic_UI_Inventory and GBankClassic_UI_Inventory.isOpen then
+			GBankClassic_UI_Inventory:DrawContent()
+		end
+		if GBankClassic_UI_Search and GBankClassic_UI_Search.isOpen then
+			GBankClassic_UI_Search:DrawContent()
+		end
+	end
+	
+	local function checkComplete()
+		if not callbackFired and processed >= total then
+			callbackFired = true
+			callback(list)
+		elseif processed == total then
+			throttledUIRefresh()
+		end
+	end
+
+	for _, wrapper in ipairs(validItems) do
+		local itemID = wrapper.id
+		local itemLink = wrapper.link
+		local item = wrapper.original
+		
+		-- Log what we're about to process
+		GBankClassic_Output:Debug("ITEM", "Processing wrapper: id=%s, link=%s, original.ID=%s", tostring(itemID), tostring(itemLink), tostring(item and item.ID or "nil item"))
+		
+		-- Final safety check before calling WoW API
+		if not itemID or type(itemID) ~= "number" or itemID <= 0 then
+			GBankClassic_Output:Debug("ITEM", "Skipping invalid: itemID=%s (type=%s)", tostring(itemID), type(itemID))
+			processed = processed + 1
+			checkComplete()
+		else
+			-- Capture itemID in local scope to prevent closure corruption
+			local capturedItemID = itemID
+			local capturedItemLink = itemLink
+			local capturedItem = item
+			
+			-- Double-check captured values
+			if not capturedItemID or type(capturedItemID) ~= "number" or capturedItemID <= 0 then
+				GBankClassic_Output:Debug("ITEM", "ERROR: itemID validation failed after capture!")
+				processed = processed + 1
+				checkComplete()
+			else
+				-- Check if item data is already cached (fast path)
+				local itemInfo = GetItemInfo(capturedItemID)
+				if itemInfo then
+					-- Item data is cached, use it directly
+					GBankClassic_Output:Debug("ITEM", "Item %d already cached", capturedItemID)
+					capturedItem.Info = self:GetInfo(capturedItemID, capturedItemLink)
+					table.insert(list, capturedItem)
+					count = count + 1
+					processed = processed + 1
+					checkComplete()
+				else
+					-- Item not cached, need async load
+					GBankClassic_Output:Debug("ITEM", "Item %d not cached, calling CreateFromItemID", capturedItemID)
+					
+					local success, itemData = pcall(Item.CreateFromItemID, Item, capturedItemID)
+					GBankClassic_Output:Debug("ITEM", "CreateFromItemID result: success=%s, itemData=%s, type=%s", tostring(success), tostring(itemData), type(itemData))
+					
+					if not success then
+						GBankClassic_Output:Debug("ITEM", "CreateFromItemID pcall failed: %s", tostring(itemData))
+						processed = processed + 1
+						checkComplete()
+					elseif not itemData then
+						GBankClassic_Output:Debug("ITEM", "CreateFromItemID returned nil")
+						processed = processed + 1
+						checkComplete()
+					elseif type(itemData) ~= "table" then
+						GBankClassic_Output:Debug("ITEM", "CreateFromItemID returned non-table: %s", type(itemData))
+						processed = processed + 1
+						checkComplete()
+					else
+						-- Got an item object, now inspect its internal state
+						GBankClassic_Output:Debug("ITEM", "Inspecting item object for ID %d", capturedItemID)
+						
+						-- Try to access internal fields safely
+						local objectItemID = nil
+						local accessSuccess = pcall(function()
+							objectItemID = itemData.itemID
+						end)
+						GBankClassic_Output:Debug("ITEM", "Internal field access: accessSuccess=%s, itemData.itemID=%s, type=%s", tostring(accessSuccess), tostring(objectItemID), type(objectItemID))
+						
+						-- Check if itemID matches what we expect
+						if not accessSuccess then
+							GBankClassic_Output:Debug("ITEM", "Cannot access itemData.itemID (protected?)")
+							processed = processed + 1
+							checkComplete()
+						elseif objectItemID == nil then
+							GBankClassic_Output:Debug("ITEM", "ERROR: itemData.itemID is nil for requested ID %d", capturedItemID)
+							processed = processed + 1
+							checkComplete()
+						elseif type(objectItemID) ~= "number" then
+							GBankClassic_Output:Debug("ITEM", "itemData.itemID is not a number: %s", type(objectItemID))
+							processed = processed + 1
+							checkComplete()
+						elseif objectItemID ~= capturedItemID then
+							GBankClassic_Output:Debug("ITEM", "itemData.itemID mismatch: expected %d, got %d", capturedItemID, objectItemID)
+							processed = processed + 1
+							checkComplete()
+						else
+							-- Everything looks good, try ContinueOnItemLoad
+							GBankClassic_Output:Debug("ITEM", "Item object valid (itemID=%d), calling ContinueOnItemLoad", objectItemID)
+							
+							local callbackSuccess, callbackError = pcall(function()
+								itemData:ContinueOnItemLoad(function()
+									GBankClassic_Output:Debug("ITEM", "ContinueOnItemLoad callback fired for ID %d", capturedItemID)
+									capturedItem.Info = self:GetInfo(capturedItemID, capturedItemLink)
+									table.insert(list, capturedItem)
+									count = count + 1
+									checkComplete()
+								end)
+							end)
+							GBankClassic_Output:Debug("ITEM", "ContinueOnItemLoad pcall result: success=%s, error=%s", tostring(callbackSuccess), tostring(callbackError))
+							
+							processed = processed + 1
+							
+							if not callbackSuccess then
+								GBankClassic_Output:Debug("ITEM", "ContinueOnItemLoad pcall failed for ID %d: %s", capturedItemID, tostring(callbackError))
+								checkComplete()
+							end
+						end
+					end
 				end
-                count = count + 1
-                if count == total then
-                    callback(list)
-                end
-            end)
-        end
-    end
+			end
+		end
+	end
 end
 
-function GBankClassic_Item:GetInfo(id, link)
-	if not link then
-		return nil
+function Items:GetInfo(id, link)
+	local name, _, rarity, level, _, _, _, _, _, icon, price, itemClassId, itemSubClassId
+	
+	-- Try link first if available
+	if link and link ~= "" then
+		name, _, rarity, level, _, _, _, _, _, icon, price, itemClassId, itemSubClassId = GetItemInfo(link)
 	end
-
-    local name, _, rarity, level, _, _, _, _, _, icon, price, itemClassId, itemSubClassId = GetItemInfo(link)
+	
+	-- Fallback to ID if link didn't work
+	if not name and id and id > 0 then
+		name, _, rarity, level, _, _, _, _, _, icon, price, itemClassId, itemSubClassId = GetItemInfo(id)
+	end
+	
+	-- If still no data, return basic info with ID only and the default grey question mark icon
 	if not name then
-		return nil
+		return { class = 0, subClass = 0, equipId = 0, rarity = 1, name = "Item " .. tostring(id or "?"), level = 1, price = 0, icon = 134400 }
 	end
 
-    local equip = C_Item.GetItemInventoryTypeByID(id)
-
-	return {
-		class = itemClassId,
-		subClass = itemSubClassId,
-		equipId = equip,
-		rarity = rarity,
-		name = name,
-		level = level,
-		price = price,
-		icon = icon,
-	}
+    local equip = GetItemInventoryTypeByID(id)
+
+	return { class = itemClassId, subClass = itemSubClassId, equipId = equip, rarity = rarity, name = name, level = level, price = price, icon = icon }
 end
 
--- NOTE: Sort was adapted from ElvUI
-local function BasicSort(a, b)
+local function basicSort(a, b)
     if a.Info.level ~= b.Info.level and a.Info.level and b.Info.level then
         return a.Info.level < b.Info.level
     end
@@ -72,8 +279,7 @@ local function BasicSort(a, b)
     end
 end
 
--- NOTE: Sort was adapted from ElvUI
-function GBankClassic_Item:Sort(items)
+function Items:Sort(items)
     table.sort(items, function(a, b)
         if a.Info.rarity ~= b.Info.rarity and a.Info.rarity and b.Info.rarity then
             return a.Info.rarity < b.Info.rarity
@@ -83,62 +289,130 @@ function GBankClassic_Item:Sort(items)
         end
         if a.Info.equipId > 0 then
             if a.Info.equipId == b.Info.equipId then
-                return BasicSort(a, b)
+                return basicSort(a, b)
             end
-
             if a.Info.equip and b.Info.equip then
                 return a.Info.equip < b.Info.equip
             end
         end
         if a.Info.class == b.Info.class and a.Info.subClass == b.Info.subClass then
-            return BasicSort(a, b)
+            return basicSort(a, b)
         end
+		
         return (a.Info.subClass or 99) < (b.Info.subClass or 99)
     end)
 end
 
-function GBankClassic_Item:Aggregate(a, b)
+function Items:Aggregate(a, b)
     local items = {}
+	-- Build ID index to avoid O(n) lookups for linkless deduplication
+	local itemsByID = {}
     if a then
         for _, v in pairs(a) do
-			if not v or not v.ID or not v.Link then
-				-- Skip malformed entries (missing required fields)
+			if not v or not v.ID then
+				-- Skip malformed entries (missing required ID field)
             else
-                local key = v.ID .. v.Link
-                if items[key] then
-                    local item = items[key]
-					local itemCount = item.Count or 1
-					local vCount = v.Count or 1
-					items[key] = { ID = item.ID, Count = itemCount + vCount, Link = item.Link }
-                else
-					items[key] = { ID = v.ID, Count = v.Count or 1, Link = v.Link }
-                end
-            end
-        end
-    end
+				-- Use normalized key (strips unique instance ID) for deduplication
+				-- This allows identical items with different instance IDs to merge
+				local itemKey = self:GetItemKey(v.Link)
+				local key
+				key = tostring(v.ID) .. itemKey
+				
+				-- If no link, also check if there's an existing entry with same ID but with link
+				-- This handles deduplication between linked (bank/bags) and linkless (mail) items
+				if not v.Link and itemKey == "" then
+					-- Use ID index for O(1) lookup instead of O(n) iteration
+					local idStr = tostring(v.ID)
+					local existingKeys = itemsByID[idStr]
+					if existingKeys and #existingKeys > 0 then
+						-- Found item(s) with same ID - merge into first entry
+						local existingKey = existingKeys[1]
+						local existingItem = items[existingKey]
+						local itemCount = existingItem.Count or 1
+						local vCount = v.Count or 1
+						existingItem.Count = itemCount + vCount
+						existingItem.Link = existingItem.Link or v.Link
+						key = nil -- Signal that we already merged
+					end
+				end
+				
+				if key then
+					if items[key] then
+						local item = items[key]
+						-- Defensive: use default value if count is missing
+						local itemCount = item.Count or 1
+						local vCount = v.Count or 1
+						items[key] = { ID = item.ID, Count = itemCount + vCount, Link = item.Link or v.Link }
+					else
+						-- Ensure stored item has count field
+						items[key] = { ID = v.ID, Count = v.Count or 1, Link = v.Link }
+						-- Add to ID index
+						local idStr = tostring(v.ID)
+						if not itemsByID[idStr] then
+							itemsByID[idStr] = {}
+						end
+						table.insert(itemsByID[idStr], key)
+					end
+				end
+			end
+		end
+	end
 
     if b then
         for _, v in pairs(b) do
-			if not v or not v.ID or not v.Link then
-				-- Skip malformed entries (missing required fields)
+			if not v or not v.ID then
+				-- Skip malformed entries (missing required ID field)
             else
-                local key = v.ID .. v.Link
-                if items[key] then
-                    local item = items[key]
-					local itemCount = item.Count or 1
-					local vCount = v.Count or 1
-					items[key] = { ID = item.ID, Count = itemCount + vCount, Link = item.Link }
-                else
-					items[key] = { ID = v.ID, Count = v.Count or 1, Link = v.Link }
-                end
-            end
-        end
-    end
+				-- Use normalized key (strips unique instance ID) for deduplication
+				-- This allows identical items with different instance IDs to merge
+				local itemKey = self:GetItemKey(v.Link)
+				local key
+				key = tostring(v.ID) .. itemKey
+				
+				-- If no link, also check if there's an existing entry with same ID but with link
+				-- This handles deduplication between linked (bank/bags) and linkless (mail) items
+				if not v.Link and itemKey == "" then
+					-- Use ID index for O(1) lookup instead of O(n) iteration
+					local idStr = tostring(v.ID)
+					local existingKeys = itemsByID[idStr]
+					if existingKeys and #existingKeys > 0 then
+						-- Found item(s) with same ID - merge into first entry
+						local existingKey = existingKeys[1]
+						local existingItem = items[existingKey]
+						local itemCount = existingItem.Count or 1
+						local vCount = v.Count or 1
+						existingItem.Count = itemCount + vCount
+						existingItem.Link = existingItem.Link or v.Link
+						key = nil -- Signal that we already merged
+					end
+				end
+				
+				if key then
+					if items[key] then
+						local item = items[key]
+						-- Defensive: use default value if count is missing
+						local itemCount = item.Count or 1
+						local vCount = v.Count or 1
+						items[key] = { ID = item.ID, Count = itemCount + vCount, Link = item.Link or v.Link }
+					else
+						-- Ensure stored item has count field
+						items[key] = { ID = v.ID, Count = v.Count or 1, Link = v.Link }
+						-- Add to ID index
+						local idStr = tostring(v.ID)
+						if not itemsByID[idStr] then
+							itemsByID[idStr] = {}
+						end
+						table.insert(itemsByID[idStr], key)
+					end
+				end
+			end
+		end
+	end
 
     return items
 end
 
-function GBankClassic_Item:IsUnique(link)
+function Items:IsUnique(link)
 	if not link then
 		return false
 	end
diff --git a/Modules/ItemHighlight.lua b/Modules/ItemHighlight.lua
new file mode 100644
index 0000000..f20c0c8
--- /dev/null
+++ b/Modules/ItemHighlight.lua
@@ -0,0 +1,372 @@
+-- GBankClassic_ItemHighlight = GBankClassic_ItemHighlight or {}
+
+-- local ItemHighlight = GBankClassic_ItemHighlight
+
+-- -- State
+-- ItemHighlight.enabled = false
+-- ItemHighlight.neededItems = {} -- {itemName: quantityNeeded}
+-- ItemHighlight.overlays = {} -- Texture overlays for dimming items
+
+-- -- Initialize the module
+-- function ItemHighlight:Initialize()
+-- 	-- Don't auto-enable from saved settings - let the checkbox control it
+-- 	self.enabled = false
+
+-- 	-- Register events
+-- 	local frame = CreateFrame("GBankClassicItemHighlightFrame")
+-- 	frame:RegisterEvent("BAG_UPDATE")
+-- 	frame:RegisterEvent("PLAYERBANKSLOTS_CHANGED")
+-- 	frame:RegisterEvent("BANKFRAME_OPENED")
+-- 	frame:RegisterEvent("BANKFRAME_CLOSED")
+-- 	frame:SetScript("OnEvent", function(_, event, ...)
+-- 		if self.enabled then
+-- 			self:RefreshHighlighting()
+-- 		end
+-- 	end)
+
+-- 	GBankClassic_Output:Debug("REQUESTS", "ItemHighlight initialized")
+-- end
+
+-- -- Enable/disable highlighting
+-- function ItemHighlight:SetEnabled(enabled)
+-- 	-- Only allow guild bank alts to use highlighting
+-- 	local banks = GBankClassic_Guild:GetBanks()
+-- 	if not banks then
+-- 		GBankClassic_Output:Debug("REQUESTS", "Highlighting disabled: no banks found")
+
+-- 		return
+-- 	end
+
+-- 	local currentPlayer = GBankClassic_Guild:GetNormalizedPlayer()
+-- 	local isBank = false
+-- 	for _, bankName in ipairs(banks) do
+-- 		local normBank = GBankClassic_Guild:NormalizeName(bankName)
+-- 		if normBank == currentPlayer then
+-- 			isBank = true
+-- 			break
+-- 		end
+-- 	end
+
+-- 	if not isBank then
+-- 		GBankClassic_Output:Debug("REQUESTS", "Highlighting disabled: not a guild bank alt")
+
+-- 		return
+-- 	end
+
+-- 	self.enabled = enabled
+
+-- 	-- Save to settings
+-- 	if not GBankClassicDB.settings then
+-- 		GBankClassicDB.settings = {}
+-- 	end
+-- 	GBankClassicDB.settings.highlightEnabled = enabled
+
+-- 	if enabled then
+-- 		self:RefreshHighlighting()
+-- 	else
+-- 		self:ClearAllOverlays()
+-- 		-- Clear Bagnon search when disabling
+-- 		if Bagnon then
+-- 			local addon = Bagnon
+-- 			addon.search = nil
+-- 			addon.canSearch = false
+-- 			addon:SendSignal('SEARCH_CHANGED')
+-- 		end
+-- 	end
+-- end
+
+-- -- Build table of needed items from all pending requests
+-- function ItemHighlight:BuildNeededItemsList()
+-- 	local info = GBankClassic_Guild.Info
+-- 	if not info or not info.requests then
+-- 		return false
+-- 	end
+
+-- 	-- Clear and rebuild
+-- 	self.neededItems = {}
+
+-- 	-- Get current guild bank alts from the requests UI filter
+-- 	local currentGuildBankAlt = GBankClassic_UI_Requests.bankFilter
+-- 	local currentPlayer = GBankClassic_Guild:GetNormalizedPlayer()
+
+-- 	-- If no filter set, default to current player if they're a guild bank alt
+-- 	if not currentGuildBankAlt or currentGuildBankAlt == "__gbank_any__" then
+-- 		if currentPlayer and GBankClassic_Guild:IsBank(currentPlayer) then
+-- 			currentGuildBankAlt = currentPlayer
+-- 		else
+-- 			return false
+-- 		end
+-- 	end
+
+-- 	-- Aggregate quantities from all pending requests for this guild bank alt
+-- 	-- Use pairs() since requests is now a map keyed by ID, not an array
+-- 	for _, request in pairs(info.requests or {}) do
+-- 		if request.bank == currentGuildBankAlt and request.status ~= "complete" and request.status ~= "fulfilled" and request.status ~= "cancelled" then
+
+-- 			local itemName = request.item
+-- 			local qtyNeeded = (request.quantity or 0) - (request.quantityFulfilled or 0)
+
+-- 			if qtyNeeded > 0 then
+-- 				self.neededItems[itemName] = (self.neededItems[itemName] or 0) + qtyNeeded
+-- 			end
+-- 		end
+-- 	end
+
+-- 	local uniqueCount = GBankClassic_Globals:Count(self.neededItems)
+-- 	GBankClassic_Output:Debug("REQUESTS", "Built needed items list: %d unique items", uniqueCount)
+
+-- 	return true
+-- end
+
+-- -- Check if an item is needed
+-- function ItemHighlight:IsItemNeeded(itemName)
+-- 	if not itemName then
+-- 		return false
+-- 	end
+
+-- 	return self.neededItems[itemName] ~= nil
+-- end
+
+-- -- Apply grey desaturation to a button
+-- function ItemHighlight:ApplyOverlay(button)
+-- 	if not button or not button:IsVisible() then
+-- 		return
+-- 	end
+
+-- 	-- Get the icon texture (works for both default and Bagnon buttons)
+-- 	local icon = button.icon or button.Icon or _G[button:GetName().."IconTexture"]
+-- 	if icon then
+-- 		-- Grey out by reducing color saturation (use very dark grey)
+-- 		icon:SetVertexColor(0.2, 0.2, 0.2)
+-- 	end
+-- 	self.overlays[button:GetName() or tostring(button)] = true
+-- end
+
+-- -- Remove grey desaturation from a button
+-- function ItemHighlight:RemoveOverlay(button)
+-- 	if not button then
+--        return
+--    end
+   
+-- 	local buttonName = button:GetName()
+-- 	-- Reset texture color to normal (FULL COLOR)
+-- 	local icon = button.icon or button.Icon or _G[buttonName.."IconTexture"]
+-- 	if icon then
+-- 		icon:SetVertexColor(1, 1, 1)
+-- 	end
+-- 	self.overlays[buttonName or tostring(button)] = nil
+-- end
+
+-- -- Clear all overlays
+-- function ItemHighlight:ClearAllOverlays()
+-- 	for buttonKey, _ in pairs(self.overlays) do
+-- 		local button = _G[buttonKey] or buttonKey
+-- 		if type(button) ~= "string" then
+-- 			self:RemoveOverlay(button)
+-- 		end
+-- 	end
+-- 	self.overlays = {}
+-- end
+
+-- -- Update highlighting for bag slots
+-- function ItemHighlight:UpdateBagHighlighting()
+-- 	GBankClassic_Output:Debug("REQUESTS", "UpdateBagHighlighting called")
+-- 	-- Try Bagnon first
+-- 	local bagnonWorked = self:UpdateBagnonHighlighting()
+-- 	if bagnonWorked then
+-- 		GBankClassic_Output:Debug("REQUESTS", "Using Bagnon highlighting")
+
+-- 		return
+-- 	end
+
+-- 	-- Fall back to default bags only if Bagnon didn't work
+-- 	GBankClassic_Output:Debug("REQUESTS", "Falling back to default bag highlighting")
+-- 	self:UpdateDefaultBagHighlighting()
+-- end
+
+-- -- Update highlighting for Bagnon bags
+-- function ItemHighlight:UpdateBagnonHighlighting()
+-- 	-- Check if Bagnon addon is loaded
+-- 	if not Bagnon and not BagBrother then
+-- 		GBankClassic_Output:Debug("REQUESTS", "Bagnon not found")
+
+-- 		return false
+-- 	end
+
+-- 	GBankClassic_Output:Debug("REQUESTS", "Bagnon found, building search string")
+
+-- 	-- Build search string from needed items
+-- 	-- Bagnon search is case-insensitive and matches partial names
+-- 	-- Use | as OR operator to match any of the item names
+-- 	local searchTerms = {}
+-- 	for itemName, _ in pairs(self.neededItems) do
+-- 		-- Strip common prefixes that don't match the actual item name
+-- 		-- Formula: Enchant Bracer -> Enchant Bracer
+-- 		-- Pattern: Robe of Power -> Robe of Power
+-- 		local cleanName = itemName:gsub("^Formula: ", "")
+-- 		cleanName = cleanName:gsub("^Pattern: ", "")
+-- 		cleanName = cleanName:gsub("^Recipe: ", "")
+-- 		cleanName = cleanName:gsub("^Plans: ", "")
+-- 		cleanName = cleanName:gsub("^Schematic: ", "")
+-- 		cleanName = cleanName:gsub("^Design: ", "")
+-- 		cleanName = cleanName:gsub("^Manual: ", "")
+-- 		table.insert(searchTerms, cleanName)
+-- 	end
+
+-- 	if #searchTerms == 0 then
+-- 		GBankClassic_Output:Debug("REQUESTS", "No items to search for")
+
+-- 		return false
+-- 	end
+
+-- 	-- Limit to 20 items max to prevent Bagnon timeout with complex search strings
+-- 	local MAX_SEARCH_ITEMS = 20
+-- 	if #searchTerms > MAX_SEARCH_ITEMS then
+-- 		GBankClassic_Output:Debug("REQUESTS", "Too many items (%d), limiting to %d", #searchTerms, MAX_SEARCH_ITEMS)
+-- 		local limited = {}
+-- 		for i = 1, MAX_SEARCH_ITEMS do
+-- 			limited[i] = searchTerms[i]
+-- 		end
+-- 		searchTerms = limited
+-- 	end
+
+-- 	-- Join with | (OR operator) so Bagnon matches items containing any of these names
+-- 	local searchString = table.concat(searchTerms, "|")
+-- 	GBankClassic_Output:Debug("REQUESTS", "Setting Bagnon search (%d items): %s", #searchTerms, searchString)
+
+-- 	-- Set Bagnon's search string (use whichever global is available)
+-- 	local addon = Bagnon or BagBrother
+-- 	if addon.sets then
+-- 		addon.sets.search = searchString
+-- 	end
+-- 	addon.search = searchString
+-- 	addon.canSearch = true
+
+-- 	-- Trigger search update
+-- 	addon:SendSignal('SEARCH_CHANGED')
+-- 	GBankClassic_Output:Debug("REQUESTS", "Sent SEARCH_CHANGED signal")
+
+-- 	return true
+-- end
+
+-- -- Update highlighting for default WoW bags
+-- function ItemHighlight:UpdateDefaultBagHighlighting()
+-- 	-- Iterate through all bags
+-- 	for bag = 0, 4 do
+-- 		local containerID = (bag == 0) and 1 or (bag + 1)
+-- 		local numSlots = GetContainerNumSlots(bag)
+
+-- 		-- Iterate through API slot numbers (1 to numSlots)
+-- 		for apiSlot = 1, numSlots do
+-- 			-- WoW bag buttons are ordered opposite of API slots
+-- 			-- API slot 1 = button slot numSlots, API slot 2 = button slot numSlots-1, etc.
+-- 			local buttonSlot = numSlots - apiSlot + 1
+-- 			local buttonName = string.format("ContainerFrame%dItem%d", containerID, buttonSlot)
+-- 			local button = _G[buttonName]
+-- 			if button then
+-- 				local itemInfo = GetContainerItemInfo(bag, apiSlot)
+-- 				if itemInfo then
+-- 					local itemName = GetItemNameByID(itemInfo.itemID)
+-- 					if not self:IsItemNeeded(itemName) then
+-- 						-- Item not needed - grey it out
+-- 						self:ApplyOverlay(button)
+-- 					end
+-- 				end
+-- 			end
+-- 		end
+-- 	end
+-- end
+
+-- -- Update highlighting for bank slots
+-- function ItemHighlight:UpdateBankHighlighting()
+-- 	if not BankFrame or not BankFrame:IsVisible() then
+--         return
+--     end
+
+-- 	-- Bank slots (1-28)
+-- 	for slot = 1, 28 do
+-- 		local itemInfo = GetContainerItemInfo(-1, slot)
+-- 		if itemInfo then
+-- 			local itemName = GetItemNameByID(itemInfo.itemID)
+-- 			local button = self:GetBankSlotButton(slot)
+-- 			if button then
+-- 				if self:IsItemNeeded(itemName) then
+-- 					self:RemoveOverlay(button)
+-- 				else
+-- 					self:ApplyOverlay(button)
+-- 				end
+-- 			end
+-- 		end
+-- 	end
+-- 	-- Bank bag slots (5-11)
+-- 	for bag = 5, 11 do
+-- 		local numSlots = GetContainerNumSlots(bag)
+-- 		for slot = 1, numSlots do
+-- 			local itemInfo = GetContainerItemInfo(bag, slot)
+-- 			if itemInfo then
+-- 				local itemName = GetItemNameByID(itemInfo.itemID)
+-- 				local button = self:GetBagSlotButton(bag, slot)
+-- 				if button then
+-- 					if self:IsItemNeeded(itemName) then
+-- 						self:RemoveOverlay(button)
+-- 					else
+-- 						self:ApplyOverlay(button)
+-- 					end
+-- 				end
+-- 			end
+-- 		end
+-- 	end
+-- end
+
+-- -- Get button frame for a bag slot
+-- function ItemHighlight:GetBagSlotButton(bag, slot)
+-- 	-- Classic Era uses direct frame names
+-- 	-- Bag 0 = ContainerFrame1, Bag 1-4 = ContainerFrame2-5
+-- 	local containerID = (bag == 0) and 1 or (bag + 1)
+-- 	local frameName = string.format("ContainerFrame%dItem%d", containerID, slot)
+
+-- 	return _G[frameName]
+-- end
+
+-- -- Get button frame for a bank slot
+-- function ItemHighlight:GetBankSlotButton(slot)
+-- 	-- Bank slots use BankFrameItem1, BankFrameItem2, etc.
+-- 	local frameName = string.format("BankFrameItem%d", slot)
+
+-- 	return _G[frameName]
+-- end
+
+-- -- Refresh all highlighting
+-- function ItemHighlight:RefreshHighlighting()
+-- 	if not self.enabled then
+-- 		-- If disabled, clear Bagnon search
+-- 		if Bagnon then
+-- 			local addon = Bagnon
+-- 			addon.search = nil
+-- 			addon.canSearch = false
+-- 			addon:SendSignal('SEARCH_CHANGED')
+-- 		end
+
+-- 		return
+-- 	end
+
+-- 	-- Rebuild needed items list
+-- 	local rebuilt = self:BuildNeededItemsList()
+-- 	if not rebuilt then
+-- 		GBankClassic_Output:Debug("REQUESTS", "BuildNeededItemsList returned false, exiting")
+
+-- 		return
+-- 	end
+
+-- 	GBankClassic_Output:Debug("REQUESTS", "About to clear overlays")
+-- 	-- Clear old overlays (for default bags)
+-- 	self:ClearAllOverlays()
+
+-- 	GBankClassic_Output:Debug("REQUESTS", "Cleared overlays, updating highlighting")
+
+-- 	-- Apply new highlighting
+-- 	self:UpdateBagHighlighting()
+-- 	self:UpdateBankHighlighting()
+
+-- 	GBankClassic_Output:Debug("REQUESTS", "Refreshed item highlighting")
+-- end
\ No newline at end of file
diff --git a/Modules/Mail.lua b/Modules/Mail.lua
index bf4f5ad..963a93b 100644
--- a/Modules/Mail.lua
+++ b/Modules/Mail.lua
@@ -1,7 +1,84 @@
-GBankClassic_Mail = {}
+GBankClassic_Mail = GBankClassic_Mail or {
+	-- -- State for split operation
+	-- splitState = nil -- {bag, slot, amount, attachmentSlot, request}
+}
+
+local Mail = GBankClassic_Mail
+
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("MailFrame")
+local MailFrame = upvalues.MailFrame
+local upvalues = Globals.GetUpvalues("CheckInbox", "GetInboxNumItems", "GetInboxHeaderInfo", "GetInboxItemLink", "GetInboxItem", "TakeInboxItem", "TakeInboxMoney", "GetItemInfo")
+local CheckInbox = upvalues.CheckInbox
+local GetInboxNumItems = upvalues.GetInboxNumItems
+local GetInboxHeaderInfo = upvalues.GetInboxHeaderInfo
+local GetInboxItemLink = upvalues.GetInboxItemLink
+local GetInboxItem = upvalues.GetInboxItem
+local TakeInboxItem = upvalues.TakeInboxItem
+local TakeInboxMoney = upvalues.TakeInboxMoney
+local GetItemInfo = upvalues.GetItemInfo
+local upvalues = Globals.GetUpvalues("ATTACHMENTS_MAX_RECEIVE")
+local ATTACHMENTS_MAX_RECEIVE = upvalues.ATTACHMENTS_MAX_RECEIVE
+
+-- -- Initialize split stack popup dialog
+-- if not StaticPopupDialogs["GBANK_SPLIT_STACK"] then
+-- 	StaticPopupDialogs["GBANK_SPLIT_STACK"] = {
+-- 		text = "%s",
+-- 		button1 = "Split",
+-- 		button2 = "Cancel",
+-- 		OnAccept = function(self, data)
+-- 			if not data then
+--              return
+--          end
+--
+-- 			ClearCursor()
+-- 			-- Find an empty bag slot to place the split items
+-- 			local emptyBag, emptySlot
+-- 			for bag = 0, 4 do
+-- 				local numSlots = GetContainerNumSlots(bag)
+-- 				for slot = 1, numSlots do
+-- 					if not GetContainerItemInfo(bag, slot) then
+-- 						emptyBag, emptySlot = bag, slot
+-- 						break
+-- 					end
+-- 				end
+-- 				if emptyBag then
+ --                 break
+--              end
+-- 			end
+-- 			if not emptyBag then
+-- 				return
+-- 			end
+
+-- 			-- Step 1: Split - puts amount on cursor
+-- 			SplitContainerItem(data.bag, data.slot, data.amount)
+-- 			After(0.1, function()
+-- 				-- Step 2: Place split items into empty slot to "commit" the split
+-- 				PickupContainerItem(emptyBag, emptySlot)
+-- 				After(0.05, function()
+-- 					-- Done! The split stack is now in inventory
+-- 					if GBankClassic_UI_Requests and GBankClassic_UI_Requests.Window then
+-- 						local message = string.format("Split %d %s complete. Click fulfill again to attach items.",
+-- 							data.amount, data.itemName)
+-- 						GBankClassic_UI_Requests.Window:SetStatusText(message)
+-- 						-- Refresh the request list to update the fulfill button icon
+-- 						GBankClassic_UI_Requests:DrawContent()
+-- 					end
+-- 				end)
+-- 			end)
+-- 		end,
+-- 		OnCancel = function()
+-- 			-- Nothing to clean up
+-- 		end,
+-- 		timeout = 0,
+-- 		whileDead = true,
+-- 		hideOnEscape = true,
+-- 		preferredIndex = 3,
+-- 	}
+-- end
 
 -- Check if mailbox is actually open (uses frame state as ground truth)
-function GBankClassic_Mail:IsMailboxOpen()
+function Mail:IsMailboxOpen()
 	local frameOpen = MailFrame and MailFrame:IsShown() or false
 	-- Sync our flag with actual frame state
 	if self.isOpen ~= frameOpen then
@@ -11,19 +88,17 @@ function GBankClassic_Mail:IsMailboxOpen()
 	return frameOpen
 end
 
-function GBankClassic_Mail:Check()
+function Mail:Check()
     CheckInbox()
 end
 
-function GBankClassic_Mail:Scan()
+function Mail:Scan()
     if not GBankClassic_Options:GetDonationEnabled() then
 		return
 	end
-
-    if not GBankClassic_Mail.isOpen then
+    if not Mail.isOpen then
 		return
 	end
-    
 	if self.isScanning then
 		return
 	end
@@ -50,6 +125,7 @@ function GBankClassic_Mail:Scan()
             isBank = true
         end
     end
+
 	if not isBank then
 		return
 	end
@@ -65,17 +141,12 @@ function GBankClassic_Mail:Scan()
         for mailId = 1, numItems do
             local _, _, sender, _, money, CODAmount, _, itemCount, _, wasReturned, _, canReply, isGM = GetInboxHeaderInfo(mailId)
             if not sender then
-                GBankClassic_Mail:ResetScan()
+                self:ResetScan()
 
                 return
             end
 
-            if CODAmount == 0
-                    and not wasReturned
-                    and not isGM
-                    and canReply
-                    and not self.Roster[sender]
-                    and (money > 0 or (itemCount and itemCount > 0)) then
+            if CODAmount == 0 and not wasReturned and not isGM and canReply and not self.Roster[sender] and (money > 0 or (itemCount and itemCount > 0)) then
                 local hasNonUnique = nil
                 if itemCount and itemCount > 0 then
                     for attachmentIndex = 1, ATTACHMENTS_MAX_RECEIVE do
@@ -95,6 +166,7 @@ function GBankClassic_Mail:Scan()
                 if hasNonUnique == nil or hasNonUnique then
                     GBankClassic_UI_Mail:SetMailId(mailId)
                     GBankClassic_UI_Mail:Open()
+
                     return
                 end
             end
@@ -102,22 +174,127 @@ function GBankClassic_Mail:Scan()
     end
 end
 
-function GBankClassic_Mail:ResetScan()
+-- -- Hook SendMail to update request fulfillment when sending items from bank alts
+-- function Mail:InitSendHook()
+-- 	if self.sendHooked then
+-- 		return
+-- 	end
+
+-- 	self.sendHooked = true
+
+-- 	hooksecurefunc("SendMail", function(recipient, subject, body)
+-- 		self:OnSendMail(recipient)
+-- 	end)
+-- end
+
+-- function Mail:OnSendMail(recipient)
+-- 	GBankClassic_Output:Debug("MAIL", "OnSendMail: hook fired for recipient=%s", tostring(recipient))
+	
+-- 	-- If pendingSend was set recently by PrepareFulfillMail (within 10 seconds), keep it
+-- 	-- Otherwise, read items from mail attachments (fallback for non-fulfill mails)
+-- 	local now = GetTime()
+-- 	if self.pendingSend and self.pendingSendAt and (now - self.pendingSendAt) < 10 then
+-- 		GBankClassic_Output:Debug("MAIL", "OnSendMail: Using pendingSend from PrepareFulfillMail")
+
+-- 		return
+-- 	end
+	
+-- 	-- Clear old pendingSend and read from mail attachments
+-- 	self.pendingSend = nil
+-- 	self.pendingSendAt = nil
+
+-- 	local sender = GBankClassic_Guild:GetNormalizedPlayer()
+-- 	local items = {}
+
+-- 	for attachmentIndex = 1, ATTACHMENTS_MAX_SEND do
+-- 		local itemName, _, _, quantity = GetSendMailItem(attachmentIndex)
+-- 		if itemName and quantity and quantity > 0 then
+-- 			table.insert(items, { name = itemName, quantity = quantity })
+-- 		end
+-- 	end
+
+-- 	GBankClassic_Output:Debug("UI", "OnSendMail: sender=%s, recipient=%s, items=%d", tostring(sender), tostring(recipient), #items)
+
+-- 	if #items == 0 then
+-- 		return
+-- 	end
+
+-- 	local info = GBankClassic_Guild.Info
+-- 	if not info or not info.requests or #info.requests == 0 then
+-- 		return
+-- 	end
+
+-- 	if not sender or not GBankClassic_Guild:IsBank(sender) then
+-- 		GBankClassic_Output:Debug("MAIL", "OnSendMail: Sender %s is not a guild bank alt, skipping", tostring(sender))
+
+-- 		return
+-- 	end
+
+-- 	GBankClassic_Output:Debug("MAIL", "OnSendMail: Sender %s IS a guild bank alt, setting pendingSend", tostring(sender))
+-- 	local normRecipient = GBankClassic_Guild:NormalizeName(recipient)
+
+-- 	self.pendingSend = {
+-- 		sender = sender,
+-- 		recipient = normRecipient,
+-- 		items = items,
+-- 	}
+-- 	self.pendingSendAt = GetTime()
+	
+-- 	-- Log at info level so user can see manual sends are tracked
+-- 	local itemList = {}
+-- 	for _, item in ipairs(items) do
+-- 		table.insert(itemList, string.format("%dx %s", item.quantity, item.name))
+-- 	end
+-- 	GBankClassic_Output:Info("Tracking manual mail to %s: %s", recipient, table.concat(itemList, ", "))
+-- end
+
+-- function Mail:ApplyPendingSend()
+-- 	GBankClassic_Output:Debug("MAIL", "ApplyPendingSend: Called, pendingSend=%s", tostring(self.pendingSend ~= nil))
+-- 	local pending = self.pendingSend
+-- 	if not pending then
+-- 		GBankClassic_Output:Debug("MAIL", "ApplyPendingSend: No pendingSend, returning")
+
+-- 		return
+-- 	end
+
+-- 	self.pendingSend = nil
+-- 	self.pendingSendAt = nil
+
+-- 	GBankClassic_Output:Info("Applying fulfillment for mail sent to %s...", pending.recipient)
+
+-- 	local totalApplied = 0
+-- 	for _, item in ipairs(pending.items) do
+-- 		local applied = GBankClassic_Guild:FulfillRequest(pending.sender, pending.recipient, item.name, item.quantity)
+-- 		if applied > 0 then
+-- 			GBankClassic_Output:Info("  Applied %dx %s toward %s's request", applied, item.name, pending.recipient)
+-- 		end
+-- 		totalApplied = totalApplied + applied
+-- 	end
+
+-- 	if totalApplied > 0 then
+-- 		GBankClassic_Output:Info("Total fulfilled: %d item(s) for %s", totalApplied, pending.recipient)
+-- 		GBankClassic_Guild:RefreshRequestsUI()
+-- 	else
+-- 		GBankClassic_Output:Info("No matching requests found for items sent to %s", pending.recipient)
+-- 	end
+-- end
+
+function Mail:ResetScan()
     -- We wait a second for the server to remove the item from the inbox before we take another
     GBankClassic_Core:ScheduleTimer(function(...)
-        GBankClassic_Mail:OnTimer()
+        self:OnTimer()
     end, 1)
 end
 
-function GBankClassic_Mail:OnTimer()
+function Mail:OnTimer()
     self.isScanning = false
-    GBankClassic_Mail:Scan()
+    self:Scan()
 end
 
-function GBankClassic_Mail:Open(mailId)
+function Mail:Open(mailId)
     local _, _, sender, _, money, _, _, itemCount = GetInboxHeaderInfo(mailId)
     if not sender then
-        GBankClassic_Mail:RetryOpen(mailId)
+        self:RetryOpen(mailId)
 
         return
     end
@@ -163,7 +340,7 @@ function GBankClassic_Mail:Open(mailId)
 
         TakeInboxMoney(mailId)
         if itemCount and itemCount > 0 then
-            GBankClassic_Mail:RetryOpen(mailId)
+            self:RetryOpen(mailId)
 
             return
         end
@@ -171,6 +348,7 @@ function GBankClassic_Mail:Open(mailId)
     if itemCount then
         if not GBankClassic_Bank:HasInventorySpace() then
             GBankClassic_Output:Warn("Inventory is full.")
+
             return
         end
 
@@ -178,9 +356,9 @@ function GBankClassic_Mail:Open(mailId)
             local link = GetInboxItemLink(mailId, attachmentIndex)
             if link then
                 local _, _, _, quantity, _ = GetInboxItem(mailId, attachmentIndex)
-                local name, _, quality, level, _, _, _, _, _, _, price = GetItemInfo(link)
+                local name, _, _, level, _, _, _, _, _, _, price = GetItemInfo(link)
                 if not name or level == nil then
-                    GBankClassic_Mail:RetryOpen(mailId)
+                    self:RetryOpen(mailId)
 
                     return
                 end
@@ -198,7 +376,7 @@ function GBankClassic_Mail:Open(mailId)
 
                     TakeInboxItem(mailId, attachmentIndex)
                     if itemCount > 1 then
-                        GBankClassic_Mail:RetryOpen(mailId)
+                        self:RetryOpen(mailId)
 
                         return
                     end
@@ -208,16 +386,415 @@ function GBankClassic_Mail:Open(mailId)
     end
 
     GBankClassic_UI_Mail:Close()
-    GBankClassic_Mail:ResetScan()
+    self:ResetScan()
 end
 
-function GBankClassic_Mail:RetryOpen(mailId)
+function Mail:RetryOpen(mailId)
     -- We wait a second for the server to remove the item from the inbox before we take another
     GBankClassic_Core:ScheduleTimer(function(...)
-        GBankClassic_Mail:OnRetryTimer(mailId)
+        self:OnRetryTimer(mailId)
     end, 1)
 end
 
-function GBankClassic_Mail:OnRetryTimer(mailId)
-    GBankClassic_Mail:Open(mailId)
-end
\ No newline at end of file
+function Mail:OnRetryTimer(mailId)
+    self:Open(mailId)
+end
+
+-- -- Check if a request can be fulfilled by the current player
+-- -- Returns: canFulfill (boolean), reason (string), itemsInBags (number), smallestStack (number)
+-- function Mail:CanFulfillRequest(request, actor)
+-- 	local normActor = GBankClassic_Guild:NormalizeName(actor or GBankClassic_Guild:GetPlayer())
+
+-- 	-- Must be a bank alt
+-- 	if not GBankClassic_Guild:IsBank(normActor) then
+-- 		return false, "Only bank alts can fulfill requests.", 0, 0
+-- 	end
+
+-- 	-- Request must be valid and not completed
+-- 	if not request or not request.item then
+-- 		return false, "Invalid request.", 0, 0
+-- 	end
+
+-- 	local qtyRequested = tonumber(request.quantity or 0) or 0
+-- 	local qtyFulfilled = tonumber(request.fulfilled or 0) or 0
+-- 	local qtyNeeded = qtyRequested - qtyFulfilled
+
+-- 	if request.status == "complete" or request.status == "fulfilled" or request.status == "cancelled" then
+-- 		return false, "Request is already completed.", 0, 0
+-- 	end
+
+-- 	if qtyFulfilled >= qtyRequested and qtyRequested > 0 then
+-- 		return false, "Request is already fulfilled.", 0, 0
+-- 	end
+
+-- 	-- Check if items are in bags and find usable stacks
+-- 	local totalInBags, items = GBankClassic_Bank:CountItemInBags(request.item)
+
+-- 	if totalInBags == 0 then
+-- 		return false, "Items not in bags. Pick up from bank first.", 0, 0
+-- 	end
+
+-- 	-- Sort items by stack size (largest first) to match attachment behavior
+-- 	table.sort(items, function(a, b) return a.count > b.count end)
+
+-- 	-- Find smallest and largest stacks, and count usable items (stacks that fit without exceeding qtyNeeded)
+-- 	local smallestStack = nil
+-- 	local largestStack = nil
+-- 	local usableItems = 0
+-- 	for _, item in ipairs(items) do
+-- 		if not smallestStack or item.count < smallestStack then
+-- 			smallestStack = item.count
+-- 		end
+-- 		if not largestStack or item.count > largestStack then
+-- 			largestStack = item.count
+-- 		end
+-- 		-- Only count this stack if adding it doesn't exceed what we need
+-- 		if usableItems + item.count <= qtyNeeded then
+-- 			usableItems = usableItems + item.count
+-- 		end
+-- 	end
+
+-- 	-- If greedy smallest-first didn't get exact match, try skipping individual small stacks
+-- 	if usableItems < qtyNeeded and totalInBags >= qtyNeeded then
+-- 		for skipIndex = 1, math.min(5, #items) do
+-- 			local testUsable = 0
+-- 			for i = 1, #items do
+-- 				if i ~= skipIndex and testUsable + items[i].count <= qtyNeeded then
+-- 					testUsable = testUsable + items[i].count
+-- 				end
+-- 			end
+-- 			if testUsable == qtyNeeded then
+-- 				usableItems = testUsable
+-- 				break
+-- 			elseif testUsable > usableItems and testUsable <= qtyNeeded then
+-- 				-- Better fit, use it
+-- 				usableItems = testUsable
+-- 			end
+-- 		end
+-- 	end
+
+-- 	-- Check if we need to split
+-- 	if usableItems < qtyNeeded and totalInBags >= qtyNeeded then
+-- 		-- We have enough total, but need to split to fulfill
+-- 		-- Efficiency check: if we have any stack large enough to provide what we need,
+-- 		-- Prefer splitting from it rather than using multiple small stacks
+-- 		if largestStack and largestStack >= qtyNeeded then
+-- 			-- Can split exactly what we need from a single stack - more efficient
+-- 			local reason = string.format("Split %d from available stacks.", qtyNeeded)
+
+-- 			return true, reason, totalInBags, smallestStack
+-- 		end
+		
+-- 		local remaining = qtyNeeded - usableItems
+		
+-- 		-- Additional efficiency check: if using small partials requires a split,
+-- 		-- Check if using only the largest stacks would require similar or smaller effort
+-- 		-- Example: [1,20,20,20,20,20] need 90 -> better to use 420+split(10) than 1+420+split(9)
+-- 		-- The trade-off: splitting 10 from one stack vs using a 1-stack + splitting 9
+-- 		if largestStack and largestStack > 1 and remaining > 0 then
+-- 			-- Count how many complete largest stacks we can use
+-- 			local largeStacksUsable = 0
+-- 			for _, item in ipairs(items) do
+-- 				if item.count == largestStack and largeStacksUsable + item.count <= qtyNeeded then
+-- 					largeStacksUsable = largeStacksUsable + item.count
+-- 				end
+-- 			end
+			
+-- 			-- If we have at least one more largest stack available to split from
+-- 			local hasExtraLargeStack = false
+-- 			for _, item in ipairs(items) do
+-- 				if item.count == largestStack then
+-- 					local testTotal = largeStacksUsable + item.count
+-- 					if testTotal > largeStacksUsable and testTotal >= qtyNeeded then
+-- 						hasExtraLargeStack = true
+-- 						break
+-- 					end
+-- 				end
+-- 			end
+			
+-- 			if hasExtraLargeStack and largeStacksUsable < qtyNeeded then
+-- 				local largeSplitAmount = qtyNeeded - largeStacksUsable
+-- 				-- Prefer this if it means not attaching tiny partial stacks
+-- 				-- (using fewer mail attachment slots is more efficient)
+-- 				if largeSplitAmount <= largestStack then
+-- 					usableItems = largeStacksUsable
+-- 					remaining = largeSplitAmount
+-- 				end
+-- 			end
+-- 		end
+		
+-- 		local reason = string.format("Splitting %d to fill the order.", remaining)
+
+-- 		return true, reason, totalInBags, smallestStack
+-- 	end
+
+-- 	-- If no stacks are small enough, we can split automatically
+-- 	if usableItems == 0 and smallestStack and smallestStack > qtyNeeded then
+-- 		local reason = string.format("Split from stack of %d.", smallestStack)
+
+-- 		return true, reason, totalInBags, smallestStack
+-- 	end
+
+-- 	-- Check if we have enough usable items to fulfill the request
+-- 	if usableItems >= qtyNeeded then
+-- 		return true, nil, usableItems, smallestStack
+-- 	end
+
+-- 	-- Not enough items even with splitting
+-- 	return false, string.format("Need %d more items.", qtyNeeded - usableItems), totalInBags, smallestStack
+-- end
+
+-- -- Prepare mail to fulfill a request: sets recipient and attaches items
+-- -- Returns: success (boolean), message (string), attachedCount (number)
+-- function Mail:PrepareFulfillMail(request)
+-- 	if not self:IsMailboxOpen() then
+-- 		return false, "Mailbox is not open.", 0
+-- 	end
+
+-- 	if not request or not request.item or not request.requester then
+-- 		return false, "Invalid request.", 0
+-- 	end
+
+-- 	local itemName = request.item
+-- 	local requester = request.requester
+-- 	local qtyRequested = tonumber(request.quantity or 0) or 0
+-- 	local qtyFulfilled = tonumber(request.fulfilled or 0) or 0
+-- 	local qtyNeeded = qtyRequested - qtyFulfilled
+
+-- 	if qtyNeeded <= 0 then
+-- 		return false, "Request is already fulfilled.", 0
+-- 	end
+
+-- 	-- Find items in inventory
+-- 	local totalInBags, items = GBankClassic_Bank:CountItemInBags(itemName)
+
+-- 	if totalInBags == 0 then
+-- 		return false, "No " .. itemName .. " found in bags.", 0
+-- 	end
+
+-- 	-- Check if mail already has items attached
+-- 	if GetSendMailItem(1) then
+-- 		return false, "Mail already has items attached. Send or clear first.", 0
+-- 	end
+
+-- 	-- Set recipient
+-- 	if SendMailNameEditBox then
+-- 		SendMailNameEditBox:SetText(requester)
+-- 	end
+
+-- 	-- Attach items (up to ATTACHMENTS_MAX_SEND slots)
+-- 	-- Classic Era doesn't support programmatic stack splitting,
+-- 	-- So we only attach stacks that won't exceed the needed quantity
+-- 	local attached = 0
+-- 	local attachmentSlot = 1
+-- 	local maxSlots = ATTACHMENTS_MAX_SEND or 12
+-- 	local skippedLargeStack = nil
+
+-- 	-- Sort items by stack size (largest first) - full stacks before partial stacks
+-- 	-- When counts are equal, maintain the original scan order (bottom-right to top-left in bags)
+-- 	-- By adding an index to each item before sorting
+-- 	for i, item in ipairs(items) do
+-- 		item.originalIndex = i
+-- 	end
+-- 	table.sort(items, function(a, b)
+-- 		if a.count == b.count then
+-- 			return a.originalIndex < b.originalIndex -- Maintain physical order for equal counts
+-- 		end
+
+-- 		return a.count > b.count
+-- 	end)
+
+-- 	-- First pass: Calculate minimum useful stack size based on split requirement
+-- 	-- Strategy: Don't use stacks smaller than what we'll need to split
+-- 	-- Example: Need 95, have [20,20,20,20,14]  need to split 15, so exclude 14
+	
+-- 	-- Accumulate largest stacks to see what we'd need to split
+-- 	local accumulated = 0
+-- 	local largestStack = items[1] and items[1].count or 0
+	
+-- 	for _, item in ipairs(items) do
+-- 		if accumulated >= qtyNeeded then
+-- 			break
+-- 		end
+-- 		-- Only accumulate stacks that are at least half the largest stack size
+-- 		-- This gets us the "main" stacks and ignores tiny partials
+-- 		if item.count >= (largestStack * 0.5) then
+-- 			accumulated = accumulated + item.count
+-- 		end
+-- 	end
+	
+-- 	-- Calculate what we'd need to split
+-- 	local wouldNeedToSplit = math.max(0, qtyNeeded - accumulated)
+	
+-- 	-- Minimum stack size = the split amount (must be able to split that much from a stack)
+-- 	-- If no split needed, use min(5, qtyNeeded) to avoid filtering out perfectly sized stacks
+-- 	-- Example: Need 1 item  minStackSize should be 1, not 5
+-- 	-- Never set minStackSize higher than largestStack (fixes non-stackable items like bags)
+-- 	local minStackSize = math.min(largestStack, wouldNeedToSplit > 0 and wouldNeedToSplit or math.min(5, qtyNeeded))
+	
+-- 	-- Build useful stacks list
+-- 	local usefulStacks = {}
+-- 	for i, item in ipairs(items) do
+-- 		if item.count >= minStackSize then
+-- 			table.insert(usefulStacks, item)
+-- 		end
+-- 	end
+	
+-- 	GBankClassic_Output:Debug("FULFILL", "Need %d, accumulated %d from large stacks, would split %d", qtyNeeded, accumulated, wouldNeedToSplit)
+-- 	GBankClassic_Output:Debug("FULFILL", "Filtered %d useful stacks from %d total (min size: %d)", #usefulStacks, #items, minStackSize)
+
+-- 	-- Second pass: Run greedy algorithm on useful stacks only
+-- 	local simulatedAttached = 0
+-- 	local skipStackIndex = nil -- Track which stack to skip during attachment for optimal fit
+-- 	local splitStackIndex = nil -- Track which stack we'll split from
+
+-- 	-- Greedy pass: accumulate items until we need more than a stack can provide
+-- 	-- Process in two stages to prefer exact-fit stacks before splits
+-- 	-- Stage 1: Accumulate all stacks that fit exactly without exceeding qtyNeeded
+-- 	for i, item in ipairs(usefulStacks) do
+-- 		if simulatedAttached >= qtyNeeded then
+-- 			break
+-- 		end
+-- 		local remaining = qtyNeeded - simulatedAttached
+
+-- 		if item.count <= remaining then
+-- 			-- This stack fits completely - accumulate it
+-- 			simulatedAttached = simulatedAttached + item.count
+-- 			GBankClassic_Output:Debug("FULFILL", "Stack %d: count=%d, accumulate, total=%d", i, item.count, simulatedAttached)
+-- 		end
+-- 	end
+	
+-- 	-- Stage 2: If we didn't get enough, look for a stack to split
+-- 	if simulatedAttached < qtyNeeded then
+-- 		local remaining = qtyNeeded - simulatedAttached
+-- 		for i, item in ipairs(usefulStacks) do
+-- 			if item.count > remaining and item.count >= remaining then
+-- 				-- This stack can provide the remaining amount
+-- 				skippedLargeStack = item
+-- 				splitStackIndex = i
+-- 				GBankClassic_Output:Debug("FULFILL", "Stack %d: count=%d, can split (need %d), mark as candidate", i, item.count, remaining)
+-- 				break -- Found a split candidate, stop looking
+-- 			end
+-- 		end
+-- 	else
+-- 		-- We accumulated enough - no split needed
+-- 		GBankClassic_Output:Debug("FULFILL", "Accumulated enough - no split needed")
+-- 	end
+	
+-- 	GBankClassic_Output:Debug("FULFILL", "Greedy result: attached=%d, splitStackIndex=%s", simulatedAttached, tostring(splitStackIndex))
+
+-- 	-- If greedy didn't get exact match and didn't find a split candidate, try skipping individual stacks to find better fit
+-- 	if simulatedAttached < qtyNeeded and totalInBags >= qtyNeeded and not skippedLargeStack then
+-- 		for skipIndex = 1, math.min(5, #items) do
+-- 			local testAttached = 0
+-- 			local testSkippedLargeStack = nil
+-- 			local testSplitStackIndex = nil
+-- 			for i = 1, #items do
+-- 				if i ~= skipIndex then
+-- 					local remaining = qtyNeeded - testAttached
+-- 					if testAttached >= qtyNeeded then
+-- 						break
+-- 					elseif items[i].count <= remaining then
+-- 						testAttached = testAttached + items[i].count
+-- 					elseif items[i].count >= remaining then
+-- 						-- This stack can provide the remaining amount - keep track of it
+-- 						-- Continue iterating to find the last stack that can be split
+-- 						testSkippedLargeStack = items[i]
+-- 						testSplitStackIndex = i
+-- 					else
+-- 						-- This stack is too small to split - stop here
+-- 						break
+-- 					end
+-- 				end
+-- 			end
+-- 			if testAttached == qtyNeeded then
+-- 				simulatedAttached = testAttached
+-- 				skipStackIndex = skipIndex -- Remember to skip this stack during attachment
+-- 				skippedLargeStack = nil -- No split needed - found exact match!
+-- 				splitStackIndex = nil
+-- 				break
+-- 			elseif testAttached > simulatedAttached or (testAttached == simulatedAttached and testSplitStackIndex and splitStackIndex and testSplitStackIndex > splitStackIndex) then
+-- 				-- Better fit found, or same fit but with split from a later stack (preferred)
+-- 				simulatedAttached = testAttached
+-- 				skipStackIndex = skipIndex
+-- 				skippedLargeStack = testSkippedLargeStack
+-- 				splitStackIndex = testSplitStackIndex
+-- 			end
+-- 		end
+-- 	end
+
+-- 	-- If we need to split, show popup first without attaching anything
+-- 	if skippedLargeStack then
+-- 		local remaining = qtyNeeded - simulatedAttached
+
+-- 		-- Show confirmation popup
+-- 		local popupText = string.format("Split %d from stack of %d %s?", remaining, skippedLargeStack.count, itemName)
+-- 		local dialog = StaticPopup_Show("GBANK_SPLIT_STACK", popupText)
+-- 		if dialog then
+-- 			dialog.data = {
+-- 				bag = skippedLargeStack.bag,
+-- 				slot = skippedLargeStack.slot,
+-- 				amount = remaining,
+-- 				attachmentSlot = attachmentSlot,
+-- 				itemName = itemName,
+-- 				requester = requester
+-- 			}
+-- 		end
+
+-- 		local message = string.format("Click split to prepare %d %s for mailing.", remaining, itemName)
+
+-- 		return false, message, 0
+-- 	end
+
+-- 	-- No split needed, proceed with normal attachment
+-- 	for i, item in ipairs(usefulStacks) do
+-- 		if attached >= qtyNeeded then
+-- 			break
+-- 		end
+-- 		if attachmentSlot > maxSlots then
+-- 			break
+-- 		end
+
+-- 		-- Skip this stack if it was identified as needing to be skipped for optimal fit
+-- 		if not (skipStackIndex and i == skipStackIndex) then
+-- 			local remaining = qtyNeeded - attached
+
+-- 			-- Attach full stacks that don't exceed what we need
+-- 			if item.count <= remaining then
+-- 				ClearCursor()
+-- 				PickupContainerItem(item.bag, item.slot)
+-- 				ClickSendMailItemButton(attachmentSlot)
+
+-- 				attached = attached + item.count
+-- 				attachmentSlot = attachmentSlot + 1
+-- 			end
+-- 		end
+-- 	end
+
+-- 	local message
+-- 	if attached >= qtyNeeded then
+-- 		message = string.format("Attached %d %s for %s. Click send to complete.", attached, itemName, requester)
+-- 	elseif attached > 0 then
+-- 		message = string.format("Attached %d of %d %s (partial). Click send, then fulfill again.", attached, qtyNeeded, itemName)
+-- 	else
+-- 		message = string.format("No %s found in bags.", itemName)
+
+-- 		return false, message, 0
+-- 	end
+	
+-- 	-- Set pendingSend now (when items are attached), not in SendMail hook
+-- 	-- This ensures pendingSend is set BEFORE MAIL_SEND_SUCCESS fires
+-- 	if attached > 0 then
+-- 		local sender = GBankClassic_Guild:GetNormalizedPlayer()
+-- 		local normRecipient = GBankClassic_Guild:NormalizeName(requester)
+-- 		self.pendingSend = {
+-- 			sender = sender,
+-- 			recipient = normRecipient,
+-- 			items = {{ name = itemName, quantity = attached }}
+-- 		}
+-- 		self.pendingSendAt = GetTime()
+-- 		GBankClassic_Output:Debug("MAIL", "PrepareFulfillMail: Set pendingSend for %s (%d %s)", tostring(normRecipient), attached, itemName)
+-- 	end
+	
+-- 	return true, message, attached
+-- end
\ No newline at end of file
diff --git a/Modules/MailInventory.lua b/Modules/MailInventory.lua
new file mode 100644
index 0000000..f624538
--- /dev/null
+++ b/Modules/MailInventory.lua
@@ -0,0 +1,158 @@
+GBankClassic_MailInventory = GBankClassic_MailInventory or {}
+
+local MailInventory = GBankClassic_MailInventory
+
+MailInventory.hasUpdated = false
+
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("time")
+local time = upvalues.time
+local upvalues = Globals.GetUpvalues("GetInboxNumItems", "GetInboxHeaderInfo", "GetInboxItem", "GetInboxItemLink", "GetServerTime")
+local GetInboxNumItems = upvalues.GetInboxNumItems
+local GetInboxHeaderInfo = upvalues.GetInboxHeaderInfo
+local GetInboxItem = upvalues.GetInboxItem
+local GetInboxItemLink = upvalues.GetInboxItemLink
+local GetServerTime = upvalues.GetServerTime
+local upvalues = Globals.GetUpvalues("ATTACHMENTS_MAX_RECEIVE")
+local ATTACHMENTS_MAX_RECEIVE = upvalues.ATTACHMENTS_MAX_RECEIVE
+
+-- Scans the current mailbox and returns structured mail inventory data
+-- Called from Bank:Scan() when mail was accessed (hasUpdated = true)
+function MailInventory:ScanMailInventory()
+	-- Only scan if mail was accessed this session
+	if not self.hasUpdated then
+		GBankClassic_Output:Debug("MAIL", "ScanMailInventory called but hasUpdated=false, returning nil")
+
+		return nil
+	end
+	
+	-- Use same structure as bank/bags: aggregate by composite key, store as array
+	local mailItemsTable = {}
+	local numItems = GetInboxNumItems()
+	
+	GBankClassic_Output:Debug("MAIL", "Starting mailbox scan: %d mail messages", numItems)
+	
+	for i = 1, numItems do
+		local _, _, sender, _, _, CODAmount, _, hasItem = GetInboxHeaderInfo(i)
+		
+		-- Skip COD mail (can't take items without payment)
+		if hasItem and CODAmount == 0 then
+			for j = 1, ATTACHMENTS_MAX_RECEIVE do
+				local name, itemID, _, count = GetInboxItem(i, j)
+				
+				if itemID and name then
+					local link = GetInboxItemLink(i, j)
+					
+					-- Conditionally include link based on item class
+					-- Gear (weapons/armor) needs full link for suffix differentiation
+					-- Consumables/trade goods don't need link (saves bandwidth in d3 sync)
+					local storageLink = nil
+					if link and GBankClassic_Item:NeedsLink(link) then
+						storageLink = link -- Store full link for gear
+					end
+					
+					-- Use normalized key for deduplication (strips unique instance ID)
+					-- This allows identical items to merge even if they have different instance IDs
+					local itemKey = GBankClassic_Item:GetItemKey(link)
+					local key = tostring(itemID) .. itemKey
+					
+					if mailItemsTable[key] then
+						-- Item already exists, add to count
+						local item = mailItemsTable[key]
+						mailItemsTable[key] = { ID = item.ID, Count = item.Count + count, Link = item.Link or storageLink }
+						GBankClassic_Output:Debug("MAIL", "Item %s: merged (key=%s) added %d, total now %d", name, key, count, mailItemsTable[key].Count)
+					else
+						-- New item
+						mailItemsTable[key] = { ID = itemID, Count = count, Link = storageLink }
+						GBankClassic_Output:Debug("MAIL", "New item in mailbox: %s (ID: %d, Count: %d, link: %s, Key: %s)", name, itemID, count, storageLink and "preserved" or "stripped", key)
+					end
+				end
+			end
+		elseif hasItem and CODAmount > 0 then
+			GBankClassic_Output:Debug("MAIL", "Skipping COD mail from %s (COD: %d copper)", sender or "Unknown", CODAmount)
+		end
+	end
+	
+	-- Convert to array format (same as bank/bags)
+	local mailItems = {}
+	for _, item in pairs(mailItemsTable) do
+		table.insert(mailItems, item)
+	end
+	
+	-- Verify mailItems is a proper sequential array
+	GBankClassic_Output:Debug("MAIL", "Created mail items array with %d items", #mailItems)
+	for i = 1, math.min(3, #mailItems) do
+		if mailItems[i] then
+			GBankClassic_Output:Debug("MAIL", "  [%d] ID=%s, Count=%s", i, tostring(mailItems[i].ID), tostring(mailItems[i].Count))
+		end
+	end
+	
+	-- Build result structure (match bank/bags format for consistency)
+	local result = {
+		slots = { count = #mailItems, total = 50 }, -- Match bank/bags structure
+		items = mailItems, -- Now an array like bank/bags
+		version = GetServerTime(),
+		lastScan = GetServerTime()
+	}
+	
+	-- Verify result structure
+	GBankClassic_Output:Debug("MAIL", "Mail result structure: items type=%s, length=%d", type(result.items), #result.items)
+	GBankClassic_Output:Debug("MAIL", "Mail result slots.count=%d", result.slots.count)
+	GBankClassic_Output:Debug("MAIL", "Mail scan complete: %d unique items across %d mail messages", #mailItems, numItems)
+	
+	return result
+end
+
+-- Returns list of alts that have the specified item in their mail
+function MailInventory:GetItemsInMail(itemID)
+	local alts = {}
+	
+	if not GBankClassic_Guild.Info or not GBankClassic_Guild.Info.alts then
+		return alts
+	end
+	
+	for name, alt in pairs(GBankClassic_Guild.Info.alts) do
+		if alt.mail and alt.mail.items then
+			-- Search for matching ID
+			for _, item in ipairs(alt.mail.items) do
+				if item.ID == itemID then
+					table.insert(alts, { name = name, count = item.Count, lastScan = alt.mail.lastScan or 0 })
+					break -- Found the item, no need to continue
+				end
+			end
+		end
+	end
+	
+	return alts
+end
+
+-- -- Returns total count of item across all alts' mail
+-- function MailInventory:GetTotalInMail(itemID)
+-- 	local total = 0
+-- 	local alts = self:GetItemsInMail(itemID)
+	
+-- 	for _, alt in ipairs(alts) do
+-- 		total = total + alt.count
+-- 	end
+	
+-- 	return total
+-- end
+
+-- Returns age of mail scan data in seconds
+function MailInventory:GetMailDataAge(alt)
+	if not alt or not alt.mail or not alt.mail.lastScan then
+		return nil
+	end
+	
+	return time() - alt.mail.lastScan
+end
+
+-- -- Checks if alt has mail inventory data
+-- function MailInventory:HasMailInventory(alt)
+-- 	if not alt or not alt.mail or not alt.mail.items then
+-- 		return false
+-- 	end
+	
+-- 	-- Check if there are any items (mail.items is array format)
+-- 	return #alt.mail.items > 0
+-- end
\ No newline at end of file
diff --git a/Modules/Options.lua b/Modules/Options.lua
index 19bc8c5..c89e118 100644
--- a/Modules/Options.lua
+++ b/Modules/Options.lua
@@ -1,21 +1,46 @@
-GBankClassic_Options = {}
+GBankClassic_Options = GBankClassic_Options or {}
 
-function GBankClassic_Options:Init()
-    self.db = LibStub("AceDB-3.0"):New("GBankClassicOptionDB")
-    self.db.char = self.db.char or {}
-    self.db.char.minimap = self.db.char.minimap or { enabled = true }
-    self.db.char.combat = self.db.char.combat or { hide = true }
-    self.db.char.bank = self.db.char.bank or { donations = true }
-    self.db.char.bank['donations'] = (self.db.char.bank['donations'] == nil) and true or self.db.char.bank['donations']
-    self.db.global = self.db.global or {}
-    self.db.global.bank = self.db.global.bank or { report = true, logLevel = LOG_LEVEL.INFO, commDebug = false, muteSyncProgress = false }
-	self.db.global.bank["logLevel"] = self.db.global.bank["logLevel"] or LOG_LEVEL.INFO
-	self.db.global.bank["commDebug"] = self.db.global.bank["commDebug"] or false
-	self.db.global.bank["muteSyncProgress"] = self.db.global.bank["muteSyncProgress"] or false
+local Options = GBankClassic_Options
 
-    -- Initialize logger with saved level
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("LibStub")
+local LibStub = upvalues.LibStub
+local upvalues = Globals.GetUpvalues("Settings")
+local Settings = upvalues.Settings
+
+function Options:Init()
+	local defaults = {
+		char = {
+			minimap = { enabled = true },
+			combat = { hide = true },
+			bank = { donations = true },
+			framePositions = {},
+		},
+		global = {
+			bank = { report = true, logLevel = LOG_LEVEL.INFO, commDebug = false },
+			-- requests = {
+			-- 	maxRequestPercent = 100,  -- Maximum % of available items that can be requested (100 = no limit)
+			-- },
+		},
+	}
+	self.db = LibStub("AceDB-3.0"):New("GBankClassicOptionDB", defaults)
+	
+	-- Migrate from old shutup toggle to new logLevel
+	if self.db.global.bank["shutup"] ~= nil then
+		if self.db.global.bank["shutup"] == true then
+			self.db.global.bank["logLevel"] = LOG_LEVEL.RESPONSE
+		end
+		self.db.global.bank["shutup"] = nil
+	end
+	if self.db.global.bank["logLevel"] == nil then
+		self.db.global.bank["logLevel"] = LOG_LEVEL.INFO
+	end
+	if self.db.global.bank["commDebug"] == nil then
+		self.db.global.bank["commDebug"] = false
+	end
+
+    -- Initialize
 	GBankClassic_Output:SetLevel(self.db.global.bank["logLevel"])
-	-- Initialize comm debug with saved setting
 	GBankClassic_Output:SetCommDebug(self.db.global.bank["commDebug"])
 
     local options = {
@@ -78,19 +103,6 @@ function GBankClassic_Options:Init()
 							return self.db.global.bank["logLevel"]
 						end,
                     },
-					["muteSyncProgress"] = {
-						order = 2.6,
-						type = "toggle",
-						width = "full",
-						name = "Mute sync progress messages",
-						desc = "Hides 'Sharing guild bank data...' and 'Send complete...' messages during data sync",
-						set = function(_, v)
-							self.db.global.bank["muteSyncProgress"] = v
-						end,
-						get = function()
-							return self.db.global.bank["muteSyncProgress"]
-						end,
-					},
                     ["reset"] = {
                         order = -1,
                         name = "Reset database",
@@ -100,6 +112,7 @@ function GBankClassic_Options:Init()
                             if not guild then
                                 return
 							end
+
                             GBankClassic_Guild:Reset(guild)
                         end,
                     },
@@ -204,8 +217,20 @@ function GBankClassic_Options:Init()
 							return GBankClassic_Output:IsCategoryEnabled("WHISPER")
 						end,
 					},
+					-- ["requests"] = {
+					-- 	order = 17,
+					-- 	type = "toggle",
+					-- 	width = "full",
+					-- 	name = "REQUESTS - Request system activity and updates",
+					-- 	set = function(_, v)
+					-- 		GBankClassic_Output:SetCategoryEnabled("REQUESTS", v)
+					-- 	end,
+					-- 	get = function()
+					-- 		return GBankClassic_Output:IsCategoryEnabled("REQUESTS")
+					-- 	end,
+					-- },
 					["ui"] = {
-						order = 17,
+						order = 18,
 						type = "toggle",
 						width = "full",
 						name = "UI - Interface operations (window opens/closes)",
@@ -217,7 +242,7 @@ function GBankClassic_Options:Init()
 						end,
 					},
 					["protocol"] = {
-						order = 18,
+						order = 19,
 						type = "toggle",
 						width = "full",
 						name = "PROTOCOL - Protocol version negotiation",
@@ -229,7 +254,7 @@ function GBankClassic_Options:Init()
 						end,
 					},
 					["database"] = {
-						order = 19,
+						order = 20,
 						type = "toggle",
 						width = "full",
 						name = "DATABASE - Database and SavedVariables operations",
@@ -241,7 +266,7 @@ function GBankClassic_Options:Init()
 						end,
 					},
 					["events"] = {
-						order = 20,
+						order = 21,
 						type = "toggle",
 						width = "full",
 						name = "EVENTS - WoW event handling (GUILD_ROSTER_UPDATE, etc.)",
@@ -252,6 +277,66 @@ function GBankClassic_Options:Init()
 							return GBankClassic_Output:IsCategoryEnabled("EVENTS")
 						end,
 					},
+					["inventory"] = {
+						order = 22,
+						type = "toggle",
+						width = "full",
+						name = "INVENTORY - Inventory (bank/bag/mail) scanning and tracking",
+						set = function(_, v)
+							GBankClassic_Output:SetCategoryEnabled("INVENTORY", v)
+						end,
+						get = function()
+							return GBankClassic_Output:IsCategoryEnabled("INVENTORY")
+						end,
+					},
+					["mail"] = {
+						order = 23,
+						type = "toggle",
+						width = "full",
+						name = "MAIL - Mail inventory scanning and tracking",
+						set = function(_, v)
+							GBankClassic_Output:SetCategoryEnabled("MAIL", v)
+						end,
+						get = function()
+							return GBankClassic_Output:IsCategoryEnabled("MAIL")
+						end,
+					},
+					["item"] = {
+						order = 24,
+						type = "toggle",
+						width = "full",
+						name = "ITEM - Item loading, validation, and processing",
+						set = function(_, v)
+							GBankClassic_Output:SetCategoryEnabled("ITEM", v)
+						end,
+						get = function()
+							return GBankClassic_Output:IsCategoryEnabled("ITEM")
+						end,
+					},
+					-- ["fulfill"] = {
+					-- 	order = 25,
+					-- 	type = "toggle",
+					-- 	width = "full",
+					-- 	name = "FULFILL - Fulfilling requests",
+					-- 	set = function(_, v)
+					-- 		GBankClassic_Output:SetCategoryEnabled("FULFILL", v)
+					-- 	end,
+					-- 	get = function()
+					-- 		return GBankClassic_Output:IsCategoryEnabled("FULFILL")
+					-- 	end,
+					-- },
+					["search"] = {
+						order = 26,
+						type = "toggle",
+						width = "full",
+						name = "SEARCH - Search operations",
+						set = function(_, v)
+							GBankClassic_Output:SetCategoryEnabled("SEARCH", v)
+						end,
+						get = function()
+							return GBankClassic_Output:IsCategoryEnabled("SEARCH")
+						end,
+					},
 					["spacer"] = {
 						order = 30,
 						type = "description",
@@ -282,6 +367,85 @@ function GBankClassic_Options:Init()
 					},
 				},
 			},
+			-- requests = {
+			-- 	order = 3,
+			-- 	type = "group",
+			-- 	name = "Requests",
+			-- 	hidden = function()
+			-- 		-- Only show to officers
+			-- 		return not CanViewOfficerNote()
+			-- 	end,
+			-- 	args = {
+			-- 		["requestsHeader"] = {
+			-- 			order = 0,
+			-- 			type = "header",
+			-- 			name = "Request settings",
+			-- 		},
+			-- 		["requestsDesc"] = {
+			-- 			order = 1,
+			-- 			type = "description",
+			-- 			name = "Configure how item requests work to help manage bank inventory fairly.",
+			-- 		},
+			-- 		["maxRequestPercent"] = {
+			-- 			order = 2,
+			-- 			type = "range",
+			-- 			width = "full",
+			-- 			name = "Maximum request amount",
+			-- 			desc = "Limit how much of available inventory can be requested at once. Set to 100% to allow requesting everything. Lower values help share inventory among multiple guild members.\n\nExample: At 50%, if bank has 100 Copper Ore, members can request up to 50.\n\nNote: Single items (like gear) can always be requested even at low percentages.",
+			-- 			min = 1,
+			-- 			max = 100,
+			-- 			step = 1,
+			-- 			get = function()
+			-- 				return Options:GetMaxRequestPercent()
+			-- 			end,
+			-- 			set = function(_, v)
+			-- 				-- Write to guild-synced settings (propagates to all clients)
+			-- 				if GBankClassic_Guild and GBankClassic_Guild.Info and GBankClassic_Guild.Info.settings then
+			-- 					GBankClassic_Guild.Info.settings.maxRequestPercent = v
+			-- 					-- Broadcast settings change to guild
+			-- 					if GBankClassic_Guild.SendRequestsData then
+			-- 						GBankClassic_Guild:SendRequestsData()
+			-- 					end
+			-- 				end
+			-- 				-- Also write to local settings as backup
+			-- 				self.db.global.requests.maxRequestPercent = v
+			-- 				GBankClassic_Output:Info("Maximum request amount set to %d%% (syncing to guild...)", v)
+			-- 			end,
+			-- 		},
+			-- 		["exampleGroup"] = {
+			-- 			order = 3,
+			-- 			type = "group",
+			-- 			inline = true,
+			-- 			name = "Example calculations",
+			-- 			args = {
+			-- 				["example1"] = {
+			-- 					order = 1,
+			-- 					type = "description",
+			-- 					fontSize = "medium",
+			-- 					name = function()
+			-- 						local pct = self.db.global.requests.maxRequestPercent or 100
+			-- 						local available = 100
+			-- 						local maxRequest = math.max(1, math.floor(available * pct / 100))
+
+			-- 						return string.format("|cff00ff00Current setting: %d%%|r\n\nIf bank has %d items available:\n  Max: |cffffd700%d items|r", pct, available, maxRequest)
+			-- 					end,
+			-- 				},
+			-- 				["example2"] = {
+			-- 					order = 2,
+			-- 					type = "description",
+			-- 					fontSize = "medium",
+			-- 					name = function()
+			-- 						local pct = self.db.global.requests.maxRequestPercent or 100
+			-- 						local available = 1
+			-- 						local maxRequest = math.max(1, math.floor(available * pct / 100))
+
+			-- 						return string.format("If bank has %d item available (gear/single):\n  Max: |cffffd700%d item|r", available, maxRequest)
+			-- 					end,
+			-- 				},
+			-- 			},
+			-- 		},
+			-- 	},
+			-- },
         },
     }
 
@@ -289,7 +453,7 @@ function GBankClassic_Options:Init()
     LibStub("AceConfigDialog-3.0"):AddToBlizOptions("GBankClassic - Revived", "GBankClassic - Revived")
 end
 
-function GBankClassic_Options:InitGuild()
+function Options:InitGuild()
     local player = GBankClassic_Guild:GetPlayer()
     if not GBankClassic_Guild:IsBank(player) then 
         return
@@ -297,6 +461,8 @@ function GBankClassic_Options:InitGuild()
 
     if self.db and self.db.char and self.db.char.bank and self.db.char.bank["enabled"] == nil then
         self.db.char.bank["enabled"] = true
+
+		-- Send an update version of the roster after enabling a new guild bank alt
         GBankClassic_Guild:AuthorRosterData()
     end
 
@@ -305,6 +471,7 @@ function GBankClassic_Options:InitGuild()
 		name = "Bank",
         hidden = function()
             local player = GBankClassic_Guild:GetPlayer()
+			
             return not GBankClassic_Guild:IsBank(player)
         end,
         args = {
@@ -317,6 +484,7 @@ function GBankClassic_Options:InitGuild()
                 set = function(_, v) 
                     self.db.char.bank["enabled"] = v 
                     if v == true then
+						-- Send an update version of the roster after enabling a new guild bank alt
                         GBankClassic_Guild:AuthorRosterData()
                     end
                 end,
@@ -374,39 +542,52 @@ function GBankClassic_Options:InitGuild()
         },
     }
     LibStub("AceConfig-3.0"):RegisterOptionsTable("GBankClassic - Revived/Bank", bankOptions)
-    if self.optionsAdded then return end
+
+    if self.optionsAdded then
+		return
+	end
+
     LibStub("AceConfigDialog-3.0"):AddToBlizOptions("GBankClassic - Revived/Bank", "Bank", "GBankClassic - Revived")
     self.optionsAdded = true
 end
 
-function GBankClassic_Options:GetBankEnabled()
+function Options:GetBankEnabled()
     return self.db.char.bank["enabled"]
 end
 
-function GBankClassic_Options:GetDonationEnabled()
+function Options:GetDonationEnabled()
     return self.db.char.bank["donations"]
 end
 
-function GBankClassic_Options:GetBankReporting()
+function Options:GetBankReporting()
     return self.db.global.bank["report"]
 end
 
-function GBankClassic_Options:GetLogLevel()
+function Options:GetLogLevel()
 	return self.db.global.bank["logLevel"] or LOG_LEVEL.INFO
 end
 
-function GBankClassic_Options:GetMinimapEnabled()
+function Options:GetMinimapEnabled()
     return self.db.char.minimap["enabled"]
 end
 
-function GBankClassic_Options:GetCombatHide()
+function Options:GetCombatHide()
     return self.db.char.combat["hide"]
 end
 
-function GBankClassic_Options:IsSyncProgressMuted()
-	return self.db.global.bank["muteSyncProgress"] or false
-end
+-- function Options:GetMaxRequestPercent()
+-- 	-- Read from guild-synced settings first (officer-configured, syncs to all clients)
+-- 	if GBankClassic_Guild and GBankClassic_Guild.Info and GBankClassic_Guild.Info.settings then
+-- 		return GBankClassic_Guild.Info.settings.maxRequestPercent or 100
+-- 	end
+-- 	-- Fall back to local setting if guild data not loaded yet
+-- 	if not self.db or not self.db.global or not self.db.global.requests then
+-- 		return 100
+-- 	end
+
+-- 	return self.db.global.requests.maxRequestPercent or 100
+-- end
 
-function GBankClassic_Options:Open()
+function Options:Open()
     Settings.OpenToCategory("GBankClassic - Revived")
 end
\ No newline at end of file
diff --git a/Modules/Output.lua b/Modules/Output.lua
index 2807d57..ea60cc4 100644
--- a/Modules/Output.lua
+++ b/Modules/Output.lua
@@ -1,90 +1,78 @@
-GBankClassic_Output = {}
-
--- Current log level (default to INFO)
-GBankClassic_Output.level = LOG_LEVEL.INFO
-
--- Communication debug flag (default to false)
-GBankClassic_Output.commDebug = false
-
--- Dedicated chat frame for debug output
-GBankClassic_Output.debugFrame = nil
-GBankClassic_Output.debugMessageBuffer = {}
-GBankClassic_Output.maxBufferSize = 1000
-
--- Persistent debug log configuration
-GBankClassic_Output.persistentLog = {}
-GBankClassic_Output.persistentLogMaxEntries = 50000 -- Keep last 50,000 entries
-GBankClassic_Output.persistentLogMaxAge = 86400 * 7 -- Keep logs for 7 days (in seconds)
+GBankClassic_Output = GBankClassic_Output or {}
+
+local Output = GBankClassic_Output
+
+Output.level = LOG_LEVEL.INFO
+Output.commDebug = false
+Output.debugFrame = nil
+Output.debugMessageBuffer = {}
+Output.maxBufferSize = 1000
+
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("FCF_DockFrame", "FCF_ResetChatWindows", "FCF_SetLocked", "FCF_SetWindowColor", "FCF_SetWindowName", "GetChatWindowInfo", "ChatFrame_RemoveAllMessageGroups", "ChatFrame_RemoveAllChannels")
+local FCF_DockFrame = upvalues.FCF_DockFrame
+local FCF_ResetChatWindows = upvalues.FCF_ResetChatWindows
+local FCF_SetLocked = upvalues.FCF_SetLocked
+local FCF_SetWindowColor = upvalues.FCF_SetWindowColor
+local FCF_SetWindowName = upvalues.FCF_SetWindowName
+local GetChatWindowInfo = upvalues.GetChatWindowInfo
+local ChatFrame_RemoveAllMessageGroups = upvalues.ChatFrame_RemoveAllMessageGroups
+local ChatFrame_RemoveAllChannels = upvalues.ChatFrame_RemoveAllChannels
+local upvalues = Globals.GetUpvalues("GameFontNormal")
+local GameFontNormal = upvalues.GameFontNormal
+local upvalues = Globals.GetUpvalues("NUM_CHAT_WINDOWS")
+local NUM_CHAT_WINDOWS = upvalues.NUM_CHAT_WINDOWS
 
 -- Category filtering helpers
-function GBankClassic_Output:IsCategoryEnabled(category)
+function Output:IsCategoryEnabled(category)
 	if not GBankClassic_Database or not GBankClassic_Database.db then
 		return false
 	end
+
 	return GBankClassic_Database.db.global.debugCategories[category] == true
 end
 
-function GBankClassic_Output:SetCategoryEnabled(category, enabled)
+function Output:SetCategoryEnabled(category, enabled)
 	if not GBankClassic_Database or not GBankClassic_Database.db then
 		return
 	end
 	GBankClassic_Database.db.global.debugCategories[category] = enabled
 end
 
-function GBankClassic_Output:EnableAllCategories()
+function Output:EnableAllCategories()
 	if not GBankClassic_Database or not GBankClassic_Database.db then
 		return
 	end
+
 	for category, _ in pairs(DEBUG_CATEGORY) do
 		GBankClassic_Database.db.global.debugCategories[category] = true
 	end
 end
 
-function GBankClassic_Output:DisableAllCategories()
+function Output:DisableAllCategories()
 	if not GBankClassic_Database or not GBankClassic_Database.db then
 		return
 	end
+
 	for category, _ in pairs(DEBUG_CATEGORY) do
 		GBankClassic_Database.db.global.debugCategories[category] = false
 	end
 end
 
-function GBankClassic_Output:Init()
-	-- Level will be set from Options after DB is loaded
-	-- Initialize debug log enabled state (default to false - users can enable in options)
-	if GBankClassicDebugLogEnabled == nil then
-		GBankClassicDebugLogEnabled = false
-	end
-	
-	-- Load persistent log from SavedVariables if it exists
-	if GBankClassicDebugLog then
-		self.persistentLog = GBankClassicDebugLog
-		GBankClassic_Output:Debug("SYSTEM", "Loaded %d persistent debug log entries from SavedVariables", #self.persistentLog)
-		-- Clean up old entries on load
-		self:GarbageCollectPersistentLog()
-	else
-		self.persistentLog = {}
-	end
-end
-
-function GBankClassic_Output:SetLevel(level)
+function Output:SetLevel(level)
 	self.level = level
 end
 
-function GBankClassic_Output:GetLevel()
+function Output:GetLevel()
 	return self.level
 end
 
-function GBankClassic_Output:SetCommDebug(enabled)
+function Output:SetCommDebug(enabled)
 	self.commDebug = enabled
 end
 
-function GBankClassic_Output:GetCommDebug()
-	return self.commDebug
-end
-
 -- Store message in buffer
-function GBankClassic_Output:BufferDebugMessage(message)
+function Output:BufferDebugMessage(message)
 	table.insert(self.debugMessageBuffer, message)
 
 	-- Keep buffer size manageable
@@ -94,8 +82,10 @@ function GBankClassic_Output:BufferDebugMessage(message)
 end
 
 -- Redraw all buffered messages to debug frame
-function GBankClassic_Output:RedrawDebugMessages()
-	if not self.debugFrame then return end
+function Output:RedrawDebugMessages()
+	if not self.debugFrame then
+		return
+	end
 
 	self.debugFrame:Clear()
 	for _, msg in ipairs(self.debugMessageBuffer) do
@@ -104,7 +94,7 @@ function GBankClassic_Output:RedrawDebugMessages()
 end
 
 -- Create or get dedicated debug chat frame
-function GBankClassic_Output:GetDebugFrame()
+function Output:GetDebugFrame()
 	-- Return cached frame if we have it
 	if self.debugFrame then
 		return self.debugFrame
@@ -119,13 +109,14 @@ function GBankClassic_Output:GetDebugFrame()
 			-- Ensure OnShow hook is set to redraw messages when tab becomes visible
 			if not self.debugFrame.gbankClassicHooked then
 				self.debugFrame:HookScript("OnShow", function()
-					GBankClassic_Output:RedrawDebugMessages()
+					self:RedrawDebugMessages()
 				end)
 				self.debugFrame.gbankClassicHooked = true
 			end
 
 			-- Restore buffered messages when frame is found
 			self:RedrawDebugMessages()
+
 			return self.debugFrame
 		end
 	end
@@ -134,7 +125,7 @@ function GBankClassic_Output:GetDebugFrame()
 end
 
 -- Create dedicated debug chat tab
-function GBankClassic_Output:CreateDebugTab()
+function Output:CreateDebugTab()
 	-- Check if tab already exists
 	for i = 1, NUM_CHAT_WINDOWS do
 		local name = GetChatWindowInfo(i)
@@ -151,7 +142,7 @@ function GBankClassic_Output:CreateDebugTab()
 			-- Hook OnShow to redraw messages when tab becomes visible
 			if not self.debugFrame.gbankClassicHooked then
 				self.debugFrame:HookScript("OnShow", function()
-					GBankClassic_Output:RedrawDebugMessages()
+					self:RedrawDebugMessages()
 				end)
 				self.debugFrame.gbankClassicHooked = true
 			end
@@ -163,6 +154,7 @@ function GBankClassic_Output:CreateDebugTab()
 			self:RedrawDebugMessages()
 
 			GBankClassic_Core:Print("GBankClassicDebug tab found and shown (ChatFrame"..i..")")
+
 			return true
 		end
 	end
@@ -184,6 +176,7 @@ function GBankClassic_Output:CreateDebugTab()
 	if not frameIndex then
 		GBankClassic_Core:Print("|cffff0000Failed to create debug tab: no available chat frames|r")
 		GBankClassic_Core:Print("Try using an existing chat frame instead")
+
 		return false
 	end
 
@@ -216,7 +209,7 @@ function GBankClassic_Output:CreateDebugTab()
 	-- Hook OnShow to redraw messages when tab becomes visible
 	if not frame.gbankClassicHooked then
 		frame:HookScript("OnShow", function()
-			GBankClassic_Output:RedrawDebugMessages()
+			self:RedrawDebugMessages()
 		end)
 		frame.gbankClassicHooked = true
 	end
@@ -228,11 +221,12 @@ function GBankClassic_Output:CreateDebugTab()
 
 	GBankClassic_Core:Print("Created GBankClassicDebug chat tab (ChatFrame"..frameIndex..")")
 	GBankClassic_Core:Print("You can now right-click the tab to customize or close it")
+
 	return true
 end
 
 -- Remove debug tab
-function GBankClassic_Output:RemoveDebugTab()
+function Output:RemoveDebugTab()
 	for i = 1, NUM_CHAT_WINDOWS do
 		local name = GetChatWindowInfo(i)
 		if name == "GBankClassicDebug" then
@@ -243,19 +237,21 @@ function GBankClassic_Output:RemoveDebugTab()
 			frame:Hide()
 			self.debugFrame = nil
 			GBankClassic_Core:Print("Removed GBankClassicDebug tab - please /reload to complete removal")
+
 			return true
 		end
 	end
 
 	GBankClassic_Core:Print("GBankClassicDebug tab not found")
+
 	return false
 end
 
 -- Core logging function
 -- If fmt contains %, uses string.format with varargs
 -- Otherwise concatenates all arguments with spaces
-local function Log(level, prefix, fmt, ...)
-	if level < GBankClassic_Output:GetLevel() and level ~= LOG_LEVEL.RESPONSE then
+local function log(level, prefix, fmt, ...)
+	if level < Output.level and level ~= LOG_LEVEL.RESPONSE then
 		return false
 	end
 
@@ -278,7 +274,7 @@ local function Log(level, prefix, fmt, ...)
 
 	-- If debug level and we have a debug frame, use it
 	if level == LOG_LEVEL.DEBUG then
-		local debugFrame = GBankClassic_Output:GetDebugFrame()
+		local debugFrame = Output:GetDebugFrame()
 		if debugFrame then
 			local fullMessage = "GBankClassic: "
 			if prefix then
@@ -288,10 +284,11 @@ local function Log(level, prefix, fmt, ...)
 			end
 
 			-- Store in buffer for persistence
-			GBankClassic_Output:BufferDebugMessage(fullMessage)
+			Output:BufferDebugMessage(fullMessage)
 
 			-- Add to frame
 			debugFrame:AddMessage(fullMessage)
+
 			return true
 		end
 	end
@@ -303,22 +300,11 @@ local function Log(level, prefix, fmt, ...)
 		GBankClassic_Core:Print(message)
 	end
 
-	-- Always store debug-level messages in persistent log (if debug logging enabled)
-	if level == LOG_LEVEL.DEBUG and GBankClassicDebugLogEnabled then
-		local fullMessage = "GBankClassic: "
-		if prefix then
-			fullMessage = fullMessage .. prefix .. " " .. message
-		else
-			fullMessage = fullMessage .. message
-		end
-		GBankClassic_Output:AddToPersistentLog(fullMessage)
-	end
-
 	return true
 end
 
--- Debug: development/troubleshooting details
-function GBankClassic_Output:Debug(fmt, ...)
+-- Development/troubleshooting details
+function Output:Debug(fmt, ...)
 	-- Check if first parameter is a category
 	if type(fmt) == "string" and DEBUG_CATEGORY[fmt] then
 		local category = fmt
@@ -326,135 +312,48 @@ function GBankClassic_Output:Debug(fmt, ...)
 		if not self:IsCategoryEnabled(category) then
 			return false
 		end
+
 		-- Shift parameters: first arg after category becomes the format string
 		local actualFmt = select(1, ...)
 		local args = {select(2, ...)}
-		return Log(LOG_LEVEL.DEBUG, "|cff888888[DEBUG]|r", actualFmt, unpack(args))
+		
+		return log(LOG_LEVEL.DEBUG, "|cff888888[DEBUG]|r", actualFmt, unpack(args))
 	end
 	
 	-- Fallback: no category specified
-	return Log(LOG_LEVEL.DEBUG, "|cff888888[DEBUG]|r", fmt, ...)
+	return log(LOG_LEVEL.DEBUG, "|cff888888[DEBUG]|r", fmt, ...)
 end
 
 -- DebugComm: protocol communication details (controlled by COMMS category)
-function GBankClassic_Output:DebugComm(fmt, ...)
-	-- Only show if debug level is active AND COMMS category is enabled
-	if GBankClassic_Output.level < LOG_LEVEL.DEBUG then
+function Output:DebugComm(fmt, ...)
+	-- Only show if debug level is active and the COMMS category is enabled
+	if Output.level < LOG_LEVEL.DEBUG then
 		return false
 	end
 	-- Check if COMMS category is enabled
 	if not self:IsCategoryEnabled("COMMS") then
 		return false
 	end
-	return Log(LOG_LEVEL.DEBUG, "|cff888888[DEBUG] (comm)|r", fmt, ...)
+	
+	return log(LOG_LEVEL.DEBUG, "|cff888888[DEBUG] (comm)|r", fmt, ...)
 end
 
 -- Info: sync status, normal operations
-function GBankClassic_Output:Info(fmt, ...)
-	return Log(LOG_LEVEL.INFO, nil, fmt, ...)
+function Output:Info(fmt, ...)
+	return log(LOG_LEVEL.INFO, nil, fmt, ...)
 end
 
 -- Warn: something unexpected but recoverable
-function GBankClassic_Output:Warn(fmt, ...)
-	return Log(LOG_LEVEL.WARN, "|cffffcc00[WARN]|r", fmt, ...)
+function Output:Warn(fmt, ...)
+	return log(LOG_LEVEL.WARN, "|cffffcc00[WARN]|r", fmt, ...)
 end
 
 -- Error: something failed
-function GBankClassic_Output:Error(fmt, ...)
-	return Log(LOG_LEVEL.ERROR, "|cffff4444[ERROR]|r", fmt, ...)
+function Output:Error(fmt, ...)
+	return log(LOG_LEVEL.ERROR, "|cffff4444[ERROR]|r", fmt, ...)
 end
 
 -- Response: response to user commands (always shown)
-function GBankClassic_Output:Response(fmt, ...)
-	return Log(LOG_LEVEL.RESPONSE, nil, fmt, ...)
-end
-
--- Add entry to persistent debug log with timestamp
-function GBankClassic_Output:AddToPersistentLog(message)
-	local entry = {
-		timestamp = time(),
-		message = message
-	}
-	table.insert(self.persistentLog, entry)
-
-	-- Simple circular buffer: remove oldest if we exceed max entries
-	while #self.persistentLog > self.persistentLogMaxEntries do
-		table.remove(self.persistentLog, 1)
-	end
-end
-
--- Garbage collect old entries from persistent log
-function GBankClassic_Output:GarbageCollectPersistentLog()
-	local currentTime = time()
-	local cutoffTime = currentTime - self.persistentLogMaxAge
-	local removed = 0
-
-	-- Remove entries older than max age
-	local i = 1
-	while i <= #self.persistentLog do
-		if self.persistentLog[i].timestamp < cutoffTime then
-			table.remove(self.persistentLog, i)
-			removed = removed + 1
-		else
-			i = i + 1
-		end
-	end
-
-	if removed > 0 then
-		GBankClassic_Output:Debug("SYSTEM", "Garbage collected %d old debug log entries (older than %d days)", removed, self.persistentLogMaxAge / 86400)
-	end
-end
-
--- Save persistent log to SavedVariables
-function GBankClassic_Output:SavePersistentLog()
-	-- Run garbage collection before saving
-	self:GarbageCollectPersistentLog()
-
-	-- Write to global SavedVariable
-	GBankClassicDebugLog = self.persistentLog
-
-	GBankClassic_Output:Debug("SYSTEM", "Saved %d persistent debug log entries to SavedVariables", #self.persistentLog)
-end
-
--- Export persistent log to formatted string for viewing
-function GBankClassic_Output:ExportPersistentLog(maxEntries)
-	maxEntries = maxEntries or 100
-	local output = {}
-	local startIdx = math.max(1, #self.persistentLog - maxEntries + 1)
-
-	for i = startIdx, #self.persistentLog do
-		local entry = self.persistentLog[i]
-		local timeStr = date("%Y-%m-%d %H:%M:%S", entry.timestamp)
-		table.insert(output, string.format("[%s] %s", timeStr, entry.message))
-	end
-
-	return table.concat(output, "\n")
-end
-
--- Export persistent log in compact format (no formatting overhead)
-function GBankClassic_Output:ExportPersistentLogCompact(maxEntries, searchFilter)
-	maxEntries = maxEntries or 1000
-	local output = {}
-	local startIdx = math.max(1, #self.persistentLog - maxEntries + 1)
-	local count = 0
-
-	for i = startIdx, #self.persistentLog do
-		local entry = self.persistentLog[i]
-		-- Apply search filter if provided
-		if not searchFilter or string.find(entry.message:lower(), searchFilter:lower(), 1, true) then
-			local timeStr = date("%H:%M:%S", entry.timestamp)  -- Compact time format
-			table.insert(output, timeStr .. " " .. entry.message)
-			count = count + 1
-		end
-	end
-
-	return table.concat(output, "\n"), count
-end
-
--- Clear persistent log
-function GBankClassic_Output:ClearPersistentLog()
-	local count = #self.persistentLog
-	self.persistentLog = {}
-	GBankClassicDebugLog = {}
-	GBankClassic_Output:Response("Cleared %d persistent debug log entries", count)
+function Output:Response(fmt, ...)
+	return log(LOG_LEVEL.RESPONSE, nil, fmt, ...)
 end
\ No newline at end of file
diff --git a/Modules/Performance.lua b/Modules/Performance.lua
deleted file mode 100644
index 8bd24a3..0000000
--- a/Modules/Performance.lua
+++ /dev/null
@@ -1,257 +0,0 @@
--- Performance metrics tracking
--- Tracks event frequency, operation timing, and resource usage for diagnostic purposes
-
-GBankClassic_Performance = {}
-local Performance = GBankClassic_Performance
-
--- Configuration
-local perfMetricsMaxSessions = 10 -- Maximum number of sessions to keep
-local perfMetricsMaxAge = 86400 * 30 -- 30 days in seconds
-
--- Garbage collect old performance metrics sessions
-function Performance:GarbageCollectSessions()
-	if not GBankClassicPerfMetrics then return end
-	
-	local currentTime = time()
-	local cutoffTime = currentTime - perfMetricsMaxAge
-	
-	local removed = 0
-	for i = #GBankClassicPerfMetrics, 1, -1 do
-		local session = GBankClassicPerfMetrics[i]
-		if session.sessionStart and session.sessionStart < cutoffTime then
-			table.remove(GBankClassicPerfMetrics, i)
-			removed = removed + 1
-		end
-	end
-	
-	if removed > 0 and GBankClassic_Output then
-		GBankClassic_Output:Debug("SYSTEM", string.format("[PERF] Garbage collected %d old session(s)", removed))
-	end
-end
-
--- Initialize performance metrics on addon load
-function Performance:Initialize()
-	if not GBankClassicPerfMetrics then
-		GBankClassicPerfMetrics = {}
-	end
-	
-	-- Run garbage collection on initialization
-	self:GarbageCollectSessions()
-	
-	-- Initialize enabled state (default to false - users can enable in options)
-	if GBankClassicPerfMetricsEnabled == nil then
-		GBankClassicPerfMetricsEnabled = false
-	end
-	
-	-- Create new session
-	local sessionStart = time()
-	local session = {
-		sessionStart = sessionStart,
-		sessionId = string.format("%s_%d", date("%Y%m%d_%H%M%S"), sessionStart),
-		
-		-- Event counters
-		events = {
-			GUILD_ROSTER_UPDATE = 0,
-			PLAYER_ENTERING_WORLD = 0,
-			CHAT_MSG_ADDON = 0,
-			MAIL_INBOX_UPDATE = 0,
-			BANKFRAME_OPENED = 0,
-			BANKFRAME_CLOSED = 0,
-		},
-		
-		-- Operation counters
-		operations = {
-			RefreshOnlineCache = 0,
-			InvalidateBanksCache = 0,
-			GetBanks = 0,
-			ComputeDelta = 0,
-			ApplyDelta = 0,
-			ReceiveAltData = 0,
-			NormalizeRequestList = 0,
-			ItemHighlightUpdate = 0,
-		},
-		
-		-- Timing data (cumulative ms)
-		timing = {
-			RefreshOnlineCache = 0,
-			GetBanks = 0,
-			ComputeDelta = 0,
-			ApplyDelta = 0,
-			NormalizeRequestList = 0,
-			ItemHighlightUpdate = 0,
-		},
-		
-		-- Memory snapshots (in KB)
-		memory = {},
-		
-		-- Peak values
-		peaks = {
-			eventsPerSecond = 0,
-			operationsPerSecond = 0,
-			longestOperation = { name = nil, duration = 0 },
-		},
-	}
-	
-	-- Store in global saved variables
-	table.insert(GBankClassicPerfMetrics, session)
-	
-	-- Keep only last N sessions (circular buffer)
-	while #GBankClassicPerfMetrics > perfMetricsMaxSessions do
-		table.remove(GBankClassicPerfMetrics, 1)
-	end
-	
-	-- Store reference to current session
-	self.currentSession = session
-	self.sessionStartTime = GetTime()
-end
-
--- Track an event firing
-function Performance:RecordEvent(eventName)
-	if not GBankClassicPerfMetricsEnabled then return end
-	if not self.currentSession then return end
-	if self.currentSession.events[eventName] then
-		self.currentSession.events[eventName] = self.currentSession.events[eventName] + 1
-	end
-end
-
--- Track an operation execution with timing
-function Performance:RecordOperation(operationName, durationMs)
-	if not GBankClassicPerfMetricsEnabled then return end
-	if not self.currentSession then return end
-	
-	if self.currentSession.operations[operationName] then
-		self.currentSession.operations[operationName] = self.currentSession.operations[operationName] + 1
-	end
-	
-	if durationMs and self.currentSession.timing[operationName] then
-		self.currentSession.timing[operationName] = self.currentSession.timing[operationName] + durationMs
-		
-		-- Track peak
-		if durationMs > self.currentSession.peaks.longestOperation.duration then
-			self.currentSession.peaks.longestOperation = {
-				name = operationName,
-				duration = durationMs,
-			}
-		end
-	end
-end
-
--- Take a memory snapshot
-function Performance:RecordMemory(label)
-	if not GBankClassicPerfMetricsEnabled then return end
-	if not self.currentSession then return end
-	
-	UpdateAddOnMemoryUsage()
-	local memory = GetAddOnMemoryUsage("GBankClassic")
-	
-	table.insert(self.currentSession.memory, {
-		timestamp = GetTime() - self.sessionStartTime,
-		label = label,
-		memoryKB = memory,
-	})
-	
-	-- Keep only last 50 snapshots
-	while #self.currentSession.memory > 50 do
-		table.remove(self.currentSession.memory, 1)
-	end
-end
-
--- Helper to wrap a function with timing
-function Performance:WrapFunction(operationName, func)
-	return function(...)
-		local startTime = debugprofilestop()
-		local results = {func(...)}
-		local duration = debugprofilestop() - startTime
-		self:RecordOperation(operationName, duration)
-		return unpack(results)
-	end
-end
-
--- Track a function execution with timing (returns the function's return values)
-function Performance:Track(operationName, func)
-	if not GBankClassicPerfMetricsEnabled then
-		return func()
-	end
-	
-	local startTime = debugprofilestop()
-	local results = {func()}
-	local duration = debugprofilestop() - startTime
-	self:RecordOperation(operationName, duration)
-	return unpack(results)
-end
-
--- Get current session stats
-function Performance:GetCurrentStats()
-	if not self.currentSession then return nil end
-	
-	local sessionDuration = GetTime() - self.sessionStartTime
-	local stats = {
-		sessionId = self.currentSession.sessionId,
-		duration = sessionDuration,
-		events = {},
-		operations = {},
-		timing = {},
-		memory = self.currentSession.memory,
-		peaks = self.currentSession.peaks,
-	}
-	
-	-- Calculate rates for events
-	for event, count in pairs(self.currentSession.events) do
-		stats.events[event] = {
-			count = count,
-			perMinute = (count / sessionDuration) * 60,
-		}
-	end
-	
-	-- Calculate rates and averages for operations
-	for operation, count in pairs(self.currentSession.operations) do
-		local totalTime = self.currentSession.timing[operation] or 0
-		stats.operations[operation] = {
-			count = count,
-			perMinute = (count / sessionDuration) * 60,
-			avgMs = count > 0 and (totalTime / count) or 0,
-			totalMs = totalTime,
-		}
-	end
-	
-	return stats
-end
-
--- Print performance report
-function Performance:PrintReport()
-	local stats = self:GetCurrentStats()
-	if not stats then
-		GBankClassic_Output:Response("No performance data available")
-		return
-	end
-	
-	GBankClassic_Output:Response("|cffffff00=== Performance report ===|r")
-	GBankClassic_Output:Response("Session: %s (%.1f minutes)", stats.sessionId, stats.duration / 60)
-	
-	GBankClassic_Output:Response("|cffffff00Events:|r")
-	for event, data in pairs(stats.events) do
-		if data.count > 0 then
-			GBankClassic_Output:Response("  %s: %d (%.1f/min)", event, data.count, data.perMinute)
-		end
-	end
-	
-	GBankClassic_Output:Response("|cffffff00Operations:|r")
-	for operation, data in pairs(stats.operations) do
-		if data.count > 0 then
-			GBankClassic_Output:Response("  %s: %d calls, %.2f ms avg (%.1f/min)", 
-				operation, data.count, data.avgMs, data.perMinute)
-		end
-	end
-	
-	if stats.peaks.longestOperation.name then
-		GBankClassic_Output:Response("|cffffff00Peak:|r Longest operation: %s (%.2f ms)", 
-			stats.peaks.longestOperation.name, stats.peaks.longestOperation.duration)
-	end
-	
-	if #stats.memory > 0 then
-		local firstMem = stats.memory[1].memoryKB
-		local lastMem = stats.memory[#stats.memory].memoryKB
-		GBankClassic_Output:Response("|cffffff00Memory:|r %.1f KB  %.1f KB (%.1f KB growth)", 
-			firstMem, lastMem, lastMem - firstMem)
-	end
-end
\ No newline at end of file
diff --git a/Modules/RequestLog.lua b/Modules/RequestLog.lua
new file mode 100644
index 0000000..8a0f7c6
--- /dev/null
+++ b/Modules/RequestLog.lua
@@ -0,0 +1,1580 @@
+GBankClassic_Guild = GBankClassic_Guild or {}
+
+local Guild = GBankClassic_Guild
+
+-- -- Throttle warnings to prevent spam (only warn once per session per type)
+-- local warnedAbout = {
+-- 	invalidRequestVersion = false,
+-- 	corruptedTimestamps = {}, -- Track by request ID
+-- }
+
+-- --[[
+-- Request sync and storage
+-- ========================
+-- This module owns the request lifecycle and synchronization rules
+-- It attaches methods to GBankClassic_Guild, but keeps the logic isolated
+
+-- Data model (GBankClassic_Guild.Info):
+-- - requests: map of request ID -> request record (canonical state for UI/logic).
+-- - requestsVersion: max updatedAt timestamp for quick freshness checks.
+-- - requestsTombstones: map requestId -> delete timestamp.
+
+-- Request record schema:
+-- {
+--   id, date, updatedAt, statusUpdatedAt,
+--   requester, bank, item, quantity, fulfilled,
+--   status = "open" | "fulfilled" | "cancelled" | "complete",
+--   notes
+-- }
+
+-- Conflict resolution (merge-based sync):
+-- - Each request is merged using last-writer-wins based on updatedAt.
+-- - Tombstones win over requests with updatedAt <= tombstone timestamp.
+-- - Fulfillment uses max() to ensure idempotency.
+
+-- Sync flow:
+-- - Version broadcast includes requestsVersion + requests hash.
+-- - Full snapshots and by-id fetches are merged per-request.
+-- - Mutations are broadcast as entries and applied directly.
+-- ]]
+
+-- -- Request status constants
+-- local VALID_REQUEST_STATUS = {
+-- 	open = true,
+-- 	fulfilled = true,
+-- 	cancelled = true,
+-- 	complete = true,
+-- }
+
+-- local function generateRequestId(actor)
+-- 	local rand = string.format("%06x", math.random(0, 0xFFFFFF))
+
+-- 	return string.format("%s:%s", actor or "unknown", rand)
+-- end
+
+-- -- Normalize incoming request data and ensure required fields exist.
+-- local function sanitizeRequest(req)
+-- 	if not req or type(req) ~= "table" then
+-- 		return nil
+-- 	end
+
+-- 	-- Reject empty required fields (Phase 1 validation)
+-- 	local item = req.item and tostring(req.item) or ""
+-- 	if item == "" then
+-- 		GBankClassic_Output:Debug("REQUESTS", "Rejected request: empty item field")
+
+-- 		return nil
+-- 	end
+
+-- 	local requesterRaw = req.requester and tostring(req.requester) or ""
+-- 	if requesterRaw == "" or requesterRaw == "Unknown" then
+-- 		GBankClassic_Output:Debug("REQUESTS", "Rejected request: invalid requester '%s'", requesterRaw)
+
+-- 		return nil
+-- 	end
+
+-- 	local bankRaw = req.bank and tostring(req.bank) or ""
+-- 	if bankRaw == "" then
+-- 		GBankClassic_Output:Debug("REQUESTS", "Rejected request: empty bank field")
+
+-- 		return nil
+-- 	end
+
+-- 	local now = GetServerTime()
+
+-- 	local quantity = math.max(tonumber(req.quantity or 0) or 0, 0)
+-- 	if quantity == 0 then
+-- 		GBankClassic_Output:Debug("REQUESTS", "Rejected request: quantity is zero")
+
+-- 		return nil
+-- 	end
+
+-- 	-- Reject requests where ID contains different item name (corrupted edited requests)
+-- 	if req.id and type(req.id) == "string" then
+-- 		-- ID format: "bank-requester-itemName-timestamp" or variations
+-- 		-- Extract item name from ID by finding the pattern between requester and timestamp
+-- 		-- Pattern: everything after the second "-realm-" and before the last timestamp portion
+-- 		local idParts = {}
+-- 		for part in string.gmatch(req.id, "[^-]+") do
+-- 			table.insert(idParts, part)
+-- 		end
+		
+-- 		-- ID typically has 6+ parts: bank, realm, requester, realm, itemname(s), timestamp(s)
+-- 		-- Try to extract item name from middle portion (skip first 4 parts for bank/requester)
+-- 		if #idParts >= 5 then
+-- 			-- Find where the item name ends (before timestamp-like numbers)
+-- 			local itemNameParts = {}
+-- 			for i = 5, #idParts do
+-- 				local part = idParts[i]
+-- 				-- Stop if we hit a pure numeric timestamp (8+ digits) or very short suffix
+-- 				if string.match(part, "^%d%d%d%d%d%d%d%d+") or #part <= 3 then
+-- 					break
+-- 				end
+-- 				table.insert(itemNameParts, part)
+-- 			end
+			
+-- 			if #itemNameParts > 0 then
+-- 				local itemInId = table.concat(itemNameParts, "-")
+-- 				-- Compare (case-insensitive, handle spaces vs dashes)
+-- 				local normalizedItem = string.lower(string.gsub(item, "%s+", ""))
+-- 				local normalizedIdItem = string.lower(string.gsub(itemInId, "%s+", ""))
+				
+-- 				if normalizedItem ~= normalizedIdItem then
+-- 					GBankClassic_Output:Debug("REQUESTS", "Rejected request: ID contains '%s' but item is '%s' (corrupted/edited request)", itemInId, item)
+
+-- 					return nil
+-- 				end
+-- 			end
+-- 		end
+-- 	end
+
+-- 	local fulfilled = math.max(tonumber(req.fulfilled or 0) or 0, 0)
+-- 	if quantity > 0 then
+-- 		fulfilled = math.min(fulfilled, quantity)
+-- 	end
+
+-- 	local bank = Guild:NormalizeName(bankRaw)
+-- 	local requester = Guild:NormalizeName(requesterRaw)
+
+-- 	-- Validate timestamps to prevent corruption
+-- 	-- Max 32-bit signed integer (Jan 19, 2038) - any larger value is corrupted
+-- 	local MAX_TIMESTAMP = 2147483647
+-- 	local function validateTimestamp(ts, fallback)
+-- 		local num = tonumber(ts) or fallback
+-- 		-- If timestamp is too large (corrupted), use fallback instead
+-- 		if num > MAX_TIMESTAMP then
+-- 			return fallback
+-- 		end
+
+-- 		return num
+-- 	end
+
+-- 	local updatedAt = validateTimestamp(req.updatedAt or req.date or now, now)
+-- 	local dateVal = validateTimestamp(req.date or updatedAt, updatedAt)
+-- 	local statusUpdatedAt = validateTimestamp(req.statusUpdatedAt or updatedAt, updatedAt)
+-- 	local status = req.status
+-- 	if not VALID_REQUEST_STATUS[status] then
+-- 		status = "open"
+-- 	end
+-- 	if quantity > 0 and fulfilled >= quantity and status ~= "cancelled" and status ~= "complete" then
+-- 		status = "fulfilled"
+-- 	end
+
+-- 	local id = req.id or generateRequestId()
+
+-- 	return { id = id, date = dateVal, updatedAt = updatedAt, statusUpdatedAt = statusUpdatedAt, requester = requester, bank = bank, item = item, quantity = quantity, fulfilled = fulfilled, status = status, notes = tostring(req.notes or "") }
+-- end
+
+-- -- Expose normalization for other modules that need a safe view of request data.
+-- function Guild:SanitizeRequest(req)
+-- 	return sanitizeRequest(req)
+-- end
+
+-- -- Request map helpers: internal storage is now a map keyed by request ID.
+-- -- Wire format remains an array for backwards compatibility.
+-- local function requestsToArray(map)
+-- 	local arr = {}
+-- 	for _, req in pairs(map or {}) do
+-- 		if req and req.id then
+-- 			table.insert(arr, req)
+-- 		end
+-- 	end
+
+-- 	return arr
+-- end
+
+-- local function requestsToMap(arr)
+-- 	local map = {}
+-- 	for _, req in ipairs(arr or {}) do
+-- 		if req and req.id then
+-- 			map[req.id] = req
+-- 		end
+-- 	end
+
+-- 	return map
+-- end
+
+-- -- Compute a stable hash of requests + tombstones for sync comparison.
+-- local function computeRequestsHash(requests, tombstones)
+-- 	local parts = {}
+
+-- 	for id, req in pairs(requests or {}) do
+-- 		local updatedAt = tonumber(req.updatedAt or req.date or 0) or 0
+-- 		table.insert(parts, string.format("r:%s:%d", tostring(id), updatedAt))
+-- 	end
+
+-- 	for id, ts in pairs(tombstones or {}) do
+-- 		local deletedAt = tonumber(ts or 0) or 0
+-- 		if deletedAt > 0 then
+-- 			table.insert(parts, string.format("t:%s:%d", tostring(id), deletedAt))
+-- 		end
+-- 	end
+
+-- 	table.sort(parts)
+-- 	local combined = table.concat(parts, "|")
+-- 	local sum = 0
+-- 	local len = #combined
+-- 	for i = 1, len do
+-- 		local byte = string.byte(combined, i)
+-- 		sum = (sum * 31 + byte) % 2147483647
+-- 	end
+-- 	sum = (sum * 31 + len) % 2147483647
+
+-- 	return sum
+-- end
+
+-- -- Calculate requestsVersion as max updatedAt across all requests
+-- local function calculateRequestsVersion(requests)
+-- 	local maxVersion = 0
+-- 	for _, req in pairs(requests or {}) do
+-- 		local updatedAt = tonumber(req.updatedAt or req.date or 0) or 0
+-- 		if updatedAt > maxVersion then
+-- 			maxVersion = updatedAt
+-- 		end
+-- 	end
+
+-- 	return maxVersion
+-- end
+
+
+-- -- Merge a single request using last-writer-wins.
+-- -- Returns: "added", "updated", "kept", "tombstoned", or nil on error
+-- local function mergeRequest(requests, tombstones, id, incoming)
+-- 	if not incoming or not id then
+-- 		GBankClassic_Output:Debug("SYNC", "mergeRequest: Invalid input (id=%s, incoming=%s)", tostring(id), tostring(incoming ~= nil))
+
+-- 		return nil
+-- 	end
+
+-- 	local clean = sanitizeRequest(incoming)
+-- 	if not clean then
+-- 		GBankClassic_Output:Debug("SYNC", "mergeRequest: sanitizeRequest failed for id=%s", tostring(id))
+
+-- 		return nil
+-- 	end
+
+-- 	local incomingTs = tonumber(clean.updatedAt or clean.date or 0) or 0
+-- 	local tombstoneTs = tonumber((tombstones or {})[id] or 0) or 0
+
+-- 	-- Check tombstone
+-- 	if tombstoneTs > 0 and incomingTs <= tombstoneTs then
+-- 		GBankClassic_Output:Debug("SYNC", "mergeRequest: Tombstoned - id=%s (tombstoneTs=%d, incomingTs=%d)", id, tombstoneTs, incomingTs)
+
+-- 		return "tombstoned"
+-- 	end
+
+-- 	local existing = requests[id]
+-- 	if existing then
+-- 		local existingTs = tonumber(existing.updatedAt or existing.date or 0) or 0
+-- 		local existingStatusTs = tonumber(existing.statusUpdatedAt or existingTs or 0) or 0
+-- 		local incomingStatusTs = tonumber(clean.statusUpdatedAt or 0) or 0 -- Don't fall back to incomingTs!
+		
+-- 		-- Status priority check: Don't allow reopening cancelled/completed requests
+-- 		-- Cancel/complete are terminal states that should not be overwritten by "open" status
+-- 		local existingIsTerminal = (existing.status == "cancelled" or existing.status == "complete")
+-- 		local incomingIsTerminal = (clean.status == "cancelled" or clean.status == "complete")
+		
+-- 		if existingIsTerminal and not incomingIsTerminal then
+-- 			-- Existing is cancelled/complete, incoming is open/fulfilled
+-- 			-- Only accept incoming if it has newer statusUpdatedAt (explicit status change)
+-- 			-- If incoming has no statusUpdatedAt, treat it as old/unknown (don't reopen)
+-- 			if incomingStatusTs <= existingStatusTs then
+-- 				GBankClassic_Output:Debug("SYNC", "mergeRequest: Rejected - Trying to reopen %s status (id=%s, existing %s@%d, incoming %s@%d)", existing.status, id, existing.status, existingStatusTs, clean.status, incomingStatusTs)
+
+-- 				return "kept"
+-- 			end
+-- 			-- If incoming has newer status timestamp, it's an explicit reopening - allow it
+-- 			GBankClassic_Output:Debug("SYNC", "mergeRequest: Allowing explicit status change from %s to %s (id=%s, statusUpdatedAt %d -> %d)", existing.status, clean.status, id, existingStatusTs, incomingStatusTs)
+-- 		end
+		
+-- 		if not existingIsTerminal and incomingIsTerminal then
+-- 			-- Incoming is trying to cancel/complete an open request
+-- 			GBankClassic_Output:Debug("SYNC", "mergeRequest: Applying terminal status change %s -> %s (id=%s, statusUpdatedAt %d -> %d, updatedAt %d -> %d)", existing.status, clean.status, id, existingStatusTs, incomingStatusTs, existingTs, incomingTs)
+-- 		end
+		
+-- 		-- Don't update timestamps on cancelled/complete requests
+-- 		-- Unless status actually changed (prevents "zombie" date refreshing)
+-- 		if existingIsTerminal and incomingIsTerminal then
+-- 			-- Both are terminal states - only reject if status and general timestamp unchanged
+-- 			if incomingStatusTs <= existingStatusTs and incomingTs <= existingTs then
+-- 				-- Same terminal state, same timestamps - just a refresh, reject it
+-- 				GBankClassic_Output:Debug("SYNC", "mergeRequest: Rejected - Timestamp refresh on %s status (id=%s, existing@%d, incoming@%d)", existing.status, id, existingStatusTs, incomingStatusTs)
+
+-- 				return "kept"
+-- 			end
+-- 			-- Otherwise fall through to normal timestamp comparison (allows quantity updates, etc.)
+-- 			GBankClassic_Output:Debug("SYNC", "mergeRequest: Allowing terminal state update (id=%s, status=%s, statusTs %d -> %d, ts %d -> %d)", id, clean.status, existingStatusTs, incomingStatusTs, existingTs, incomingTs)
+-- 		end
+		
+-- 		if incomingTs > existingTs then
+-- 			requests[id] = clean
+-- 			GBankClassic_Output:Debug("SYNC", "mergeRequest: Updated - id=%s, status %s->%s, updatedAt %d->%d", id, existing.status, clean.status, existingTs, incomingTs)
+
+-- 			return "updated"
+-- 		else
+-- 			GBankClassic_Output:Debug("SYNC", "mergeRequest: Kept - id=%s (incoming older: %d <= %d)", id, incomingTs, existingTs)
+
+-- 			return "kept"
+-- 		end
+-- 	else
+-- 		requests[id] = clean
+-- 		GBankClassic_Output:Debug("SYNC", "mergeRequest: Added - id=%s, status=%s, updatedAt=%d", id, clean.status, incomingTs)
+
+-- 		return "added"
+-- 	end
+-- end
+
+-- -- Initialization and normalization.
+-- function Guild:EnsureRequestsInitialized()
+-- 	if not self.Info then
+-- 		return
+-- 	end
+
+-- 	-- Initialize requests map
+-- 	if not self.Info.requests then
+-- 		self.Info.requests = {}
+-- 	end
+
+-- 	-- Migrate from array to map format if needed (detect by checking for numeric keys)
+-- 	if self.Info.requests[1] ~= nil then
+-- 		GBankClassic_Output:Debug("REQUESTS", "Converting requests from array to map format")
+-- 		self.Info.requests = requestsToMap(self.Info.requests)
+-- 	end
+
+-- 	-- Initialize tombstones
+-- 	if not self.Info.requestsTombstones then
+-- 		self.Info.requestsTombstones = {}
+-- 	end
+
+-- 	-- Migrate away from log-based storage
+-- 	-- The log is no longer used - we now use simple delta-based sync
+-- 	if self.Info.requestLog or self.Info.requestLogSeq or self.Info.requestLogApplied then
+-- 		GBankClassic_Output:Debug("REQUESTS", "Removing deprecated request log data")
+-- 		self.Info.requestLog = nil
+-- 		self.Info.requestLogSeq = nil
+-- 		self.Info.requestLogApplied = nil
+-- 		-- Also clear legacy field names
+-- 		self.Info.requestsOps = nil
+-- 		self.Info.requestsOpSeq = nil
+-- 		self.Info.requestsOpApplied = nil
+-- 	end
+
+-- 	-- Clear runtime log indices (no longer used)
+-- 	self.requestLogIndex = nil
+-- 	self.requestLogByActor = nil
+
+-- 	-- Remove deprecated requestIdSeq (now using random IDs)
+-- 	if self.Info.requestIdSeq then
+-- 		self.Info.requestIdSeq = nil
+-- 	end
+
+-- 	-- Calculate version from requests if not set
+-- 	if not self.Info.requestsVersion or self.Info.requestsVersion == 0 then
+-- 		self.Info.requestsVersion = calculateRequestsVersion(self.Info.requests)
+-- 	end
+
+-- 	self:NormalizeRequestList()
+-- end
+
+-- -- Normalize stored requests and drop tombstoned entries.
+-- function Guild:NormalizeRequestList()
+-- 	if not self.Info or not self.Info.requests then
+-- 		return
+-- 	end
+
+-- 	local before = GBankClassic_Globals:Count(self.Info.requests)
+-- 	GBankClassic_Output:Debug("REQUESTS", "NormalizeRequestList: Starting with %d requests", before)
+
+-- 	local normalized = {}
+-- 	local tombstones = self.Info.requestsTombstones or {}
+-- 	local latest = tonumber(self.Info.requestsVersion or 0) or 0
+
+-- 	for id, req in pairs(self.Info.requests) do
+-- 		local clean = sanitizeRequest(req)
+-- 		if clean and clean.id then
+-- 			local tombstoneTs = tonumber(tombstones[clean.id] or 0) or 0
+-- 			if tombstoneTs > 0 and (tonumber(clean.updatedAt or 0) or 0) <= tombstoneTs then
+-- 				-- Skip entries that were deleted after their last update.
+-- 				GBankClassic_Output:Debug("REQUESTS", "NormalizeRequestList: Skipping tombstoned request id=%s", clean.id)
+-- 			else
+-- 				local existing = normalized[clean.id]
+-- 				if existing then
+-- 					local existingUpdated = tonumber(existing.updatedAt or existing.date or 0) or 0
+-- 					local incomingUpdated = tonumber(clean.updatedAt or clean.date or 0) or 0
+-- 					if incomingUpdated > existingUpdated then
+-- 						normalized[clean.id] = clean
+-- 						GBankClassic_Output:Debug("REQUESTS", "NormalizeRequestList: Updated duplicate id=%s", clean.id)
+-- 					end
+-- 				else
+-- 					normalized[clean.id] = clean
+-- 				end
+-- 				if clean.updatedAt and clean.updatedAt > latest then
+-- 					-- Validate timestamp to prevent corruption
+-- 					local MAX_TIMESTAMP = 2147483647 -- Max 32-bit signed integer (Jan 19, 2038)
+-- 					if clean.updatedAt < MAX_TIMESTAMP then
+-- 						latest = clean.updatedAt
+-- 					else
+-- 						-- Only warn once per corrupted request ID to prevent spam
+-- 						if not warnedAbout.corruptedTimestamps[clean.id] then
+-- 							GBankClassic_Output:Warn("Skipping corrupted updatedAt timestamp %s for request id=%s", tostring(clean.updatedAt), tostring(clean.id))
+-- 							warnedAbout.corruptedTimestamps[clean.id] = true
+-- 						end
+-- 					end
+-- 				end
+-- 			end
+-- 		end
+-- 	end
+
+-- 	self.Info.requests = normalized
+-- 	self.Info.requestsVersion = latest
+
+-- 	local after = GBankClassic_Globals:Count(normalized)
+-- 	GBankClassic_Output:Debug("REQUESTS", "NormalizeRequestList: Finished with %d requests (calling PruneRequests)", after)
+
+-- 	self:PruneRequests()
+-- end
+
+-- -- Tombstone pruning. Returns (pruned, before, after).
+-- function Guild:PruneRequestTombstones()
+-- 	if not self.Info or not self.Info.requestsTombstones then
+-- 		return 0, 0, 0
+-- 	end
+
+-- 	local before = GBankClassic_Globals:Count(self.Info.requestsTombstones)
+-- 	local now = GetServerTime()
+-- 	local keep = {}
+-- 	for requestId, ts in pairs(self.Info.requestsTombstones) do
+-- 		local deletedAt = tonumber(ts or 0) or 0
+-- 		if deletedAt > 0 and (now - deletedAt) <= REQUEST_LOG.EXPIRY_SECONDS then
+-- 			keep[requestId] = deletedAt
+-- 		end
+-- 	end
+-- 	self.Info.requestsTombstones = keep
+-- 	local after = GBankClassic_Globals:Count(keep)
+
+-- 	return before - after, before, after
+-- end
+
+-- -- Throttled pruning: only runs if enough time has passed since last prune.
+-- -- Returns true if pruning was performed, false if skipped.
+-- function Guild:PruneIfNeeded()
+-- 	local now = GetServerTime()
+-- 	local lastPrune = self.lastPruneTime or 0
+-- 	if (now - lastPrune) < REQUEST_LOG.PRUNE_INTERVAL then
+-- 		return false
+-- 	end
+
+-- 	self.lastPruneTime = now
+-- 	self:PruneRequests()
+-- 	self:PruneRequestTombstones()
+
+-- 	return true
+-- end
+
+-- -- Snapshot application using merge-based sync (no log replay).
+-- -- Each request is merged using last-writer-wins based on updatedAt.
+-- function Guild:ApplyRequestSnapshot(payload)
+-- 	if not payload or type(payload) ~= "table" then
+-- 		GBankClassic_Output:Debug("SYNC", "ApplyRequestSnapshot: Invalid payload")
+
+-- 		return false
+-- 	end
+-- 	if not self.Info then
+-- 		GBankClassic_Output:Debug("SYNC", "ApplyRequestSnapshot: No GBankClassic_Guild.Info")
+
+-- 		return false
+-- 	end
+-- 	self:EnsureRequestsInitialized()
+
+-- 	local incomingList = payload.requests
+-- 	if not incomingList or type(incomingList) ~= "table" then
+-- 		GBankClassic_Output:Debug("SYNC", "ApplyRequestSnapshot: No requests in payload")
+
+-- 		return false
+-- 	end
+
+-- 	local requestCount = GBankClassic_Globals:Count(incomingList)
+-- 	GBankClassic_Output:Debug("SYNC", "ApplyRequestSnapshot: Merging %d incoming requests", requestCount)
+
+-- 	-- Merge incoming tombstones (keep most recent per ID)
+-- 	local tombstones = self.Info.requestsTombstones or {}
+-- 	for id, ts in pairs(payload.tombstones or {}) do
+-- 		local incomingTs = tonumber(ts or 0) or 0
+-- 		if incomingTs > (tonumber(tombstones[id] or 0) or 0) then
+-- 			tombstones[id] = incomingTs
+-- 		end
+-- 	end
+-- 	self.Info.requestsTombstones = tombstones
+
+-- 	-- Merge each incoming request
+-- 	local stats = { added = 0, updated = 0, kept = 0, tombstoned = 0 }
+-- 	local iterFunc = incomingList[1] ~= nil and ipairs or pairs
+-- 	for _, req in iterFunc(incomingList) do
+-- 		if req and req.id then
+-- 			local result = mergeRequest(self.Info.requests, tombstones, req.id, req)
+-- 			if result then
+-- 				stats[result] = (stats[result] or 0) + 1
+-- 			end
+-- 		end
+-- 	end
+
+-- 	-- Update version and clean up
+-- 	self.Info.requestsVersion = calculateRequestsVersion(self.Info.requests)
+-- 	self:NormalizeRequestList()
+-- 	self:PruneRequests()
+-- 	self:PruneRequestTombstones()
+-- 	self:RefreshRequestsUI()
+
+-- 	GBankClassic_Output:Debug("SYNC", "ApplyRequestSnapshot: Complete - added=%d, updated=%d, kept=%d, tombstoned=%d", stats.added, stats.updated, stats.kept, stats.tombstoned)
+
+-- 	return true
+-- end
+
+-- -- Request list pruning based on expiry. Returns (pruned, before, after).
+-- function Guild:PruneRequests()
+-- 	if not self.Info or not self.Info.requests then
+-- 		return 0, 0, 0
+-- 	end
+
+-- 	local before = GBankClassic_Globals:Count(self.Info.requests)
+-- 	local now = GetServerTime()
+-- 	local prunedCount = 0
+-- 	local latest = tonumber(self.Info.requestsVersion or 0) or 0
+
+-- 	GBankClassic_Output:Debug("REQUESTS", "PruneRequests: Starting with %d requests", before)
+
+-- 	for id, req in pairs(self.Info.requests) do
+-- 		local updated = tonumber(req.updatedAt or req.date or 0) or 0
+-- 		local quantity = tonumber(req.quantity or 0) or 0
+-- 		local fulfilled = tonumber(req.fulfilled or 0) or 0
+-- 		local isDone = req.status == "fulfilled" or req.status == "complete" or req.status == "cancelled" or (quantity > 0 and fulfilled >= quantity)
+-- 		local tooOld = isDone and (now - updated) > REQUEST_LOG.EXPIRY_SECONDS
+-- 		if tooOld then
+-- 			self.Info.requests[id] = nil
+-- 			prunedCount = prunedCount + 1
+-- 			GBankClassic_Output:Debug("REQUESTS", "PruneRequests: Pruning request id=%s, status=%s, age=%d seconds", req.id or "nil", req.status or "nil", now - updated)
+-- 		else
+-- 			if updated > latest then
+-- 				latest = updated
+-- 			end
+-- 		end
+-- 	end
+
+-- 	if prunedCount > 0 then
+-- 		GBankClassic_Output:Debug("REQUESTS", "PruneRequests: Pruned %d old completed requests", prunedCount)
+-- 	end
+
+-- 	self.Info.requestsVersion = latest
+-- 	local after = GBankClassic_Globals:Count(self.Info.requests)
+
+-- 	GBankClassic_Output:Debug("REQUESTS", "PruneRequests: Finished with %d requests (%d pruned)", after, prunedCount)
+
+-- 	return prunedCount, before, after
+-- end
+
+-- -- Apply a mutation entry received from another player.
+-- function Guild:ApplyRequestMutation(entry)
+-- 	if not entry or type(entry) ~= "table" or not self.Info then
+-- 		GBankClassic_Output:Debug("SYNC", "ApplyRequestMutation: Invalid entry or missing GBankClassic_Guild.Info")
+
+-- 		return false
+-- 	end
+-- 	self:EnsureRequestsInitialized()
+
+-- 	local entryType = entry.type
+-- 	local entryTs = tonumber(entry.ts or 0) or 0
+-- 	local requestId = entry.requestId or (entry.request and entry.request.id)
+-- 	if not entryType or not requestId then
+-- 		GBankClassic_Output:Debug("SYNC", "ApplyRequestMutation: Missing entryType or requestId (type=%s, id=%s)", tostring(entryType), tostring(requestId))
+
+-- 		return false
+-- 	end
+
+-- 	GBankClassic_Output:Debug("SYNC", "ApplyRequestMutation: type=%s, requestId=%s, ts=%d", entryType, requestId, entryTs)
+
+-- 	local tombstones = self.Info.requestsTombstones or {}
+
+-- 	-- Handle delete: remove request and record tombstone
+-- 	if entryType == "delete" then
+-- 		self.Info.requests[requestId] = nil
+-- 		local tombstoneTs = tonumber(tombstones[requestId] or 0) or 0
+-- 		if entryTs > tombstoneTs then
+-- 			tombstones[requestId] = entryTs
+-- 			self.Info.requestsTombstones = tombstones
+-- 		end
+-- 		GBankClassic_Output:Debug("SYNC", "ApplyRequestMutation: Delete applied for id=%s", requestId)
+
+-- 		return true
+-- 	end
+
+-- 	-- Handle fulfill: idempotent delta application
+-- 	if entryType == "fulfill" then
+-- 		local req = self.Info.requests[requestId]
+-- 		if not req or req.status == "cancelled" or req.status == "complete" then
+-- 			GBankClassic_Output:Debug("SYNC", "ApplyRequestMutation: Fulfill rejected (request not found or terminal state) id=%s", requestId)
+
+-- 			return false
+-- 		end
+-- 		local targetFulfilled = entry.targetFulfilled
+-- 		if targetFulfilled ~= nil then
+-- 			-- Idempotent: use max of current and target
+-- 			req.fulfilled = math.max(tonumber(req.fulfilled or 0) or 0, tonumber(targetFulfilled) or 0)
+-- 		else
+-- 			-- Legacy additive delta (backwards compat)
+-- 			local delta = tonumber(entry.delta or 0) or 0
+-- 			if delta > 0 then
+-- 				req.fulfilled = (tonumber(req.fulfilled or 0) or 0) + delta
+-- 			end
+-- 		end
+-- 		-- Clamp to quantity and update status if fully fulfilled
+-- 		local qty = tonumber(req.quantity or 0) or 0
+-- 		if qty > 0 then
+-- 			req.fulfilled = math.min(req.fulfilled, qty)
+-- 			if req.fulfilled >= qty and req.status ~= "cancelled" and req.status ~= "complete" then
+-- 				req.status = "fulfilled"
+-- 				req.statusUpdatedAt = entryTs
+-- 			end
+-- 		end
+-- 		if entryTs > 0 then
+-- 			req.updatedAt = math.max(tonumber(req.updatedAt or 0) or 0, entryTs)
+-- 		end
+-- 		GBankClassic_Output:Debug("SYNC", "ApplyRequestMutation: Fulfill applied for id=%s (fulfilled=%d)", requestId, req.fulfilled)
+
+-- 		return true
+-- 	end
+
+-- 	-- Handle add/cancel/complete: merge request snapshot
+-- 	if entry.request then
+-- 		GBankClassic_Output:Debug("SYNC", "ApplyRequestMutation: Merging request snapshot type=%s, id=%s, status=%s, statusUpdatedAt=%s, updatedAt=%s", entryType, requestId, tostring(entry.request.status), tostring(entry.request.statusUpdatedAt), tostring(entry.request.updatedAt))
+		
+-- 		local result = mergeRequest(self.Info.requests, tombstones, requestId, entry.request)
+		
+-- 		GBankClassic_Output:Debug("SYNC", "ApplyRequestMutation: mergeRequest result=%s for type=%s, id=%s", tostring(result), entryType, requestId)
+		
+-- 		return result == "added" or result == "updated"
+-- 	end
+
+-- 	GBankClassic_Output:Debug("SYNC", "ApplyRequestMutation: No action taken for type=%s, id=%s (no request data)", entryType, requestId)
+
+-- 	return false
+-- end
+
+-- -- Broadcast a request mutation to guild members.
+-- -- mutation: { type, requestId, request (for add), delta/targetFulfilled (for fulfill) }
+-- function Guild:BroadcastRequestMutation(mutation)
+-- 	if not mutation or type(mutation) ~= "table" then
+-- 		GBankClassic_Output:Debug("SYNC", "BroadcastRequestMutation: Invalid mutation (nil or not table)")
+
+-- 		return
+-- 	end
+
+-- 	local now = GetServerTime()
+-- 	local actor = self:GetNormalizedPlayer() or "unknown"
+-- 	-- Use timestamp as pseudo-seq for backwards compat with old clients that expect seq field
+-- 	local pseudoSeq = now
+-- 	local payload = {
+-- 		type = "requests-log",
+-- 		logEntries = {{
+-- 			type = mutation.type,
+-- 			actor = actor,
+-- 			seq = pseudoSeq,  -- Backwards compat: old clients expect seq field
+-- 			ts = now,
+-- 			id = string.format("%s:%d", actor, now),
+-- 			requestId = mutation.requestId,
+-- 			request = mutation.request,
+-- 			delta = mutation.delta,
+-- 			targetFulfilled = mutation.targetFulfilled,
+-- 		}}
+-- 	}
+	
+-- 	GBankClassic_Output:Debug("SYNC", "BroadcastRequestMutation: Sending type=%s, requestId=%s, actor=%s, ts=%d, hasRequest=%s", tostring(mutation.type), tostring(mutation.requestId), actor, now, tostring(mutation.request ~= nil))
+	
+-- 	local data = GBankClassic_Core:SerializeWithChecksum(payload)
+	
+-- 	GBankClassic_Output:Debug("SYNC", "BroadcastRequestMutation: Serialized payload, size=%d bytes, calling SendCommMessage", #data)
+	
+-- 	-- Use dedicated gbank-rm prefix for request mutations
+-- 	-- Separate throttle bucket from gbank-d prevents bulk snapshot syncs from blocking alert mutations
+-- 	local sendResult = GBankClassic_Core:SendCommMessage("gbank-rm", data, "Guild", nil, "ALERT")
+	
+-- 	GBankClassic_Output:Debug("SYNC", "BroadcastRequestMutation: SendCommMessage returned %s for type=%s", tostring(sendResult), tostring(mutation.type))
+-- end
+
+-- -- After a local mutation, update version and refresh UI.
+-- function Guild:FinalizeMutation(ts)
+-- 	self:TouchRequestsVersion(ts or GetServerTime())
+-- 	self:PruneIfNeeded()
+-- 	self:RefreshRequestsUI()
+-- end
+
+-- -- Version and UI helpers
+-- function Guild:TouchRequestsVersion(ts)
+-- 	if not self.Info then
+-- 		return
+-- 	end
+
+-- 	local current = tonumber(self.Info.requestsVersion or 0) or 0
+-- 	local incoming = tonumber(ts or GetServerTime()) or current
+-- 	if incoming > current then
+-- 		self.Info.requestsVersion = incoming
+-- 	end
+-- end
+
+-- function Guild:RefreshRequestsUI()
+-- 	GBankClassic_Output:Debug("UI", "RefreshRequestsUI called: isOpen=%s, requests=%d", tostring(GBankClassic_UI_Requests and GBankClassic_UI_Requests.isOpen), self.Info and self.Info.requests and GBankClassic_Globals:Count(self.Info.requests) or 0)
+
+-- 	if GBankClassic_UI_Requests and GBankClassic_UI_Requests.isOpen then
+-- 		-- Recreate filters (including guild bank alt checkbox) when roster updates
+-- 		GBankClassic_UI_Requests:UpdateFilters()
+-- 		GBankClassic_UI_Requests:DrawContent()
+-- 	end
+-- end
+
+-- function Guild:EnsureRequestsIndexSyncState()
+-- 	if not self.requestsIndexSync then
+-- 		self.requestsIndexSync = {
+-- 			lastQueryAt = 0,
+-- 			perSender = {},
+-- 			inFlight = nil,
+-- 			inFlightSince = 0,
+-- 			awaitingById = false,
+-- 		}
+-- 	end
+-- end
+
+-- function Guild:CanQueryRequestsIndex(sender)
+-- 	self:EnsureRequestsIndexSyncState()
+-- 	local now = GetServerTime()
+-- 	local state = self.requestsIndexSync
+
+-- 	if state.inFlight then
+-- 		if (now - (state.inFlightSince or 0)) < REQUESTS_SYNC.INDEX_INFLIGHT_TIMEOUT then
+-- 			return false
+-- 		end
+
+-- 		state.inFlight = nil
+-- 		state.inFlightSince = 0
+-- 		state.awaitingById = false
+-- 	end
+
+-- 	if (now - (state.lastQueryAt or 0)) < REQUESTS_SYNC.INDEX_QUERY_COOLDOWN then
+-- 		return false
+-- 	end
+
+-- 	if sender and sender ~= "" then
+-- 		local last = state.perSender[sender]
+-- 		if last and (now - last) < REQUESTS_SYNC.INDEX_QUERY_COOLDOWN then
+-- 			return false
+-- 		end
+-- 	end
+
+-- 	return true
+-- end
+
+-- function Guild:BeginRequestsIndexSync(sender)
+-- 	if not self:CanQueryRequestsIndex(sender) then
+-- 		return false
+-- 	end
+
+-- 	self:EnsureRequestsIndexSyncState()
+-- 	local now = GetServerTime()
+-- 	self.requestsIndexSync.lastQueryAt = now
+-- 	if sender and sender ~= "" then
+-- 		self.requestsIndexSync.perSender[sender] = now
+-- 	end
+-- 	self.requestsIndexSync.inFlight = sender or "*"
+-- 	self.requestsIndexSync.inFlightSince = now
+-- 	self.requestsIndexSync.awaitingById = false
+
+-- 	return true
+-- end
+
+-- function Guild:MarkRequestsIndexAwaitingById()
+-- 	self:EnsureRequestsIndexSyncState()
+-- 	self.requestsIndexSync.awaitingById = true
+-- end
+
+-- function Guild:EndRequestsIndexSync()
+-- 	self:EnsureRequestsIndexSyncState()
+-- 	self.requestsIndexSync.inFlight = nil
+-- 	self.requestsIndexSync.inFlightSince = 0
+-- 	self.requestsIndexSync.awaitingById = false
+-- end
+
+-- function Guild:GetRequestsHash()
+-- 	if not self.Info then
+-- 		return 0
+-- 	end
+
+-- 	self:EnsureRequestsInitialized()
+
+-- 	return computeRequestsHash(self.Info.requests, self.Info.requestsTombstones)
+-- end
+
+-- -- Snapshot sync messaging.
+-- function Guild:GetRequestsVersion()
+-- 	if not self.Info then
+-- 		return 0
+-- 	end
+
+-- 	local version = tonumber(self.Info.requestsVersion or 0) or 0
+-- 	-- Validate version is within reasonable unix timestamp range (2000-2038)
+-- 	-- Prevents integer overflow from corrupted data003)
+-- 	local MIN_TIMESTAMP = 946684800 -- Jan 1, 2000
+-- 	local MAX_TIMESTAMP = 2147483647 -- Max 32-bit signed integer (Jan 19, 2038)
+-- 	if version < MIN_TIMESTAMP or version > MAX_TIMESTAMP then
+-- 		-- Only warn once per session to prevent spam
+-- 		if not warnedAbout.invalidRequestVersion then
+-- 			GBankClassic_Output:Warn("Invalid request version %s detected, resetting to 0", tostring(version))
+-- 			warnedAbout.invalidRequestVersion = true
+-- 		end
+-- 		self.Info.requestsVersion = 0 -- Actually fix the stored value
+
+-- 		return 0
+-- 	end
+
+-- 	return version
+-- end
+
+-- function Guild:SendRequestsSnapshot(target)
+-- 	-- Always send snapshot, even if empty (so querying player knows we have nothing)
+-- 	if not self.Info then
+-- 		GBankClassic_Output:DebugComm("SendRequestsSnapshot: Skipping (self.Info is nil)")
+
+-- 		return
+-- 	end
+
+-- 	self:EnsureRequestsInitialized()
+-- 	self:NormalizeRequestList()
+-- 	local payload = {
+-- 		type = "requests",
+-- 		player = "*",  -- Backwards compat: old versions need this field to process responses
+-- 		version = self:GetRequestsVersion(),
+-- 		requests = requestsToArray(self.Info.requests),  -- Convert map to array for wire format
+-- 		tombstones = self.Info.requestsTombstones or {},
+-- 	}
+-- 	local data = GBankClassic_Core:SerializeWithChecksum(payload)
+-- 	-- Send on old prefix for backwards compat; new clients listen on both
+-- 	GBankClassic_Core:SendCommMessage("gbank-d", data, "Guild", target, "BULK") -- TODO: We're no longer using togbank-d (for us, gbank-d = togbank-d3)
+-- end
+
+-- function Guild:SendRequestsData(target)
+-- 	self:SendRequestsSnapshot(target)
+-- end
+
+-- function Guild:QueryRequestsSnapshot(priority)
+-- 	-- Send wildcard query
+-- 	-- Old clients won't respond to wildcard, but targeted queries flood guild chat and trigger WoW throttling which blocks responses. Wildcard-only is the fix.
+-- 	local data = GBankClassic_Core:SerializeWithChecksum({ player = "*", type = "requests" })
+-- 	-- Send on old prefix for backwards compat; new clients listen on both
+-- 	GBankClassic_Core:SendCommMessage("gbank-r", data, "Guild", nil, priority or "BULK")
+-- 	GBankClassic_Output:Debug("SYNC", "Sent wildcard query")
+-- end
+
+-- -- Request index query/response for hash-based sync.
+-- function Guild:QueryRequestsIndex(target, priority)
+-- 	if not self:BeginRequestsIndexSync(target) then
+-- 		return false
+-- 	end
+
+-- 	local payload = {
+-- 		player = "*",
+-- 		type = "requests-index",
+-- 		version = self:GetRequestsVersion(),
+-- 		hash = self:GetRequestsHash(),
+-- 	}
+-- 	local data = GBankClassic_Core:SerializeWithChecksum(payload)
+-- 	-- Send on old prefix for backwards compat; new clients listen on both
+-- 	if target and target ~= "" then
+-- 		if not GBankClassic_Core:SendWhisper("gbank-r", data, target, priority or "NORMAL") then
+-- 			self:EndRequestsIndexSync()
+
+-- 			return false
+-- 		end
+-- 	else
+-- 		GBankClassic_Core:SendCommMessage("gbank-r", data, "Guild", nil, priority or "BULK")
+-- 	end
+
+-- 	return true
+-- end
+
+-- function Guild:SendRequestsIndex(target)
+-- 	if not self.Info then
+-- 		return
+-- 	end
+
+-- 	self:EnsureRequestsInitialized()
+-- 	self:NormalizeRequestList()
+
+-- 	local requestsIndex = {}
+-- 	for id, req in pairs(self.Info.requests or {}) do
+-- 		local updatedAt = tonumber(req.updatedAt or req.date or 0) or 0
+-- 		table.insert(requestsIndex, { id = id, updatedAt = updatedAt })
+-- 	end
+-- 	table.sort(requestsIndex, function(a, b)
+-- 		return tostring(a.id) < tostring(b.id)
+-- 	end)
+
+-- 	local tombstonesIndex = {}
+-- 	for id, ts in pairs(self.Info.requestsTombstones or {}) do
+-- 		local deletedAt = tonumber(ts or 0) or 0
+-- 		if deletedAt > 0 then
+-- 			table.insert(tombstonesIndex, { id = id, deletedAt = deletedAt })
+-- 		end
+-- 	end
+-- 	table.sort(tombstonesIndex, function(a, b)
+-- 		return tostring(a.id) < tostring(b.id)
+-- 	end)
+
+-- 	local payload = {
+-- 		type = "requests-index",
+-- 		version = self:GetRequestsVersion(),
+-- 		hash = self:GetRequestsHash(),
+-- 		requests = requestsIndex,
+-- 		tombstones = tombstonesIndex,
+-- 	}
+-- 	local data = GBankClassic_Core:SerializeWithChecksum(payload)
+-- 	-- Send on old prefix for backwards compat; new clients listen on both
+-- 	if target and target ~= "" then
+-- 		GBankClassic_Core:SendWhisper("gbank-d", data, target, "BULK") -- TODO: We're no longer using togbank-d (for us, gbank-d = togbank-d3)
+-- 	else
+-- 		GBankClassic_Core:SendCommMessage("gbank-d", data, "Guild", nil, "BULK") -- TODO: We're no longer using togbank-d (for us, gbank-d = togbank-d3)
+-- 	end
+-- end
+
+-- function Guild:ReceiveRequestsIndex(payload, sender)
+-- 	if not payload or type(payload) ~= "table" then
+-- 		return
+-- 	end
+-- 	if not self.Info then
+-- 		return
+-- 	end
+
+-- 	self:EnsureRequestsInitialized()
+
+-- 	local incomingRequests = payload.requests
+-- 	if type(incomingRequests) ~= "table" then
+-- 		return
+-- 	end
+
+-- 	-- Apply tombstones from index and track for skip logic.
+-- 	local tombstonesMap = {}
+-- 	local incomingTombstones = payload.tombstones
+-- 	for _, entry in pairs(incomingTombstones or {}) do
+-- 		if entry and entry.id then
+-- 			local ts = tonumber(entry.deletedAt or entry.ts or 0) or 0
+-- 			if ts > 0 then
+-- 				tombstonesMap[entry.id] = ts
+-- 				local currentTs = tonumber((self.Info.requestsTombstones or {})[entry.id] or 0) or 0
+-- 				if ts > currentTs then
+-- 					self.Info.requestsTombstones = self.Info.requestsTombstones or {}
+-- 					self.Info.requestsTombstones[entry.id] = ts
+-- 				end
+-- 				local localReq = self.Info.requests[entry.id]
+-- 				if localReq then
+-- 					local localUpdated = tonumber(localReq.updatedAt or localReq.date or 0) or 0
+-- 					if localUpdated <= ts then
+-- 						self.Info.requests[entry.id] = nil
+-- 					end
+-- 				end
+-- 			end
+-- 		end
+-- 	end
+
+-- 	local missingIds = {}
+-- 	for _, entry in pairs(incomingRequests) do
+-- 		if entry and entry.id then
+-- 			local incomingUpdated = tonumber(entry.updatedAt or entry.date or 0) or 0
+-- 			local tombstoneTs = tombstonesMap[entry.id] or tonumber((self.Info.requestsTombstones or {})[entry.id] or 0) or 0
+-- 			if tombstoneTs > 0 and incomingUpdated <= tombstoneTs then
+-- 				-- Deleted entry, skip fetching
+-- 			else
+-- 				local localReq = self.Info.requests[entry.id]
+-- 				local localUpdated = localReq and (tonumber(localReq.updatedAt or localReq.date or 0) or 0) or 0
+-- 				if not localReq or localUpdated < incomingUpdated then
+-- 					table.insert(missingIds, entry.id)
+-- 				end
+-- 			end
+-- 		end
+-- 	end
+
+-- 	if #missingIds > 0 then
+-- 		self:MarkRequestsIndexAwaitingById()
+-- 		self:QueryRequestsById(sender, missingIds)
+-- 	else
+-- 		self:EndRequestsIndexSync()
+-- 		self:RefreshRequestsUI()
+-- 	end
+-- end
+
+-- function Guild:QueryRequestsById(target, ids, priority)
+-- 	if not ids or type(ids) ~= "table" or #ids == 0 then
+-- 		return false
+-- 	end
+
+-- 	local payload = {
+-- 		player = "*",
+-- 		type = "requests-by-id",
+-- 		ids = ids,
+-- 	}
+-- 	local data = GBankClassic_Core:SerializeWithChecksum(payload)
+-- 	-- Send on old prefix for backwards compat; new clients listen on both
+-- 	if target and target ~= "" then
+-- 		if not GBankClassic_Core:SendWhisper("gbank-r", data, target, priority or "NORMAL") then
+-- 			return false
+-- 		end
+-- 	else
+-- 		GBankClassic_Core:SendCommMessage("gbank-r", data, "Guild", nil, priority or "BULK")
+-- 	end
+
+-- 	return true
+-- end
+
+-- function Guild:SendRequestsById(target, ids)
+-- 	if not ids or type(ids) ~= "table" or #ids == 0 then
+-- 		return
+-- 	end
+-- 	if not self.Info then
+-- 		return
+-- 	end
+
+-- 	self:EnsureRequestsInitialized()
+
+-- 	local requests = {}
+-- 	local tombstones = {}
+-- 	for _, id in ipairs(ids) do
+-- 		if id then
+-- 			local req = self.Info.requests[id]
+-- 			if req then
+-- 				table.insert(requests, req)
+-- 			else
+-- 				local ts = tonumber((self.Info.requestsTombstones or {})[id] or 0) or 0
+-- 				if ts > 0 then
+-- 					tombstones[id] = ts
+-- 				end
+-- 			end
+-- 		end
+-- 	end
+
+-- 	local payload = {
+-- 		type = "requests-by-id",
+-- 		requests = requests,
+-- 		tombstones = tombstones,
+-- 	}
+-- 	local data = GBankClassic_Core:SerializeWithChecksum(payload)
+-- 	-- Send on old prefix for backwards compat; new clients listen on both
+-- 	if target and target ~= "" then
+-- 		GBankClassic_Core:SendWhisper("gbank-d", data, target, "BULK") -- TODO: We're no longer using togbank-d (for us, gbank-d = togbank-d3)
+-- 	else
+-- 		GBankClassic_Core:SendCommMessage("gbank-d", data, "Guild", nil, "BULK") -- TODO: We're no longer using togbank-d (for us, gbank-d = togbank-d3)
+-- 	end
+-- end
+
+-- function Guild:ReceiveRequestsById(payload)
+-- 	if not payload or type(payload) ~= "table" then
+-- 		return ADOPTION_STATUS.INVALID
+-- 	end
+-- 	if not self.Info then
+-- 		return ADOPTION_STATUS.IGNORED
+-- 	end
+
+-- 	self:EnsureRequestsInitialized()
+
+-- 	local requests = payload.requests
+-- 	if not requests or type(requests) ~= "table" then
+-- 		return ADOPTION_STATUS.INVALID
+-- 	end
+
+-- 	if self:ApplyRequestSnapshot({
+-- 		requests = requests,
+-- 		tombstones = payload.tombstones or {},
+-- 	}) then
+-- 		self:EndRequestsIndexSync()
+
+-- 		return ADOPTION_STATUS.ADOPTED
+-- 	end
+
+-- 	return ADOPTION_STATUS.INVALID
+-- end
+
+-- -- Receive and merge a requests snapshot from another player.
+-- -- Uses merge-based sync - always merges, ApplyRequestSnapshot handles conflict resolution.
+-- function Guild:ReceiveRequestsData(payload)
+-- 	if not payload or type(payload) ~= "table" then
+-- 		GBankClassic_Output:Debug("SYNC", "ReceiveRequestsData: Invalid - payload not a table")
+
+-- 		return ADOPTION_STATUS.INVALID
+-- 	end
+-- 	if not self.Info then
+-- 		GBankClassic_Output:Debug("SYNC", "ReceiveRequestsData: Ignored - self.Info is nil")
+
+-- 		return ADOPTION_STATUS.IGNORED
+-- 	end
+-- 	self:EnsureRequestsInitialized()
+
+-- 	local incomingCount = (payload.requests and type(payload.requests) == "table") and #payload.requests or 0
+-- 	local localCountBefore = self.Info.requests and GBankClassic_Globals:Count(self.Info.requests) or 0
+-- 	GBankClassic_Output:Debug("SYNC", "ReceiveRequestsData: Start - local=%d, incoming=%d", localCountBefore, incomingCount)
+
+-- 	-- Always merge - ApplyRequestSnapshot handles last-writer-wins per request
+-- 	if self:ApplyRequestSnapshot(payload) then
+-- 		local localCountAfter = self.Info.requests and GBankClassic_Globals:Count(self.Info.requests) or 0
+-- 		GBankClassic_Output:Debug("SYNC", "ReceiveRequestsData: Adopted - final=%d (was %d, incoming=%d)", localCountAfter, localCountBefore, incomingCount)
+
+-- 		return ADOPTION_STATUS.ADOPTED
+-- 	end
+
+-- 	GBankClassic_Output:Debug("SYNC", "ReceiveRequestsData: Invalid - ApplyRequestSnapshot returned false")
+
+-- 	return ADOPTION_STATUS.INVALID
+-- end
+
+function Guild:SendRequestsVersionPing()
+	if not self.Info then
+		return
+	end
+	
+	local payload = {
+		requests = {
+			-- version = self:GetRequestsVersion(),
+			-- hash = self:GetRequestsHash(),
+		},
+	}
+	local data = GBankClassic_Core:SerializeWithChecksum(payload)
+	GBankClassic_Core:SendCommMessage("gbank-v", data, "Guild", nil, "BULK")
+end
+
+-- -- Receive mutation entries from another player and apply them.
+-- function Guild:ReceiveRequestMutations(payload, sender)
+-- 	if not payload or type(payload) ~= "table" then
+-- 		GBankClassic_Output:Debug("SYNC", "ReceiveRequestMutations: Invalid payload from %s", tostring(sender))
+
+-- 		return
+-- 	end
+
+-- 	local entries = payload.logEntries
+-- 	if not entries or type(entries) ~= "table" then
+-- 		GBankClassic_Output:Debug("SYNC", "ReceiveRequestMutations: No logEntries in payload from %s", tostring(sender))
+
+-- 		return
+-- 	end
+
+-- 	if not self.Info then
+-- 		GBankClassic_Output:Debug("SYNC", "ReceiveRequestMutations: No GBankClassic_Guild.Info, ignoring mutations from %s", tostring(sender))
+
+-- 		return
+-- 	end
+
+-- 	self:EnsureRequestsInitialized()
+
+-- 	GBankClassic_Output:Debug("SYNC", "ReceiveRequestMutations: Processing %d entries from %s", #entries, tostring(sender))
+
+-- 	local applied = 0
+-- 	for i, entry in ipairs(entries) do
+-- 		if entry and type(entry) == "table" then
+-- 			local entryType = entry.type or "unknown"
+-- 			local requestId = entry.requestId or "?"
+-- 			GBankClassic_Output:Debug("SYNC", "ReceiveRequestMutations: Entry %d/%d: type=%s, requestId=%s", i, #entries, entryType, tostring(requestId))
+			
+-- 			if self:ApplyRequestMutation(entry) then
+-- 				applied = applied + 1
+-- 				GBankClassic_Output:Debug("SYNC", "ReceiveRequestMutations: Entry %d applied (type=%s, id=%s)", i, entryType, tostring(requestId))
+-- 			else
+-- 				GBankClassic_Output:Debug("SYNC", "ReceiveRequestMutations: Entry %d rejected (type=%s, id=%s)", i, entryType, tostring(requestId))
+-- 			end
+-- 		end
+-- 	end
+
+-- 	if applied > 0 then
+-- 		GBankClassic_Output:Debug("SYNC", "ReceiveRequestMutations: Applied %d/%d entries from %s", applied, #entries, tostring(sender))
+-- 		self:FinalizeMutation()
+-- 	else
+-- 		GBankClassic_Output:Debug("SYNC", "ReceiveRequestMutations: No entries applied from %s", tostring(sender))
+-- 	end
+-- end
+
+-- -- Request mutation helpers.
+-- function Guild:AddRequest(request)
+-- 	if not self.Info then
+-- 		return false
+-- 	end
+-- 	if not request or type(request) ~= "table" then
+-- 		return false
+-- 	end
+
+-- 	self:EnsureRequestsInitialized()
+
+-- 	local now = GetServerTime()
+-- 	request.date = request.date or now
+-- 	request.updatedAt = now
+-- 	request.status = request.status or "open"
+-- 	request.statusUpdatedAt = request.statusUpdatedAt or now -- Track when status was set
+-- 	request.fulfilled = tonumber(request.fulfilled or 0) or 0
+
+-- 	-- Generate request ID in actor:random format
+-- 	if not request.id then
+-- 		local actor = self:GetNormalizedPlayer() or "unknown"
+-- 		request.id = generateRequestId(actor)
+-- 	end
+
+-- 	local clean = sanitizeRequest(request)
+-- 	if not clean then
+-- 		return false
+-- 	end
+
+-- 	-- Store directly
+-- 	self.Info.requests[clean.id] = clean
+
+-- 	-- Broadcast and finalize
+-- 	self:BroadcastRequestMutation({ type = "add", requestId = clean.id, request = clean })
+-- 	self:FinalizeMutation(now)
+
+-- 	GBankClassic_Output:Debug("REQUESTS", "AddRequest: id=%s, item=%s, qty=%d", clean.id, clean.item or "", clean.quantity or 0)
+
+-- 	return true
+-- end
+
+-- -- Access control for requests.
+-- function Guild:CanManageRequests(actor, actorIsGM)
+-- 	if CanViewOfficerNote() then
+-- 		return true
+-- 	end
+
+-- 	local normActor = self:NormalizeName(actor)
+
+-- 	if normActor and self.IsBank and self:IsBank(normActor) then
+-- 		return true
+-- 	end
+-- 	if actorIsGM ~= nil then
+-- 		return actorIsGM
+-- 	end
+-- 	if normActor and self.SenderIsGM and self:SenderIsGM(normActor) then
+-- 		return true
+-- 	end
+
+-- 	return false
+-- end
+
+-- function Guild:CanCancelRequest(req, actor)
+-- 	if not req or type(req) ~= "table" then
+-- 		return false
+-- 	end
+
+-- 	local normActor = self:NormalizeName(actor or self:GetPlayer())
+-- 	local requester = self:NormalizeName(req.requester)
+
+-- 	if normActor and requester and normActor == requester then
+-- 		return true
+-- 	end
+
+-- 	return self:CanManageRequests(normActor)
+-- end
+
+-- function Guild:CanCompleteRequest(req, actor, actorIsGM)
+-- 	if not req or type(req) ~= "table" then
+-- 		return false
+-- 	end
+
+-- 	local normActor = self:NormalizeName(actor or self:GetPlayer())
+-- 	if not normActor then
+-- 		return false
+-- 	end
+
+-- 	local bank = self:NormalizeName(req.bank)
+-- 	if bank and bank ~= "" and normActor == bank then
+-- 		return true
+-- 	end
+-- 	if actorIsGM ~= nil then
+-- 		return actorIsGM
+-- 	end
+-- 	if self.SenderIsGM and self:SenderIsGM(normActor) then
+-- 		return true
+-- 	end
+
+-- 	return false
+-- end
+
+-- function Guild:CanDeleteRequest(req, actor, actorIsGM)
+-- 	if not req or type(req) ~= "table" then
+-- 		return false
+-- 	end
+
+-- 	local normActor = self:NormalizeName(actor or self:GetPlayer())
+-- 	if not normActor then
+-- 		return false
+-- 	end
+-- 	if actorIsGM ~= nil then
+-- 		return actorIsGM
+-- 	end
+-- 	if self.SenderIsGM and self:SenderIsGM(normActor) then
+-- 		return true
+-- 	end
+
+-- 	return false
+-- end
+
+-- function Guild:CancelRequest(requestId, actor)
+-- 	if not self.Info or not self.Info.requests or not requestId then
+-- 		GBankClassic_Output:Debug("SYNC", "CancelRequest failed: Missing data (Info=%s, requests=%s, requestId=%s)", tostring(self.Info ~= nil), tostring(self.Info and self.Info.requests ~= nil), tostring(requestId))
+
+-- 		return false
+-- 	end
+
+-- 	local req = self.Info.requests[requestId]
+-- 	if not req then
+-- 		GBankClassic_Output:Debug("SYNC", "CancelRequest failed: Request not found (id=%s)", tostring(requestId))
+
+-- 		return false
+-- 	end
+
+-- 	-- Can't cancel if already in terminal state
+-- 	local quantity = tonumber(req.quantity or 0) or 0
+-- 	local fulfilled = tonumber(req.fulfilled or 0) or 0
+-- 	if req.status == "cancelled" or req.status == "complete" then
+-- 		GBankClassic_Output:Debug("SYNC", "CancelRequest failed: Already in terminal state (status=%s)", req.status)
+
+-- 		return false
+-- 	end
+-- 	if req.status == "fulfilled" or (quantity > 0 and fulfilled >= quantity) then
+-- 		GBankClassic_Output:Debug("SYNC", "CancelRequest failed: Already fulfilled (status=%s, fulfilled=%d, quantity=%d)", req.status, fulfilled, quantity)
+
+-- 		return false
+-- 	end
+
+-- 	if not self:CanCancelRequest(req, actor or self:GetPlayer()) then
+-- 		GBankClassic_Output:Debug("SYNC", "CancelRequest failed: Permission denied (actor=%s, requester=%s)", tostring(actor or self:GetPlayer()), tostring(req.requester))
+
+-- 		return false
+-- 	end
+
+-- 	-- Apply mutation directly
+-- 	local now = GetServerTime()
+-- 	local oldStatus = req.status
+-- 	req.status = "cancelled"
+-- 	req.statusUpdatedAt = now
+-- 	req.updatedAt = now
+
+-- 	GBankClassic_Output:Debug("SYNC", "CancelRequest success: id=%s, item=%s, requester=%s, oldStatus=%s, statusUpdatedAt=%d, updatedAt=%d", requestId, req.item or "?", req.requester or "?", oldStatus, now, now)
+
+-- 	-- Broadcast and finalize
+-- 	self:BroadcastRequestMutation({ type = "cancel", requestId = requestId, request = req })
+-- 	GBankClassic_Output:Debug("SYNC", "CancelRequest: Broadcast sent for id=%s", requestId)
+	
+-- 	self:FinalizeMutation(now)
+
+-- 	return true
+-- end
+
+-- function Guild:CompleteRequest(requestId, actor)
+-- 	if not self.Info or not self.Info.requests or not requestId then
+-- 		return false
+-- 	end
+
+-- 	local req = self.Info.requests[requestId]
+-- 	if not req then
+-- 		return false
+-- 	end
+
+-- 	-- Can't complete if already in terminal state
+-- 	local quantity = tonumber(req.quantity or 0) or 0
+-- 	local fulfilled = tonumber(req.fulfilled or 0) or 0
+-- 	if req.status == "cancelled" or req.status == "complete" then
+-- 		return false
+-- 	end
+-- 	if req.status == "fulfilled" or (quantity > 0 and fulfilled >= quantity) then
+-- 		return false
+-- 	end
+-- 	if not self:CanCompleteRequest(req, actor or self:GetPlayer()) then
+-- 		return false
+-- 	end
+
+-- 	-- Apply mutation directly
+-- 	local now = GetServerTime()
+-- 	req.status = "complete"
+-- 	req.statusUpdatedAt = now
+-- 	req.updatedAt = now
+
+-- 	-- Broadcast and finalize
+-- 	self:BroadcastRequestMutation({ type = "complete", requestId = requestId, request = req })
+-- 	self:FinalizeMutation(now)
+
+-- 	return true
+-- end
+
+-- function Guild:DeleteRequest(requestId, actor)
+-- 	if not self.Info or not self.Info.requests or not requestId then
+-- 		return false
+-- 	end
+
+-- 	local req = self.Info.requests[requestId]
+-- 	if not req then
+-- 		return false
+-- 	end
+-- 	if not self:CanDeleteRequest(req, actor or self:GetPlayer()) then
+-- 		return false
+-- 	end
+
+-- 	-- Apply mutation directly
+-- 	local now = GetServerTime()
+-- 	self.Info.requests[requestId] = nil
+
+-- 	-- Record tombstone
+-- 	self.Info.requestsTombstones = self.Info.requestsTombstones or {}
+-- 	self.Info.requestsTombstones[requestId] = now
+
+-- 	-- Broadcast and finalize
+-- 	self:BroadcastRequestMutation({ type = "delete", requestId = requestId })
+-- 	self:FinalizeMutation(now)
+
+-- 	return true
+-- end
+
+-- -- Increment fulfillment for matching requests; returns amount applied.
+-- function Guild:FulfillRequest(bank, requester, itemName, count)
+-- 	if not self.Info or not self.Info.requests or not bank or not requester or not itemName or not count or count <= 0 then
+-- 		return 0
+-- 	end
+
+-- 	local normBank = self:NormalizeName(bank) or bank
+-- 	local normRequester = self:NormalizeName(requester) or requester
+-- 	local targetItem = string.lower(itemName)
+-- 	local now = GetServerTime()
+
+-- 	local applied = 0
+-- 	local mutations = {}
+
+-- 	for _, req in pairs(self.Info.requests) do
+-- 		if count <= 0 then
+-- 			break
+-- 		end
+
+-- 		local reqItem = req.item and string.lower(req.item) or ""
+-- 		local qty = tonumber(req.quantity or 0) or 0
+-- 		local fulfilled = tonumber(req.fulfilled or 0) or 0
+
+-- 		if req.bank == normBank and req.requester == normRequester and reqItem == targetItem and fulfilled < qty then
+-- 			local remaining = qty - fulfilled
+-- 			local delta = math.min(remaining, count)
+-- 			count = count - delta
+-- 			applied = applied + delta
+
+-- 			-- Apply mutation directly
+-- 			local targetFulfilled = fulfilled + delta
+-- 			req.fulfilled = targetFulfilled
+-- 			req.updatedAt = now
+			
+-- 			GBankClassic_Output:Debug("FULFILL", "Request %s: fulfilled=%d->%d, qty=%d, status=%s", req.id or "unknown", fulfilled, targetFulfilled, qty, tostring(req.status))
+			
+-- 			if qty > 0 and targetFulfilled >= qty and req.status ~= "cancelled" and req.status ~= "complete" then
+-- 				req.status = "fulfilled"
+-- 				req.statusUpdatedAt = now
+-- 				GBankClassic_Output:Debug("FULFILL", "Set status to fulfilled (fulfilled %d >= qty %d)", targetFulfilled, qty)
+-- 			else
+-- 				GBankClassic_Output:Debug("FULFILL", "Status not changed: qty=%d, fulfilled=%d, status=%s", qty, targetFulfilled, tostring(req.status))
+-- 			end
+
+-- 			-- Queue broadcast (targetFulfilled for idempotency on receiver)
+-- 			table.insert(mutations, { type = "fulfill", requestId = req.id, delta = delta, targetFulfilled = targetFulfilled })
+-- 		end
+-- 	end
+
+-- 	-- Broadcast all mutations
+-- 	for _, mutation in ipairs(mutations) do
+-- 		self:BroadcastRequestMutation(mutation)
+-- 	end
+
+-- 	if applied > 0 then
+-- 		self:FinalizeMutation(now)
+-- 	end
+
+-- 	return applied
+-- end
+
+-- -- Manual compaction with stats output.
+-- function Guild:Compact()
+-- 	if not self.Info then
+-- 		GBankClassic_Output:Response("Compact: no guild info loaded.")
+
+-- 		return
+-- 	end
+-- 	self:EnsureRequestsInitialized()
+
+-- 	-- Run compaction and collect stats
+-- 	local requestsPruned, requestsBefore, requestsAfter = self:PruneRequests()
+-- 	local tombstonesPruned, tombstonesBefore, tombstonesAfter = self:PruneRequestTombstones()
+
+-- 	-- Report results
+-- 	local totalPruned = requestsPruned + tombstonesPruned
+
+-- 	if totalPruned == 0 then
+-- 		GBankClassic_Output:Response("Compact: nothing to prune.")
+-- 		GBankClassic_Output:Response("  Requests: %d, tombstones: %d", requestsAfter, tombstonesAfter)
+-- 	else
+-- 		GBankClassic_Output:Response("Compact: pruned %d entries.", totalPruned)
+-- 		if requestsPruned > 0 then
+-- 			GBankClassic_Output:Response("  Requests: %d -> %d (-%d)", requestsBefore, requestsAfter, requestsPruned)
+-- 		else
+-- 			GBankClassic_Output:Response("  Requests: %d", requestsAfter)
+-- 		end
+-- 		if tombstonesPruned > 0 then
+-- 			GBankClassic_Output:Response("  Tombstones: %d -> %d (-%d)", tombstonesBefore, tombstonesAfter, tombstonesPruned)
+-- 		else
+-- 			GBankClassic_Output:Response("  Tombstones: %d", tombstonesAfter)
+-- 		end
+-- 	end
+-- end
+
+-- -- Checks if requested items are available in mail across all alts
+-- function Guild:CheckMailFulfillment(request)
+-- 	if not request or not request.item then
+-- 		return { inMail = 0, canFulfillFromMail = false, alts = {} }
+-- 	end
+
+-- 	-- Get item ID from item name
+-- 	local itemID = nil
+-- 	if not self.Info or not self.Info.alts then
+-- 		return { inMail = 0, canFulfillFromMail = false, alts = {} }
+-- 	end
+
+-- 	-- Find item ID by searching through all alts (mail.items is an array)
+-- 	for _, alt in pairs(self.Info.alts) do
+-- 		if alt.mail and alt.mail.items then
+-- 			for _, item in ipairs(alt.mail.items) do
+-- 				-- Use item name from item link if available, otherwise can't match by name
+-- 				local itemName = item.Link and (GetItemInfo(item.Link))
+-- 				if itemName == request.item or item.ID == tonumber(request.item) then
+-- 					itemID = item.ID
+-- 					break
+-- 				end
+-- 			end
+-- 		end
+-- 		if itemID then
+-- 			break
+-- 		end
+-- 	end
+
+-- 	if not itemID then
+-- 		return { inMail = 0, canFulfillFromMail = false, alts = {} }
+-- 	end
+
+-- 	local inMail = 0
+-- 	local alts = {}
+
+-- 	for name, alt in pairs(self.Info.alts) do
+-- 		if alt.mail and alt.mail.items then
+-- 			-- Search for matching ID
+-- 			for _, item in ipairs(alt.mail.items) do
+-- 				if item.ID == itemID then
+-- 					local count = item.Count
+-- 					inMail = inMail + count
+-- 					table.insert(alts, { name = name, count = count, lastScan = alt.mail.lastScan or 0 })
+-- 					break -- Found the item, no need to continue
+-- 				end
+-- 			end
+-- 		end
+-- 	end
+
+-- 	local needed = request.quantity - (request.fulfilled or 0)
+
+-- 	return { inMail = inMail, canFulfillFromMail = inMail >= needed, alts = alts }
+-- end
\ No newline at end of file
diff --git a/Modules/Tests.lua b/Modules/Tests.lua
index dee1aa4..f4f6642 100644
--- a/Modules/Tests.lua
+++ b/Modules/Tests.lua
@@ -1,19 +1,25 @@
-GBankClassic_Tests = {}
+GBankClassic_Tests = GBankClassic_Tests or {}
+
 local Tests = GBankClassic_Tests
 
--- Proxy to access addon after it loads (Core loads after Tests in TOC)
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("GetServerTime")
+local GetServerTime = upvalues.GetServerTime
+
+-- Proxy to access addon after it loads (core loads after tests)
 local addon = setmetatable({}, {
     __index = function(_, key)
         return GBankClassic_Core and GBankClassic_Core[key]
     end
 })
 
--- Direct module references (these exist before Core)
+-- Direct module references (these exist before core)
 local Guild = GBankClassic_Guild
 local Database = GBankClassic_Database
+local DeltaComms = GBankClassic_DeltaComms
 
 -- Helper function for deep table copy
-local function TableCopy(src, dest)
+local function copyTable(src, dest)
     if type(src) ~= "table" then
         return src
     end
@@ -21,17 +27,18 @@ local function TableCopy(src, dest)
     dest = dest or {}
     for k, v in pairs(src) do
         if type(v) == "table" then
-            dest[k] = TableCopy(v)
+            dest[k] = copyTable(v)
         else
             dest[k] = v
         end
     end
+
     return dest
 end
 
 -- Test framework
+local saved = {}
 local testResults = {}
-local currentTest = nil
 
 local function assert(condition, message)
     if not condition then
@@ -59,7 +66,6 @@ local function assertNil(value, message)
 end
 
 local function runTest(testName, testFunc)
-    currentTest = testName
     local success, err = pcall(testFunc)
 
     if success then
@@ -69,17 +75,11 @@ local function runTest(testName, testFunc)
         table.insert(testResults, {name = testName, passed = false, error = err})
         addon:Print("|cffff0000|r " .. testName .. ": " .. tostring(err))
     end
-
-    currentTest = nil
 end
 
--- Helper function to create test data (matches actual Bank.lua structure)
+-- Helper function to create test data
 local function createTestItem(id, count, link)
-    return {
-        ID = id,
-        Count = count or 1,
-        Link = link or ("[Item " .. id .. "]")
-    }
+    return { ID = id, Count = count or 1, Link = link or ("[Item " .. id .. "]") }
 end
 
 local function createTestAltData(name)
@@ -103,19 +103,19 @@ local function createTestAltData(name)
 end
 
 --============================================================================
--- Phase 5.1: Delta Computation Tests
+-- Phase 5.1: Delta computation tests
 --============================================================================
 
 -- Test setup: Initialize guild context for delta tests
 local function setupDeltaTest(guildName)
     guildName = guildName or "TestGuild"
 
-    -- Ensure Guild.Info is initialized with the guild name
+    -- Ensure GBankClassic_Guild.Info is initialized with the guild name
     if not Guild.Info or Guild.Info.name ~= guildName then
         Guild.Info = { name = guildName }
     end
 
-    -- Mock Events:TriggerCallback if it doesn't exist (for ApplyDelta)
+    -- Mock events:TriggerCallback if it doesn't exist (for ApplyDelta)
     if GBankClassic_Events and not GBankClassic_Events.TriggerCallback then
         GBankClassic_Events.TriggerCallback = function() end
     end
@@ -123,6 +123,7 @@ local function setupDeltaTest(guildName)
     -- Database should already be initialized by addon, but ensure structure exists
     if not Database.db then
         addon:Print("|cffff0000ERROR: Database not initialized! Tests require addon to be loaded.|r")
+
         return nil
     end
 
@@ -131,7 +132,7 @@ local function setupDeltaTest(guildName)
         Database.db.factionrealm = {}
     end
 
-    -- Ensure guild entry exists (use Database:Reset to create proper structure)
+    -- Ensure guild entry exists (use GBankClassic_Database:Reset to create proper structure)
     if not Database.db.factionrealm[guildName] then
         Database:Reset(guildName)
     end
@@ -159,7 +160,7 @@ local function testDeltaComputationNoChanges()
     assertNotNil(retrieved, "Snapshot should be retrievable after save")
 
     -- Create identical "new" data
-    local newData = TableCopy(oldData)
+    local newData = copyTable(oldData)
 
     -- Compute delta
     local delta = Guild:ComputeDelta("TestAlt1", newData)
@@ -168,7 +169,6 @@ local function testDeltaComputationNoChanges()
     assertEquals("alt-delta", delta.type, "Delta type should be alt-delta")
     assertEquals("TestAlt1", delta.name, "Delta name should match")
     assertNotNil(delta.version, "Delta should have version")
-    -- baseVersion is optional in v0.8.0 (removed for bandwidth savings)
     assert(not Guild:DeltaHasChanges(delta), "Delta should have no changes")
 end
 
@@ -185,7 +185,7 @@ local function testDeltaComputationMoneyChange()
     assert(saved, "Failed to save snapshot")
 
     -- Create new data with money change
-    local newData = TableCopy(oldData)
+    local newData = copyTable(oldData)
     newData.money = 200000
 
     -- Compute delta
@@ -209,7 +209,7 @@ local function testDeltaComputationItemAdded()
     assert(saved, "Failed to save snapshot")
 
     -- Create new data with added item
-    local newData = TableCopy(oldData)
+    local newData = copyTable(oldData)
     table.insert(newData.bank.items, createTestItem(2996, 5, "[Bolt of Linen Cloth]"))
 
     -- Compute delta
@@ -235,7 +235,7 @@ local function testDeltaComputationItemRemoved()
     assert(saved, "Failed to save snapshot")
 
     -- Create new data with removed item
-    local newData = TableCopy(oldData)
+    local newData = copyTable(oldData)
     table.remove(newData.bank.items, 1) -- Remove first item
 
     -- Compute delta
@@ -261,7 +261,7 @@ local function testDeltaComputationItemCountChanged()
     assert(saved, "Failed to save snapshot")
 
     -- Create new data with changed item count
-    local newData = TableCopy(oldData)
+    local newData = copyTable(oldData)
     newData.bank.items[1].Count = 25 -- Change from 20 to 25
 
     -- Compute delta
@@ -288,9 +288,9 @@ local function testDeltaComputationMultipleChanges()
     assert(saved, "Failed to save snapshot")
 
     -- Create new data with multiple changes
-    local newData = TableCopy(oldData)
-    newData.money = 300000  -- Money change
-    newData.bank.items[1].Count = 30  -- Count change
+    local newData = copyTable(oldData)
+    newData.money = 300000 -- Money change
+    newData.bank.items[1].Count = 30 -- Count change
     table.insert(newData.bank.items, createTestItem(2996, 5, "[Bolt of Linen Cloth]"))  -- Add item
     table.remove(newData.bags.items, 1)  -- Remove item
 
@@ -320,7 +320,7 @@ end
 
 local function testGetChangedFields()
     local oldItem = createTestItem(2589, 20, "[Linen Cloth]")
-    local newItem = TableCopy(oldItem)
+    local newItem = copyTable(oldItem)
     newItem.Count = 25
 
     local changes = Guild:GetChangedFields(oldItem, newItem)
@@ -332,7 +332,7 @@ local function testGetChangedFields()
 end
 
 --============================================================================
--- Phase 5.2: Size Estimation Tests
+-- Phase 5.2: Size estimation tests
 --============================================================================
 
 local function testSizeEstimationEmpty()
@@ -394,7 +394,7 @@ local function testSizeEstimationComparison()
 end
 
 --============================================================================
--- Phase 5.3: Protocol Negotiation Tests
+-- Phase 5.3: Protocol negotiation tests
 --============================================================================
 
 local function testProtocolVersionDetection()
@@ -419,68 +419,8 @@ local function testProtocolVersionDetection()
     assertNil(unknownProtocol, "Unknown user should have nil protocol")
 end
 
-local function testShouldUseDeltaLogic()
-    local guildName = setupDeltaTest()
-    if not guildName then
-        error("Test setup failed - database not initialized")
-    end
-
-    -- Setup Guild.Info
-    Guild.Info = Guild.Info or {}
-    Guild.Info.name = guildName
-
-    -- Mock guild support at 60% (above 10% threshold)
-    local oldGetGuildDeltaSupport = Database.GetGuildDeltaSupport
-    Database.GetGuildDeltaSupport = function(name)
-        return 0.6  -- 60% support
-    end
-
-    -- Test with delta enabled
-    local oldEnabled = FEATURES.DELTA_ENABLED
-    local oldForce = FEATURES.FORCE_FULL_SYNC
-    FEATURES.DELTA_ENABLED = true
-    FEATURES.FORCE_FULL_SYNC = false
-
-    -- ShouldUseDelta takes no parameters
-    local shouldUse = Guild:ShouldUseDelta()
-    assert(shouldUse, "Should use delta when conditions are met")
-
-    -- Test with delta disabled
-    FEATURES.DELTA_ENABLED = false
-    shouldUse = Guild:ShouldUseDelta()
-    assert(not shouldUse, "Should not use delta when disabled")
-
-    -- Test with force full sync
-    FEATURES.DELTA_ENABLED = true
-    FEATURES.FORCE_FULL_SYNC = true
-    shouldUse = Guild:ShouldUseDelta()
-    assert(not shouldUse, "Should not use delta when forced full sync")
-
-    -- Restore
-    FEATURES.DELTA_ENABLED = oldEnabled
-    FEATURES.FORCE_FULL_SYNC = oldForce
-    Database.GetGuildDeltaSupport = oldGetGuildDeltaSupport
-end
-
-local function testDeltaSupportThreshold()
-    -- Test threshold comparison logic
-    -- PROTOCOL.DELTA_SUPPORT_THRESHOLD is 0.05 (5%)
-
-    -- Test below threshold (3%)
-    local support = 0.03
-    assert(support < PROTOCOL.DELTA_SUPPORT_THRESHOLD, "3% should be below 5% threshold")
-
-    -- Test above threshold (10%)
-    support = 0.10
-    assert(support >= PROTOCOL.DELTA_SUPPORT_THRESHOLD, "10% should be above 5% threshold")
-
-    -- Test exact threshold (5%)
-    support = 0.05
-    assert(support >= PROTOCOL.DELTA_SUPPORT_THRESHOLD, "5% should meet 5% threshold")
-end
-
 --============================================================================
--- Phase 5.4: Error Handling Tests
+-- Phase 5.4: Error handling tests
 --============================================================================
 
 local function testApplyDeltaNoExistingData()
@@ -489,7 +429,7 @@ local function testApplyDeltaNoExistingData()
         error("Test setup failed - database not initialized")
     end
 
-    -- Ensure Guild.Info.alts exists but is empty
+    -- Ensure GBankClassic_Guild.Info.alts exists but is empty
     if not Guild.Info.alts then
         Guild.Info.alts = {}
     end
@@ -502,7 +442,7 @@ local function testApplyDeltaNoExistingData()
         changes = {}
     }
 
-    -- Should fail because no existing data in Info.alts
+    -- Should fail because no existing data in GBankClassic_Guild.alts
     local result = Guild:ApplyDelta("NonExistent-TestRealm", delta, "Sender-TestRealm")
     assert(result ~= "APPLIED", "Should not apply when no existing data")
 end
@@ -517,7 +457,7 @@ local function testApplyDeltaVersionMismatch()
     local existingData = createTestAltData("TestAlt")
     existingData.version = 5
 
-    -- Set up Guild.Info.alts with the existing data
+    -- Set up GBankClassic_Guild.Info.alts with the existing data
     if not Guild.Info.alts then
         Guild.Info.alts = {}
     end
@@ -561,12 +501,12 @@ local function testSnapshotValidation()
     assert(Database:ValidateSnapshot(validSnapshot), "Valid snapshot should pass")
 
     -- Invalid: missing version
-    local invalidSnapshot1 = TableCopy(validSnapshot)
+    local invalidSnapshot1 = copyTable(validSnapshot)
     invalidSnapshot1.version = nil
     assert(not Database:ValidateSnapshot(invalidSnapshot1), "Missing version should fail")
 
     -- Invalid: version not a number
-    local invalidSnapshot2 = TableCopy(validSnapshot)
+    local invalidSnapshot2 = copyTable(validSnapshot)
     invalidSnapshot2.version = "not a number"
     assert(not Database:ValidateSnapshot(invalidSnapshot2), "Non-numeric version should fail")
 
@@ -589,7 +529,7 @@ local function testDeltaStructureValidation()
             money = 100000
         }
     }
-    local valid, err = addon:ValidateDeltaStructure(validDelta)
+    local valid, err = DeltaComms:ValidateDeltaStructure(validDelta)
     assert(valid, "Valid delta should pass: " .. tostring(err))
 
     -- Invalid: missing type
@@ -599,7 +539,7 @@ local function testDeltaStructureValidation()
         baseVersion = 1,
         changes = {}
     }
-    valid, err = addon:ValidateDeltaStructure(invalidDelta1)
+    valid, err = DeltaComms:ValidateDeltaStructure(invalidDelta1)
     assert(not valid, "Missing type should fail")
 
     -- Invalid: wrong type
@@ -610,7 +550,7 @@ local function testDeltaStructureValidation()
         baseVersion = 1,
         changes = {}
     }
-    valid, err = addon:ValidateDeltaStructure(invalidDelta2)
+    valid, err = DeltaComms:ValidateDeltaStructure(invalidDelta2)
     assert(not valid, "Wrong type should fail")
 
     -- Invalid: missing name
@@ -620,7 +560,7 @@ local function testDeltaStructureValidation()
         baseVersion = 1,
         changes = {}
     }
-    valid, err = addon:ValidateDeltaStructure(invalidDelta3)
+    valid, err = DeltaComms:ValidateDeltaStructure(invalidDelta3)
     assert(not valid, "Missing name should fail")
 
     -- Invalid: non-numeric version
@@ -631,24 +571,24 @@ local function testDeltaStructureValidation()
         baseVersion = 1,
         changes = {}
     }
-    valid, err = addon:ValidateDeltaStructure(invalidDelta4)
+    valid, err = DeltaComms:ValidateDeltaStructure(invalidDelta4)
     assert(not valid, "Non-numeric version should fail")
 end
 
 --============================================================================
--- Phase 5.5: Integration Tests
+-- Phase 5.5: Integration tests
 --============================================================================
 
 local function testFullDeltaRoundtrip()
     setupDeltaTest("TestGuild")
 
     local name = "IntegrationTest"
-    local norm = Guild:NormalizeName(name)  -- Use Guild's NormalizeName which adds realm suffix
+    local norm = Guild:NormalizeName(name) -- Adds realm suffix
 
     -- Create initial data with proper structure
     local oldData = createTestAltData(name)
     oldData.version = 1
-    oldData.money = 100000  -- Money is at root level, not in bank
+    oldData.money = 100000 -- Money is at root level, not in bank
     oldData.bank.items = oldData.bank.items or {}
     -- Keep only first bank item
     oldData.bank.items[2] = nil
@@ -656,15 +596,15 @@ local function testFullDeltaRoundtrip()
     -- Keep both bag items (from createTestAltData)
     Database:SaveSnapshot("TestGuild", name, oldData)
 
-    -- Setup Guild.Info for ApplyDelta with a deep copy
+    -- Setup GBankClassic_Guild.Info for ApplyDelta with a deep copy
     Guild.Info.name = "TestGuild"
     Guild.Info.alts = Guild.Info.alts or {}
-    Guild.Info.alts[norm] = TableCopy(oldData)
+    Guild.Info.alts[norm] = copyTable(oldData)
 
     -- Make changes
-    local newData = TableCopy(oldData)
+    local newData = copyTable(oldData)
     newData.version = 2
-    newData.money = 200000  -- Money is at root level
+    newData.money = 200000 -- Money is at root level
     -- Add new item to bank (append to array)
     table.insert(newData.bank.items, createTestItem(2996, 5))
     -- Remove first bag item
@@ -680,67 +620,30 @@ local function testFullDeltaRoundtrip()
     assertNotNil(delta.changes, "Delta should have changes")
     assertEquals(200000, delta.changes.money, "Delta should contain money change")
 
-    -- Apply delta (modifies Guild.Info.alts[norm] in place)
+    -- Apply delta (modifies GBankClassic_Guild.Info.alts[norm] in place)
     local status = Guild:ApplyDelta(name, delta, "sender")
     -- ApplyDelta returns ADOPTION_STATUS values, not boolean
-    -- Just check it didn't return INVALID
+    -- Just check it didn't return invalid
 
-    -- Verify changes through Guild.Info.alts
+    -- Verify changes through GBankClassic_Guild.Info.alts
     local appliedData = Guild.Info.alts[norm]
-    assertNotNil(appliedData, "Data should be in Guild.Info.alts")
+    assertNotNil(appliedData, "Data should be in GBankClassic_Guild.Info.alts")
     assertEquals(200000, appliedData.money, "Money should be updated")
     -- Bank should now have 2 items (originally had 1, added 1)
     assertEquals(2, #appliedData.bank.items, "Bank should have 2 items")
     -- Bag items should have 1 item (originally had 2, removed 1)
-    assertEquals(1, #appliedData.bags.items, "Bags should have 1 item (TESTS ITEM REMOVAL)")
+    assertEquals(1, #appliedData.bags.items, "Bags should have 1 item (tests item removal)")
     assertEquals(2, appliedData.version, "Version should be updated")
 end
 
-local function testDeltaSizeThreshold()
-    setupDeltaTest("TestGuild")
-
-    local name = "SizeTest"
-    local oldData = createTestAltData(name)
-    oldData.version = 1
-    oldData.money = 100000
-    -- Add many items to increase full size
-    for i = 3, 20 do
-        oldData.bank.items[i] = createTestItem(2589 + i, 1)
-    end
-    Database:SaveSnapshot("TestGuild", name, oldData)
-
-    local newData = TableCopy(oldData)
-    newData.version = 2
-    newData.money = 200000  -- Just change money
-
-    local delta = Guild:ComputeDelta(name, newData)
-    assertNotNil(delta, "Delta should be computed")
-    assertNotNil(delta.changes, "Delta should have changes")
-    assertEquals(200000, delta.changes.money, "Delta should have money change")
-
-    local fullSize = Guild:EstimateSize(newData)
-    local deltaSize = Guild:EstimateSize(delta)
-    local ratio = deltaSize / fullSize
-
-    -- With many items, a money-only delta should be small relative to full data
-    assert(ratio < PROTOCOL.MIN_DELTA_SIZE_RATIO,
-        string.format(
-            "Money-only change should be below %.0f%% threshold (actual: %.1f%%, deltaSize=%d, fullSize=%d)",
-            PROTOCOL.MIN_DELTA_SIZE_RATIO * 100,
-            ratio * 100,
-            deltaSize,
-            fullSize
-        ))
-end
-
 --============================================================================
--- Phase 5.6: Backwards Compatibility Tests
+-- Phase 5.6: Backwards compatibility tests
 --============================================================================
 
 local function testV1ClientIgnoresDeltaPrefix()
     setupDeltaTest("TestGuild")
 
-    -- Setup Guild.Info
+    -- Setup GBankClassic_Guild.Info
     Guild.Info = Guild.Info or {}
     Guild.Info.name = "TestGuild"
 
@@ -766,103 +669,109 @@ local function testV2ClientHandlesBothProtocols()
     assert(PROTOCOL.SUPPORTS_DELTA, "Current protocol should support delta")
 end
 
-local function testFallbackToFullSync()
-    setupDeltaTest("TestGuild")
+--============================================================================
+-- Test runner
+--============================================================================
 
-    -- Setup Guild.Info
-    Guild.Info = Guild.Info or {}
-    Guild.Info.name = "TestGuild"
+function Tests:RunAllTests()
+    -- Snapshot key global state so tests don't pollute the addon runtime
+    saved.GuildInfo = copyTable(GBankClassic_Guild and GBankClassic_Guild.Info or {})
+    saved.DatabaseDb = copyTable(GBankClassic_Database and GBankClassic_Database.db or {})
+    saved.TriggerCallback = (GBankClassic_Events and GBankClassic_Events.TriggerCallback) or nil
+
+    -- Run the tests (wrapped in pcall to ensure cleanup happens)
+    local ok, res = pcall(function()
+        testResults = {}
+        addon:Print("=== Running GBankClassic tests for delta sync ===")
+
+        -- Phase 5.1: Delta computation
+        addon:Print("\n|cff00ffffPhase 5.1: Delta computation tests|r")
+        runTest("Delta computation - No changes", testDeltaComputationNoChanges)
+        runTest("Delta computation - Money change", testDeltaComputationMoneyChange)
+        runTest("Delta computation - Item added", testDeltaComputationItemAdded)
+        runTest("Delta computation - Item removed", testDeltaComputationItemRemoved)
+        runTest("Delta computation - Item count changed", testDeltaComputationItemCountChanged)
+        runTest("Delta computation - Multiple changes", testDeltaComputationMultipleChanges)
+        runTest("Items equal - Comparison", testItemsEqual)
+        runTest("Get changed fields", testGetChangedFields)
+
+        -- Phase 5.2: Size estimation
+        addon:Print("\n|cff00ffffPhase 5.2: Size estimation tests|r")
+        runTest("Size estimation - Empty", testSizeEstimationEmpty)
+        runTest("Size estimation - Small delta", testSizeEstimationSmallDelta)
+        runTest("Size estimation - Large delta", testSizeEstimationLargeDelta)
+        runTest("Size estimation - Comparison", testSizeEstimationComparison)
+
+        -- Phase 5.3: Protocol negotiation
+        addon:Print("\n|cff00ffffPhase 5.3: Protocol negotiation tests|r")
+        runTest("Protocol version detection", testProtocolVersionDetection)
+
+        -- Phase 5.4: Error handling
+        addon:Print("\n|cff00ffffPhase 5.4: Error handling tests|r")
+        runTest("Apply delta - No existing data", testApplyDeltaNoExistingData)
+        runTest("Apply delta - Version mismatch", testApplyDeltaVersionMismatch)
+        runTest("Delta error tracking", testDeltaErrorTracking)
+        runTest("Snapshot validation", testSnapshotValidation)
+        runTest("Delta structure validation", testDeltaStructureValidation)
+
+        -- Phase 5.5: Integration tests
+        addon:Print("\n|cff00ffffPhase 5.5: Integration tests|r")
+        runTest("Full delta roundtrip", testFullDeltaRoundtrip)
+
+        -- Phase 5.6: Backwards compatibility
+        addon:Print("\n|cff00ffffPhase 5.6: Backwards compatibility tests|r")
+        runTest("V1 Client ignores delta prefix", testV1ClientIgnoresDeltaPrefix)
+        runTest("V2 Client handles both protocols", testV2ClientHandlesBothProtocols)
+
+        -- Summary
+        local passed = 0
+        local failed = 0
+        for _, result in ipairs(testResults) do
+            if result.passed then
+                passed = passed + 1
+            else
+                failed = failed + 1
+            end
+        end
 
-    -- v0.8.0: Guild support threshold removed - delta always enabled if feature flag is on
-    -- This test now validates that delta is enabled regardless of guild support percentage
-    local oldGetGuildDeltaSupport = Database.GetGuildDeltaSupport
-    Database.GetGuildDeltaSupport = function(name)
-        return 0  -- 0% support
-    end
+        addon:Print(string.format("\n|cff00ffff=== Test summary ===|r\nTotal: %d | |cff00ff00Passed: %d|r | |cffff0000Failed: %d|r",
+            passed + failed, passed, failed))
 
-    -- Should still use delta in v0.8.0 (threshold check removed)
-    local shouldUse = Guild:ShouldUseDelta()
-    assert(shouldUse, "v0.8.0: Should use delta even with 0% guild support (threshold removed)")
+        if failed > 0 then
+            addon:Print("|cffff0000Some tests failed. See output above for details.|r")
+        else
+            addon:Print("|cff00ff00All tests passed!|r")
+        end
 
-    -- Restore
-    Database.GetGuildDeltaSupport = oldGetGuildDeltaSupport
-end
+        return failed == 0
+    end)
 
---============================================================================
--- Test Runner
---============================================================================
+    -- Always restore globals, even if tests errored
+    if saved then
+        if saved.GuildInfo then
+            if not GBankClassic_Guild then
+                GBankClassic_Guild = {}
+            end
+            GBankClassic_Guild.Info = copyTable(saved.GuildInfo)
+        end
 
-function Tests:RunAllTests()
-    testResults = {}
-    addon:Print("=== Running GBank Delta Sync Tests ===")
-
-    -- Phase 5.1: Delta Computation
-    addon:Print("\n|cff00ffffPhase 5.1: Delta Computation Tests|r")
-    runTest("Delta Computation - No Changes", testDeltaComputationNoChanges)
-    runTest("Delta Computation - Money Change", testDeltaComputationMoneyChange)
-    runTest("Delta Computation - Item Added", testDeltaComputationItemAdded)
-    runTest("Delta Computation - Item Removed", testDeltaComputationItemRemoved)
-    runTest("Delta Computation - Item Count Changed", testDeltaComputationItemCountChanged)
-    runTest("Delta Computation - Multiple Changes", testDeltaComputationMultipleChanges)
-    runTest("Items Equal - Comparison", testItemsEqual)
-    runTest("Get Changed Fields", testGetChangedFields)
-
-    -- Phase 5.2: Size Estimation
-    addon:Print("\n|cff00ffffPhase 5.2: Size Estimation Tests|r")
-    runTest("Size Estimation - Empty", testSizeEstimationEmpty)
-    runTest("Size Estimation - Small Delta", testSizeEstimationSmallDelta)
-    runTest("Size Estimation - Large Delta", testSizeEstimationLargeDelta)
-    runTest("Size Estimation - Comparison", testSizeEstimationComparison)
-
-    -- Phase 5.3: Protocol Negotiation
-    addon:Print("\n|cff00ffffPhase 5.3: Protocol Negotiation Tests|r")
-    runTest("Protocol Version Detection", testProtocolVersionDetection)
-    runTest("Should Use Delta Logic", testShouldUseDeltaLogic)
-    runTest("Delta Support Threshold", testDeltaSupportThreshold)
-
-    -- Phase 5.4: Error Handling
-    addon:Print("\n|cff00ffffPhase 5.4: Error Handling Tests|r")
-    runTest("Apply Delta - No Existing Data", testApplyDeltaNoExistingData)
-    runTest("Apply Delta - Version Mismatch", testApplyDeltaVersionMismatch)
-    runTest("Delta Error Tracking", testDeltaErrorTracking)
-    runTest("Snapshot Validation", testSnapshotValidation)
-    runTest("Delta Structure Validation", testDeltaStructureValidation)
-
-    -- Phase 5.5: Integration Tests
-    addon:Print("\n|cff00ffffPhase 5.5: Integration Tests|r")
-    runTest("Full Delta Roundtrip", testFullDeltaRoundtrip)
-    runTest("Delta Size Threshold", testDeltaSizeThreshold)
-
-    -- Phase 5.6: Backwards Compatibility
-    addon:Print("\n|cff00ffffPhase 5.6: Backwards Compatibility Tests|r")
-    runTest("V1 Client Ignores Delta Prefix", testV1ClientIgnoresDeltaPrefix)
-    runTest("V2 Client Handles Both Protocols", testV2ClientHandlesBothProtocols)
-    runTest("Fallback to Full Sync", testFallbackToFullSync)
-
-    -- Summary
-    local passed = 0
-    local failed = 0
-    for _, result in ipairs(testResults) do
-        if result.passed then
-            passed = passed + 1
-        else
-            failed = failed + 1
+        if saved.DatabaseDb then
+            if not GBankClassic_Database then
+                GBankClassic_Database = {}
+            end
+            GBankClassic_Database.db = copyTable(saved.DatabaseDb)
         end
-    end
 
-    addon:Print(string.format("\n|cff00ffff=== Test Summary ===|r\nTotal: %d | |cff00ff00Passed: %d|r | |cffff0000Failed: %d|r",
-        passed + failed, passed, failed))
+        if GBankClassic_Events and saved.TriggerCallback ~= nil then
+            GBankClassic_Events.TriggerCallback = saved.TriggerCallback
+        end
+    end
 
-    if failed > 0 then
-        addon:Print("|cffff0000Some tests failed. See output above for details.|r")
+    if ok then
+        return res
     else
-        addon:Print("|cff00ff00All tests passed!|r")
+        error(res)
     end
-
-    addon:Print("\nBe sure to /reload before proceeding!\n")
-    -- TODO: reset data to avoid UI errors when opening /bank after running /bank test
-
-    return failed == 0
 end
 
 function Tests:RunTest(testName)
@@ -882,18 +791,14 @@ function Tests:RunTest(testName)
         ["size-large"] = testSizeEstimationLargeDelta,
         ["size-compare"] = testSizeEstimationComparison,
         ["protocol-detect"] = testProtocolVersionDetection,
-        ["should-delta"] = testShouldUseDeltaLogic,
-        ["support-threshold"] = testDeltaSupportThreshold,
         ["error-no-data"] = testApplyDeltaNoExistingData,
         ["error-version"] = testApplyDeltaVersionMismatch,
         ["error-tracking"] = testDeltaErrorTracking,
         ["snapshot-validate"] = testSnapshotValidation,
         ["delta-validate"] = testDeltaStructureValidation,
         ["roundtrip"] = testFullDeltaRoundtrip,
-        ["size-threshold"] = testDeltaSizeThreshold,
         ["v1-ignore"] = testV1ClientIgnoresDeltaPrefix,
         ["v2-both"] = testV2ClientHandlesBothProtocols,
-        ["fallback"] = testFallbackToFullSync,
     }
 
     local testFunc = tests[testName]
diff --git a/Modules/UI.lua b/Modules/UI.lua
index 32d0d5a..8b590ab 100644
--- a/Modules/UI.lua
+++ b/Modules/UI.lua
@@ -1,14 +1,36 @@
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("LibStub")
+local LibStub = upvalues.LibStub
+local upvalues = Globals.GetUpvalues("CreateFrame", "IsShiftKeyDown", "ChatEdit_InsertLink", "IsControlKeyDown", "DressUpItemLink", "PickupItem", "GetItemInfo", "GetItemQualityColor", "GameTooltip_SetDefaultAnchor")
+local CreateFrame = upvalues.CreateFrame
+local IsShiftKeyDown = upvalues.IsShiftKeyDown
+local ChatEdit_InsertLink = upvalues.ChatEdit_InsertLink
+local IsControlKeyDown = upvalues.IsControlKeyDown
+local DressUpItemLink = upvalues.DressUpItemLink
+local PickupItem = upvalues.PickupItem
+local GetItemInfo = upvalues.GetItemInfo
+local GetItemQualityColor = upvalues.GetItemQualityColor
+local GameTooltip_SetDefaultAnchor = upvalues.GameTooltip_SetDefaultAnchor
+local upvalues = Globals.GetUpvalues("UIParent", "UISpecialFrames", "WorldFrame", "GameTooltip")
+local UIParent = upvalues.UIParent
+local UISpecialFrames = upvalues.UISpecialFrames
+local WorldFrame = upvalues.WorldFrame
+local GameTooltip = upvalues.GameTooltip
+
 GBankClassic_UI = LibStub("AceGUI-3.0")
 
-function GBankClassic_UI:Init()
+local UI = GBankClassic_UI
+
+function UI:Init()
     GBankClassic_UI_Minimap:Init()
     GBankClassic_UI_Inventory:Init()
     GBankClassic_UI_Donations:Init()
+	-- GBankClassic_UI_Requests:Init()
     GBankClassic_UI_Search:Init()
     GBankClassic_UI_Mail:Init()
 end
 
-function GBankClassic_UI:Controller()
+function UI:Controller()
     local controller = CreateFrame("Frame", "GBankClassic", UIParent)
     controller:SetScript("OnHide", function()
         GBankClassic_UI_Inventory:Close()
@@ -16,7 +38,7 @@ function GBankClassic_UI:Controller()
     table.insert(UISpecialFrames, "GBankClassic")
 end
 
-function GBankClassic_UI:EventHandler(self, event, ...)
+function UI:EventHandler(self, event, ...)
     if event == "OnClick" then
         if IsShiftKeyDown() then
             ChatEdit_InsertLink(self.link)
@@ -37,7 +59,7 @@ function GBankClassic_UI:EventHandler(self, event, ...)
     end
 end
 
-function GBankClassic_UI:DrawItem(item, parent, size, height, imageSize, imageHeight, labelXOffset, labelYOffset)
+function UI:DrawItem(item, parent, size, height, imageSize, imageHeight, labelXOffset, labelYOffset)
     if not size then
         size = 40
     end
@@ -62,7 +84,7 @@ function GBankClassic_UI:DrawItem(item, parent, size, height, imageSize, imageHe
         labelYOffset = 0
     end
 
-    local slot = GBankClassic_UI:Create("Icon")
+    local slot = self:Create("Icon")
     local label = slot.label
     local image = slot.image
     local frame = slot.frame
@@ -79,24 +101,34 @@ function GBankClassic_UI:DrawItem(item, parent, size, height, imageSize, imageHe
     else
         slot:SetLabel(" ")
     end
-    slot:SetImage(item.Info.icon)
+	
+	-- Generate link on-demand if needed (synchronous from cache if available)
+	if item.ID and not item.Link then
+		GBankClassic_Guild:ReconstructItemLink(item)
+	end
+
+	-- Get icon if available, otherwise try to fetch from item ID
+	local icon = (item.Info and item.Info.icon) or select(10, GetItemInfo(item.ID or 0))
+	if icon then
+		slot:SetImage(icon)
+	end
     slot:SetImageSize(imageSize, imageHeight)
     slot:SetWidth(size)
     slot:SetHeight(height)
 
     if item.Link then
         slot:SetCallback("OnEnter", function()
-            GBankClassic_UI:ShowItemTooltip(item.Link) 
+            self:ShowItemTooltip(item.Link) 
         end)
         slot:SetCallback("OnLeave", function()
-            GBankClassic_UI:HideTooltip()
+            self:HideTooltip()
         end)
         slot:SetCallback("OnClick", function(self, event)
-            GBankClassic_UI:EventHandler(self, event)
+            self:EventHandler(self, event)
         end)
         frame:RegisterForDrag("LeftButton")
         frame:SetScript("OnDragStart", function(_)
-            GBankClassic_UI:EventHandler(slot, "OnDragStart")
+            self:EventHandler(slot, "OnDragStart")
         end)
     end
     slot.info = item.Info
@@ -118,21 +150,22 @@ function GBankClassic_UI:DrawItem(item, parent, size, height, imageSize, imageHe
 	return slot
 end
 
-function GBankClassic_UI:ShowItemTooltip(link)
+function UI:ShowItemTooltip(link)
     if not link then
         return
     end
+    
     GameTooltip:SetOwner(WorldFrame, "ANCHOR_CURSOR")
     GameTooltip:SetHyperlink(link)
     GameTooltip:Show()
 end
 
-function GBankClassic_UI:HideTooltip()
+function UI:HideTooltip()
     GameTooltip:Hide()
     GameTooltip_SetDefaultAnchor(GameTooltip, UIParent)
 end
 
-function GBankClassic_UI:OnInsertLink(link)
+function UI:OnInsertLink(link)
     if GBankClassic_UI_Search.searchField and GBankClassic_UI_Search.searchField.editbox:HasFocus() then
         GBankClassic_UI_Search.SearchText = link
         GBankClassic_UI_Search:DrawContent()
diff --git a/Modules/UI/Donations.lua b/Modules/UI/Donations.lua
index ab230ed..fea6009 100644
--- a/Modules/UI/Donations.lua
+++ b/Modules/UI/Donations.lua
@@ -1,15 +1,21 @@
-GBankClassic_UI_Donations = {}
+GBankClassic_UI_Donations = GBankClassic_UI_Donations or {}
 
-function GBankClassic_UI_Donations:Init()
+local UI_Donations = GBankClassic_UI_Donations
+
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("GetClassColor")
+local GetClassColor = upvalues.GetClassColor
+
+function UI_Donations:Init()
     self:DrawWindow()
 end
 
-local function OnClose(_)
-    GBankClassic_UI_Donations.isOpen = false
-    GBankClassic_UI_Donations.Window:Hide()
+local function onClose(_)
+    UI_Donations.isOpen = false
+    UI_Donations.Window:Hide()
 end
 
-function GBankClassic_UI_Donations:Toggle()
+function UI_Donations:Toggle()
     if self.isOpen then
         self:Close()
     else
@@ -17,7 +23,7 @@ function GBankClassic_UI_Donations:Toggle()
     end
 end
 
-function GBankClassic_UI_Donations:Open()
+function UI_Donations:Open()
 	if self.isOpen then
 		return
 	end
@@ -43,26 +49,25 @@ function GBankClassic_UI_Donations:Open()
     end
 end
 
-function GBankClassic_UI_Donations:Close()
+function UI_Donations:Close()
 	if not self.isOpen then
 		return
 	end
-
 	if not self.Window then
 		return
 	end
 
-    OnClose(self.Window)
+    onClose(self.Window)
 
     if GBankClassic_UI_Inventory.isOpen == false then
         _G["GBankClassic"]:Hide()
     end
 end
 
-function GBankClassic_UI_Donations:DrawWindow()
+function UI_Donations:DrawWindow()
     local donations = GBankClassic_UI:Create("Frame")
     donations:Hide()
-    donations:SetCallback("OnClose", OnClose)
+    donations:SetCallback("OnClose", onClose)
     donations:SetTitle("Donations")
     donations:SetLayout("Flow")
     donations:SetWidth(350)
@@ -106,7 +111,7 @@ function GBankClassic_UI_Donations:DrawWindow()
     self.Content = content
 end
 
-function GBankClassic_UI_Donations:DrawContent()
+function UI_Donations:DrawContent()
     self.Window:SetStatusText("")
     self.Content:ReleaseChildren()
 
diff --git a/Modules/UI/Inventory.lua b/Modules/UI/Inventory.lua
index d3719f4..10b4cdc 100644
--- a/Modules/UI/Inventory.lua
+++ b/Modules/UI/Inventory.lua
@@ -1,26 +1,39 @@
-GBankClassic_UI_Inventory = {}
+GBankClassic_UI_Inventory = GBankClassic_UI_Inventory or {}
 
-function GBankClassic_UI_Inventory:Init()
+local UI_Inventory = GBankClassic_UI_Inventory
+
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("date")
+local date = upvalues.date
+local upvalues = Globals.GetUpvalues("GetServerTime", "GetCoinTextureString", "SecondsToTime", "IsShiftKeyDown", "IsControlKeyDown")
+local GetServerTime = upvalues.GetServerTime
+local GetCoinTextureString = upvalues.GetCoinTextureString
+local SecondsToTime = upvalues.SecondsToTime
+local IsShiftKeyDown = upvalues.IsShiftKeyDown
+local IsControlKeyDown = upvalues.IsControlKeyDown
+
+function UI_Inventory:Init()
     self:DrawWindow()
 end
 
-local function QueryEmpty()
+local function queryEmpty()
 	local now = GetServerTime()
-	local last = GBankClassic_UI_Inventory.last_empty_sync or 0
+	local last = UI_Inventory.last_empty_sync or 0
 	if now - last > 30 then
-		GBankClassic_UI_Inventory.last_empty_sync = now
+		UI_Inventory.last_empty_sync = now
 		GBankClassic_Guild:Share()
 	end
 end
 
-local function OnClose(_)
-    GBankClassic_UI_Inventory.isOpen = false
-    GBankClassic_UI_Inventory.Window:Hide()
+local function onClose(_)
+    UI_Inventory.isOpen = false
+    UI_Inventory.Window:Hide()
     GBankClassic_UI_Donations:Close()
+    -- GBankClassic_UI_Requests:Close()
     GBankClassic_UI_Search:Close()
 end
 
-function GBankClassic_UI_Inventory:Toggle()
+function UI_Inventory:Toggle()
     if self.isOpen then
         self:Close()
     else
@@ -28,7 +41,7 @@ function GBankClassic_UI_Inventory:Toggle()
     end
 end
 
-function GBankClassic_UI_Inventory:Open()
+function UI_Inventory:Open()
 	if self.isOpen then
 		return
 	end
@@ -52,26 +65,30 @@ function GBankClassic_UI_Inventory:Open()
     end
 end
 
-function GBankClassic_UI_Inventory:Close()
+function UI_Inventory:Close()
 	if not self.isOpen then
 		return
 	end
-    
 	if not self.Window then
 		return
 	end
 
-    OnClose(self.Window)
+    onClose(self.Window)
 end
 
-function GBankClassic_UI_Inventory:DrawWindow()
+function UI_Inventory:DrawWindow()
     local window = GBankClassic_UI:Create("Frame")
     window:Hide()
-    window:SetCallback("OnClose", OnClose)
+    window:SetCallback("OnClose", onClose)
     window:SetTitle("GBankClassic")
     window:SetLayout("Flow")
     window:SetWidth(550)
 
+	-- Persist window position/size across reloads
+	if GBankClassic_Options and GBankClassic_Options.db then
+		window:SetStatusTable(GBankClassic_Options.db.char.framePositions)
+	end
+    
     window.frame:SetResizeBounds(500, 500)
     window.frame:EnableKeyboard(true)
     window.frame:SetPropagateKeyboardInput(true)
@@ -118,6 +135,15 @@ function GBankClassic_UI_Inventory:DrawWindow()
     scoreboardButton:SetHeight(24)
     buttonContainer:AddChild(scoreboardButton)
 
+	-- local requestsButton = GBankClassic_UI:Create("Button")
+	-- requestsButton:SetText("Requests")
+	-- requestsButton:SetCallback("OnClick", function(_)
+	-- 	GBankClassic_UI_Requests:Toggle()
+	-- end)
+	-- requestsButton:SetWidth(175)
+	-- requestsButton:SetHeight(24)
+	-- buttonContainer:AddChild(requestsButton)
+
     local tabGroup = GBankClassic_UI:Create("TabGroup")
     tabGroup:SetLayout("Flow")
     tabGroup:SetFullWidth(true)
@@ -126,17 +152,19 @@ function GBankClassic_UI_Inventory:DrawWindow()
     self.TabGroup = tabGroup
 end
 
-function GBankClassic_UI_Inventory:DrawContent()
+function UI_Inventory:DrawContent()
     local info = GBankClassic_Guild.Info
 	local roster_alts = GBankClassic_Guild:GetRosterAlts()
 	if not info or not roster_alts then
-		QueryEmpty()
-		OnClose()
+		queryEmpty()
+		onClose()
 		GBankClassic_Output:Response("Database is empty; wait for sync.")
+
 		return
 	end
 
-    GBankClassic_UI_Search:BuildSearchData()
+    -- Rebuild search on next open
+	GBankClassic_UI_Search.searchDataBuilt = false
 
     local players = {}
     local n = 0
@@ -156,11 +184,11 @@ function GBankClassic_UI_Inventory:DrawContent()
     for _, player in pairs(players) do
 		local norm = GBankClassic_Guild:NormalizeName(player)
 		local alt = info.alts[norm]
-        if not first_tab then
-            first_tab = player
-        end
-        tabs[i] = { value = player, text = player }
-        if alt and _G.type(alt) == "table" then
+        if alt and type(alt) == "table" then
+            if not first_tab then
+                first_tab = player
+            end
+            tabs[i] = { value = player, text = player }
             if alt.money then
                 total_gold = total_gold + alt.money
             end
@@ -172,13 +200,13 @@ function GBankClassic_UI_Inventory:DrawContent()
                 slots = slots + alt.bags.slots.count
                 total_slots = total_slots + alt.bags.slots.total
             end
+            i = i + 1
         end
-        i = i + 1
     end
 
 	if #tabs == 0 then
-		QueryEmpty()
-		OnClose()
+		queryEmpty()
+		onClose()
 		GBankClassic_Output:Response("Database is empty; wait for sync.")
 
 		return
@@ -187,8 +215,13 @@ function GBankClassic_UI_Inventory:DrawContent()
     self.TabGroup:SetTabs(tabs)
 
 	local percent = total_slots > 0 and (slots / total_slots) or 0
-	local color = GBankClassic_UI_Inventory:GetPercentColor(percent)
-	local defaultStatus = string.format("%s    |c%s%d/%d|r", GetCoinTextureString(total_gold), color, slots, total_slots)
+	local color = self:GetPercentColor(percent)
+    local defaultStatus
+    if slots > 0 and total_slots > 0 then
+	    defaultStatus = string.format("%s    |c%s%d/%d|r", GetCoinTextureString(total_gold), color, slots, total_slots)
+    else
+	    defaultStatus = string.format("%s    |c%s|r", GetCoinTextureString(total_gold), color)
+    end
     self.Window:SetStatusText(defaultStatus)
 
     self.Window:SetCallback("OnEnterStatusBar", function(_)
@@ -211,13 +244,28 @@ function GBankClassic_UI_Inventory:DrawContent()
             slot_total = slot_total + alt.bags.slots.total
         end
 
+		-- Add mail item count if available
+		local mailCount = alt.mail and alt.mail.items and GBankClassic_Globals:Count(alt.mail.items) or 0
+
         local money = 0
         if alt.money then
             money = alt.money
         end
 
-        local color = GBankClassic_UI_Inventory:GetPercentColor(slot_count / slot_total)
-        local status = string.format("As of %s    %s    |c%s%d/%d|r", datetime, GetCoinTextureString(money), color, slot_count, slot_total)
+		local percent = slot_total > 0 and (slot_count / slot_total) or 0
+		local color = self:GetPercentColor(percent)
+		local mailText = ""
+		if mailCount > 0 then
+			local age = GBankClassic_MailInventory:GetMailDataAge(alt)
+			local ageText = age and (" (" .. SecondsToTime(age) .. " ago)") or ""
+			mailText = string.format("    |cff87ceeb %d item%s%s|r", mailCount, mailCount > 1 and "s" or "", ageText)
+		end
+        local status
+        if slot_count > 0 and slot_total > 0 then
+            status = string.format("As of %s    %s    |c%s%d/%d|r%s", datetime, GetCoinTextureString(money), color, slot_count, slot_total, mailText)
+        else
+            status = string.format("As of %s    %s    |c%s|r%s", datetime, GetCoinTextureString(money), color, mailText)
+        end
         self.Window:SetStatusText(status)
     end)
 
@@ -255,17 +303,87 @@ function GBankClassic_UI_Inventory:DrawContent()
             scroll:SetFullHeight(true)
             scroll:SetFullWidth(true)
             g:AddChild(scroll)
-
-            local bank = nil
-            if alt.bank then
-                bank = alt.bank.items
+            
+            local normTab = GBankClassic_Guild:NormalizeName(tab)
+            local alt = info.alts[normTab]
+            
+            -- Use alt.items if available
+            -- Otherwise compute from sources for backward compatibility
+            local items = {}
+            
+            if alt.items and next(alt.items) ~= nil then
+                -- Use alt.items directly (may be array or key-value)
+                for _, item in pairs(alt.items) do
+                    table.insert(items, item)
+                end
+                GBankClassic_Output:Debug("INVENTORY", "Inventory tab %s: using alt.items (%d items)", tab, #items)
+            else
+                -- Fallback: compute from sources (backward compatibility for very old data)
+                local bankItems = (alt.bank and alt.bank.items) or {}
+                local bagItems = (alt.bags and alt.bags.items) or {}
+                local mailItems = (alt.mail and alt.mail.items) or {}
+                
+                GBankClassic_Output:Debug("INVENTORY", "Inventory tab %s: computing from sources bank=%d, bags=%d, mail=%d", tab, #bankItems, #bagItems, #mailItems)
+                
+                -- Aggregate all sources (all are now in array format), then convert the key-value result to array
+                local aggregated = GBankClassic_Item:Aggregate(bankItems, bagItems)
+                aggregated = GBankClassic_Item:Aggregate(aggregated, mailItems)
+                for _, item in pairs(aggregated) do
+                    table.insert(items, item)
+                end
             end
-            if alt.bags then
-                local items = GBankClassic_Item:Aggregate(bank, alt.bags.items)
-                GBankClassic_Item:GetItems(items, function(list)
+            
+            GBankClassic_Output:Debug("INVENTORY", "Inventory tab %s: aggregated to %d unique items", tab, #items)
+            
+            if items and #items > 0 then
+                -- Check for duplicate item IDs with different links
+                local itemsByID = {}
+                for _, item in pairs(items) do
+                    if item and item.ID then
+                        if not itemsByID[item.ID] then
+                            itemsByID[item.ID] = {}
+                        end
+                        table.insert(itemsByID[item.ID], { Count = item.Count, Link = item.Link })
+                    end
+                end
+                for itemID, entries in pairs(itemsByID) do
+                    if #entries > 1 then
+                        GBankClassic_Output:Debug("INVENTORY", "Duplicate item ID %d found with %d different entries:", itemID, #entries)
+                        for i, entry in ipairs(entries) do
+                            GBankClassic_Output:Debug("INVENTORY", "  Entry %d: count=%d, link=%s", i, entry.Count, entry.Link or "nil")
+                        end
+                    end
+                end
+                
+                -- Validate and filter items before passing to GetItems
+                local validItems = {}
+                for i, item in ipairs(items) do
+                    if item and item.ID and item.ID > 0 then
+                        table.insert(validItems, item)
+                    else
+                        GBankClassic_Output:Debug("INVENTORY", "WARNING: Tab %s skipping invalid item at index %d (ID: %s, link: %s)", tab, i, tostring(item and item.ID or "nil item"), tostring(item and item.Link or "nil"))
+                    end
+                end
+                
+                GBankClassic_Item:GetItems(validItems, function(list)
+                    GBankClassic_Output:Debug("INVENTORY", "Inventory tab %s: GetItems callback received %d items", tab, list and #list or 0)
                     GBankClassic_Item:Sort(list)
+
                     for _, item in pairs(list) do
-                        GBankClassic_UI:DrawItem(item, scroll)
+                        if item and item.Info and item.Info.name then
+                            GBankClassic_Output:Debug("INVENTORY", "Inventory tab %s: displaying %s with count %d (ID: %d)", tab, item.Info.name, item.Count or 0, item.ID)
+                        end
+                        local itemWidget = GBankClassic_UI:DrawItem(item, scroll)
+                        if itemWidget then
+                            itemWidget:SetCallback("OnClick", function(widget, event)
+                                if IsShiftKeyDown() or IsControlKeyDown() then
+                                    GBankClassic_UI:EventHandler(widget, event)
+
+                                    return
+                                end
+                                -- GBankClassic_UI_Search:ShowRequestDialog(item, tab)
+                            end)
+                        end
                     end
                 end)
             end
@@ -284,7 +402,7 @@ function GBankClassic_UI_Inventory:DrawContent()
 	end
 end
 
-function GBankClassic_UI_Inventory:GetPercentColor(percent)
+function UI_Inventory:GetPercentColor(percent)
     local color = nil
     if percent <= 0.25 then
         color = "ffffffff"
@@ -297,5 +415,6 @@ function GBankClassic_UI_Inventory:GetPercentColor(percent)
     elseif percent > 0.9 then
         color = "ffff0000"
     end
+    
     return color
 end
\ No newline at end of file
diff --git a/Modules/UI/Mail.lua b/Modules/UI/Mail.lua
index 2b334c8..71afea7 100644
--- a/Modules/UI/Mail.lua
+++ b/Modules/UI/Mail.lua
@@ -1,15 +1,29 @@
-GBankClassic_UI_Mail = {}
-
-function GBankClassic_UI_Mail:Init()
+GBankClassic_UI_Mail = GBankClassic_UI_Mail or {}
+
+local UI_Mail = GBankClassic_UI_Mail
+
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("GetInboxHeaderInfo", "GetClassColor", "GetInboxText", "GetCoinTextureString", "GetInboxItem", "GetInboxItemLink", "GetItemInfoInstant")
+local GetInboxHeaderInfo = upvalues.GetInboxHeaderInfo
+local GetClassColor = upvalues.GetClassColor
+local GetInboxText = upvalues.GetInboxText
+local GetCoinTextureString = upvalues.GetCoinTextureString
+local GetInboxItem = upvalues.GetInboxItem
+local GetInboxItemLink = upvalues.GetInboxItemLink
+local GetItemInfoInstant = upvalues.GetItemInfoInstant
+local upvalues = Globals.GetUpvalues("ATTACHMENTS_MAX_RECEIVE")
+local ATTACHMENTS_MAX_RECEIVE = upvalues.ATTACHMENTS_MAX_RECEIVE
+
+function UI_Mail:Init()
     self:DrawWindow()
 end
 
-local function OnClose(_)
-    GBankClassic_UI_Mail.isOpen = false
-    GBankClassic_UI_Mail.Window:Hide()
+local function onClose(_)
+    UI_Mail.isOpen = false
+    UI_Mail.Window:Hide()
 end
 
-function GBankClassic_UI_Mail:Open()
+function UI_Mail:Open()
 	if self.isOpen then
 		return
 	end
@@ -27,26 +41,25 @@ function GBankClassic_UI_Mail:Open()
     self:RedrawContent()
 end
 
-function GBankClassic_UI_Mail:Close()
+function UI_Mail:Close()
 	if not self.isOpen then
 		return
 	end
-
 	if not self.Window then
 		return
 	end
 
-    OnClose(self.Window)
+    onClose(self.Window)
 end
 
-function GBankClassic_UI_Mail:SetMailId(id)
+function UI_Mail:SetMailId(id)
     self.MailId = id
 end
 
-function GBankClassic_UI_Mail:DrawWindow()
+function UI_Mail:DrawWindow()
     local window = GBankClassic_UI:Create("Frame")
     window:Hide()
-    window:SetCallback("OnClose", OnClose)
+    window:SetCallback("OnClose", onClose)
     window:SetTitle("Donation")
     window:SetLayout("Flow")
     window:SetWidth(440)
@@ -80,13 +93,13 @@ function GBankClassic_UI_Mail:DrawWindow()
     self.Content = content
 end
 
-function GBankClassic_UI_Mail:DrawContent()
+function UI_Mail:DrawContent()
     self.Content:ReleaseChildren()
     self.Content:ResumeLayout()
 
     local _, _, sender, subject, money = GetInboxHeaderInfo(self.MailId)
     if not sender then
-        GBankClassic_UI_Mail:RedrawContent()
+        self:RedrawContent()
 
         return
     end
@@ -210,12 +223,12 @@ function GBankClassic_UI_Mail:DrawContent()
     self.OpenButton:SetDisabled(false)
 end
 
-function GBankClassic_UI_Mail:RedrawContent()
+function UI_Mail:RedrawContent()
     GBankClassic_Core:ScheduleTimer(function(...)
-        GBankClassic_UI_Mail:OnTimer()
+        self:OnTimer()
     end, 0.25)
 end
 
-function GBankClassic_UI_Mail:OnTimer()
-    GBankClassic_UI_Mail:DrawContent()
+function UI_Mail:OnTimer()
+    self:DrawContent()
 end
\ No newline at end of file
diff --git a/Modules/UI/Minimap.lua b/Modules/UI/Minimap.lua
index 4dd1bc0..d02dc7e 100644
--- a/Modules/UI/Minimap.lua
+++ b/Modules/UI/Minimap.lua
@@ -1,6 +1,17 @@
-GBankClassic_UI_Minimap = {}
+GBankClassic_UI_Minimap = GBankClassic_UI_Minimap or {}
 
-function GBankClassic_UI_Minimap:Init()
+local UI_Minimap = GBankClassic_UI_Minimap
+
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("LibStub")
+local LibStub = upvalues.LibStub
+local upvalues = Globals.GetUpvalues("IsShiftKeyDown")
+local IsShiftKeyDown = upvalues.IsShiftKeyDown
+local upvalues = Globals.GetUpvalues("GameTooltip", "WorldFrame")
+local GameTooltip = upvalues.GameTooltip
+local WorldFrame = upvalues.WorldFrame
+
+function UI_Minimap:Init()
     self.icon = LibStub("LibDBIcon-1.0")
     local iconDB = LibStub("LibDataBroker-1.1"):NewDataObject("GBankClassicIcon", {
         type = "data source",
@@ -30,7 +41,7 @@ function GBankClassic_UI_Minimap:Init()
     self.icon:Register("GBankClassic", iconDB, self.db.profile.minimap)
 end
 
-function GBankClassic_UI_Minimap:Toggle()
+function UI_Minimap:Toggle()
     if not GBankClassic_Options:GetMinimapEnabled() then
         self.icon:Hide("GBankClassic")
     else
@@ -38,7 +49,7 @@ function GBankClassic_UI_Minimap:Toggle()
     end
 end
 
-function GBankClassic_UI_Minimap:ShowTooltip()
+function UI_Minimap:ShowTooltip()
     GameTooltip:SetOwner(WorldFrame, "ANCHOR_CURSOR")
     GameTooltip:AddLine("GBankClassic")
     GameTooltip:AddDoubleLine("Click", "Inventory", 1, 1, 1)
diff --git a/Modules/UI/Requests.lua b/Modules/UI/Requests.lua
new file mode 100644
index 0000000..33960de
--- /dev/null
+++ b/Modules/UI/Requests.lua
@@ -0,0 +1,1468 @@
+-- GBankClassic_UI_Requests = GBankClassic_UI_Requests or {}
+
+-- local UI_Requests = GBankClassic_UI_Requests
+
+-- local COLUMN_SPACING_H = 5
+-- local COLUMN_SPACING_V = 2
+-- local CONTENT_WIDTH_PADDING = 60
+-- local FILTER_LAYOUT_TOP = "top"
+-- local FILTER_LAYOUT_TWO_HEADERS = "two-headers"
+-- local FILTER_LAYOUT = FILTER_LAYOUT_TOP
+
+-- local COLUMNS = {
+-- 	{ key = "date", label = "Date", width = 140, align = "center" },
+-- 	{ key = "requester", label = "Requester", width = 150, align = "center", flex = true, weight = 1 },
+-- 	{ key = "bank", label = "Bank", width = 150, align = "center", flex = true, weight = 1 },
+-- 	{ key = "quantity", label = "#", width = 50, align = "end" },
+-- 	{ key = "item", label = "Item", width = 170, align = "start", flex = true, weight = 2 },
+-- 	{ key = "fulfilled", label = "Sent", width = 70, align = "center" },
+-- 	{ key = "actions", label = "Actions", width = 140, align = "center" },
+-- }
+
+-- local function minContentWidth()
+-- 	local total = 0
+-- 	for _, col in ipairs(COLUMNS) do
+-- 		total = total + (col.width or 0)
+-- 	end
+-- 	total = total + COLUMN_SPACING_H * (#COLUMNS - 1)
+
+-- 	return total
+-- end
+
+-- local MIN_WIDTH = minContentWidth() + CONTENT_WIDTH_PADDING
+
+-- local CANCEL_ICON = "|TInterface\\RAIDFRAME\\ReadyCheck-NotReady:18:18:0:0|t"
+-- local COMPLETE_ICON = "|TInterface\\Buttons\\UI-CheckBox-Check:18:18:0:0|t"
+-- local DELETE_ICON = "|TInterface\\Buttons\\UI-GroupLoot-Pass-Up:18:18:0:0|t"
+-- local FULFILL_ICON = "|TInterface\\Icons\\INV_Letter_15:18:18:0:0|t"
+
+-- local FULFILL_ICON_READY = "|TInterface\\Icons\\INV_Letter_15:18:18:0:0|t" -- Envelope: ready to send
+-- local FULFILL_ICON_NO_MAILBOX = "|TInterface\\Icons\\INV_Letter_02:18:18:0:0|t" -- Sealed letter: need mailbox
+-- local FULFILL_ICON_NOT_IN_BAGS = "|TInterface\\Icons\\INV_Misc_Bag_07:18:18:0:0|t" -- Bag: pick up from bank
+-- local FULFILL_ICON_NEED_SPLIT = "|TInterface\\Icons\\INV_Misc_Shovel_01:18:18:0:0|t" -- Shovel: manual work needed
+-- local FULFILL_ICON_NO_ITEMS = "|TInterface\\Icons\\INV_Misc_QuestionMark:18:18:0:0|t" -- Question mark: no items
+
+-- local DELETE_REQUEST_DIALOG = "GBankClassic_DeleteRequest"
+-- local FILTER_ANY = "__gbank_any__"
+-- local FILTER_SEPARATOR_ME_ANY = "__gbank_sep_me_any__"
+-- local FILTER_SEPARATOR_ANY_REST = "__gbank_sep_any_rest__"
+-- local FILTER_SEPARATOR_LABEL = "----------"
+
+-- local function useTwoHeaderLayout()
+-- 	return FILTER_LAYOUT == FILTER_LAYOUT_TWO_HEADERS
+-- end
+
+-- local function isFilterSeparator(value)
+-- 	return value == FILTER_SEPARATOR_ME_ANY or value == FILTER_SEPARATOR_ANY_REST
+-- end
+
+-- local function currentFilterValue(self, key)
+-- 	if key == "requester" then
+-- 		return self.requesterFilter
+-- 	end
+
+-- 	return self.bankFilter
+-- end
+
+-- local function setFilterValue(self, key, value)
+-- 	if key == "requester" then
+-- 		self.requesterFilter = value
+-- 	else
+-- 		self.bankFilter = value
+-- 	end
+-- end
+
+-- local function handleFilterChange(self, key, widget, value)
+-- 	if isFilterSeparator(value) then
+-- 		local currentValue = currentFilterValue(self, key) or FILTER_ANY
+-- 		if widget and widget.SetValue then
+-- 			widget:SetValue(currentValue)
+-- 		end
+
+-- 		return
+-- 	end
+
+-- 	if value == FILTER_ANY then
+-- 		setFilterValue(self, key, nil)
+-- 	else
+-- 		setFilterValue(self, key, value)
+-- 	end
+
+-- 	self:DrawContent()
+-- end
+
+-- local function columnLayout(contentWidth)
+-- 	local cols = {}
+-- 	local widths = {}
+-- 	local baseTotal = 0
+-- 	local flexTotal = 0
+-- 	local spaceH = COLUMN_SPACING_H
+
+-- 	for _, col in ipairs(COLUMNS) do
+-- 		baseTotal = baseTotal + (col.width or 0)
+-- 		if col.flex then
+-- 			flexTotal = flexTotal + (col.weight or 1)
+-- 		end
+-- 	end
+
+-- 	local available = (tonumber(contentWidth) or 0) - spaceH * (#COLUMNS - 1)
+-- 	if available < baseTotal then
+-- 		available = baseTotal
+-- 	end
+
+-- 	local extra = available - baseTotal
+-- 	local used = 0
+-- 	local lastFlex = nil
+
+-- 	for i, col in ipairs(COLUMNS) do
+-- 		local width = col.width or 0
+-- 		if col.flex and flexTotal > 0 then
+-- 			width = width + extra * ((col.weight or 1) / flexTotal)
+-- 			lastFlex = i
+-- 		end
+-- 		width = math.floor(width + 0.5)
+-- 		widths[i] = width
+-- 		used = used + width
+-- 	end
+
+-- 	local remainder = available - used
+-- 	if remainder ~= 0 then
+-- 		local adjustIndex = lastFlex or #COLUMNS
+-- 		widths[adjustIndex] = widths[adjustIndex] + remainder
+-- 	end
+
+-- 	for i, col in ipairs(COLUMNS) do
+-- 		cols[i] = { width = widths[i], alignH = col.align or "start" }
+-- 	end
+
+-- 	return cols, widths
+-- end
+
+-- local function justifyForAlign(align)
+-- 	align = tostring(align or "start"):lower()
+-- 	if align == "end" or align == "right" then
+-- 		return "RIGHT"
+-- 	end
+-- 	if align == "center" or align == "middle" then
+-- 		return "CENTER"
+-- 	end
+
+-- 	return "LEFT"
+-- end
+
+-- local function onClose(_)
+-- 	UI_Requests.isOpen = false
+-- 	if UI_Requests.Window then
+-- 		UI_Requests.Window:Hide()
+-- 	end
+-- end
+
+-- local function tagColumnWidget(widget, colIndex, keepWidth)
+-- 	if not widget or not widget.SetUserData then
+-- 		return
+-- 	end
+
+-- 	widget:SetUserData("gbankRequestsColIndex", colIndex)
+-- 	widget:SetUserData("gbankRequestsKeepWidth", keepWidth and true or false)
+-- end
+
+-- local function centerButtonText(button)
+-- 	if button.text and button.text.SetJustifyH then
+-- 		button.text:ClearAllPoints()
+-- 		button.text:SetPoint("CENTER")
+-- 		button.text:SetJustifyH("CENTER")
+-- 	end
+-- end
+
+-- local function setWidgetShown(widget, shown)
+-- 	if not widget or not widget.frame then
+-- 		return
+-- 	end
+
+-- 	local frame = widget.frame
+-- 	if not frame.gbankRequestsOrigShow then
+-- 		frame.gbankRequestsOrigShow = frame.Show
+-- 	end
+-- 	if shown then
+-- 		if frame.gbankRequestsHidden then
+-- 			frame.Show = frame.gbankRequestsOrigShow
+-- 			frame.gbankRequestsHidden = false
+-- 		end
+-- 		frame:Show()
+-- 	else
+-- 		if not frame.gbankRequestsHidden then
+-- 			-- AceGUI Flow layout calls frame:Show() during layout; override to keep hidden.
+-- 			frame.gbankRequestsHidden = true
+-- 			frame.Show = function() end
+-- 		end
+-- 		frame:Hide()
+-- 	end
+-- end
+
+-- local function attachActionTooltip(button, title, detail)
+-- 	if not button or not button.SetCallback then
+-- 		return
+-- 	end
+
+-- 	button:SetCallback("OnEnter", function()
+-- 		if not button.frame then
+-- 			return
+-- 		end
+
+-- 		GameTooltip:SetOwner(button.frame, "ANCHOR_RIGHT")
+-- 		GameTooltip:ClearLines()
+-- 		GameTooltip:AddLine(title or "")
+-- 		if detail and detail ~= "" then
+-- 			GameTooltip:AddLine(detail, 0.9, 0.9, 0.9, true)
+-- 		end
+-- 		GameTooltip:Show()
+-- 	end)
+-- 	button:SetCallback("OnLeave", function()
+-- 		GBankClassic_UI:HideTooltip()
+-- 	end)
+-- end
+
+-- -- Special tooltip handler for fulfill button that works even when disabled
+-- -- Hooks frame directly and stores tooltip data for dynamic updates
+-- local function setupFulfillButtonTooltip(button)
+-- 	if not button or not button.frame then
+-- 		return
+-- 	end
+
+-- 	local frame = button.frame
+-- 	if frame.gbankFulfillTooltipHooked then
+-- 		return
+-- 	end
+
+-- 	frame.gbankFulfillTooltipHooked = true
+
+-- 	frame.gbankTooltipTitle = "Fulfill request"
+-- 	frame.gbankTooltipDetail = ""
+
+-- 	-- Hook scripts directly on the frame (works even when button is disabled)
+-- 	frame:HookScript("OnEnter", function(self)
+-- 		GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
+-- 		GameTooltip:ClearLines()
+-- 		GameTooltip:AddLine(self.gbankTooltipTitle or "")
+-- 		if self.gbankTooltipDetail and self.gbankTooltipDetail ~= "" then
+-- 			GameTooltip:AddLine(self.gbankTooltipDetail, 0.9, 0.9, 0.9, true)
+-- 		end
+-- 		GameTooltip:Show()
+-- 	end)
+-- 	frame:HookScript("OnLeave", function()
+-- 		GBankClassic_UI:HideTooltip()
+-- 	end)
+-- end
+
+-- local function updateFulfillButtonTooltip(button, title, detail)
+-- 	if not button or not button.frame then
+-- 		return
+-- 	end
+
+-- 	button.frame.gbankTooltipTitle = title or "Fulfill request"
+-- 	button.frame.gbankTooltipDetail = detail or ""
+-- end
+
+-- local function ensureDeleteDialog()
+-- 	if not StaticPopupDialogs then
+-- 		return
+-- 	end
+-- 	if StaticPopupDialogs[DELETE_REQUEST_DIALOG] then
+-- 		return
+-- 	end
+
+-- 	StaticPopupDialogs[DELETE_REQUEST_DIALOG] = {
+-- 		text = "%s",
+-- 		button1 = YES,
+-- 		button2 = CANCEL,
+-- 		timeout = 0,
+-- 		whileDead = true,
+-- 		hideOnEscape = true,
+-- 		OnAccept = function(_, data)
+-- 			if not data or not data.requestId then
+-- 				return
+-- 			end
+
+-- 			if not GBankClassic_Guild:DeleteRequest(data.requestId, data.actor) then
+-- 				if data.ui and data.ui.Window then
+-- 					data.ui.Window:SetStatusText("Unable to delete request.")
+-- 				end
+-- 			end
+-- 		end,
+-- 	}
+-- end
+
+-- local function confirmDeleteRequest(request, actor)
+-- 	if not request or not StaticPopup_Show then
+-- 		return
+-- 	end
+
+-- 	ensureDeleteDialog()
+
+-- 	local qty = tonumber(request.quantity or 0) or 0
+-- 	local item = request.item or "Unknown"
+-- 	local requester = request.requester or "Unknown"
+-- 	local bank = request.bank or "Unknown"
+-- 	local message = string.format("Are you sure you want to permanently delete the request for %dx %s from %s to %s?", qty, item, requester, bank)
+
+-- 	StaticPopup_Show(DELETE_REQUEST_DIALOG, message, nil, {
+-- 		requestId = request.id,
+-- 		actor = actor,
+-- 		ui = UI_Requests,
+-- 	})
+-- end
+
+-- local function currentContentWidth(self)
+-- 	if self.Content and self.Content.content and self.Content.content.GetWidth then
+-- 		local width = self.Content.content:GetWidth()
+-- 		if width and width > 0 then
+-- 			return width
+-- 		end
+-- 	end
+
+-- 	if self.Window and self.Window.frame and self.Window.frame.GetWidth then
+-- 		local width = self.Window.frame:GetWidth()
+-- 		if width and width > 0 then
+-- 			return width - CONTENT_WIDTH_PADDING
+-- 		end
+-- 	end
+
+-- 	return MIN_WIDTH - CONTENT_WIDTH_PADDING
+-- end
+
+-- -- Throttled bag update handling - only active when window is open
+-- local BAG_UPDATE_THROTTLE = 0.5 -- Seconds
+-- local bagUpdateFrame = nil
+-- local lastBagUpdate = 0
+-- local pendingBagUpdate = false
+
+-- local function onBagUpdate()
+-- 	if not UI_Requests.isOpen then
+-- 		return
+-- 	end
+
+-- 	local now = GetTime()
+-- 	if now - lastBagUpdate < BAG_UPDATE_THROTTLE then
+-- 		-- Throttled - schedule a delayed refresh if not already pending
+-- 		if not pendingBagUpdate then
+-- 			pendingBagUpdate = true
+-- 			After(BAG_UPDATE_THROTTLE, function()
+-- 				pendingBagUpdate = false
+-- 				if UI_Requests.isOpen then
+-- 					lastBagUpdate = GetTime()
+-- 					UI_Requests:DrawContent()
+-- 				end
+-- 			end)
+-- 		end
+
+-- 		return
+-- 	end
+
+-- 	lastBagUpdate = now
+-- 	UI_Requests:DrawContent()
+-- end
+
+-- local function registerBagEvents()
+-- 	if not bagUpdateFrame then
+-- 		bagUpdateFrame = CreateFrame("Frame")
+-- 		bagUpdateFrame:SetScript("OnEvent", onBagUpdate)
+-- 	end
+-- 	-- BAG_UPDATE_DELAYED fires once after all bag changes from a single action
+-- 	bagUpdateFrame:RegisterEvent("BAG_UPDATE_DELAYED")
+-- end
+
+-- local function unregisterBagEvents()
+-- 	if bagUpdateFrame then
+-- 		bagUpdateFrame:UnregisterAllEvents()
+-- 	end
+-- end
+
+-- function UI_Requests:Init()
+-- 	self.sortColumn = "date"
+-- 	self.sortDirection = "desc"
+-- 	self.requesterFilter = nil
+-- 	self.bankFilter = nil
+-- 	self.defaultFiltersApplied = false
+-- 	self:DrawWindow()
+-- end
+
+-- function UI_Requests:Toggle()
+-- 	if self.isOpen then
+-- 		self:Close()
+-- 	else
+-- 		self:Open()
+-- 	end
+-- end
+
+-- function UI_Requests:Open()
+-- 	if self.isOpen then
+-- 		return
+-- 	end
+
+-- 	self.isOpen = true
+
+-- 	-- Check if guild bank alt status has changed since window was created
+-- 	local currentPlayer = GBankClassic_Guild:GetNormalizedPlayer()
+-- 	local isCurrentlyGuildBankAlt = currentPlayer and GBankClassic_Guild:IsBank(currentPlayer) or false
+-- 	local guildBankAltStatusChanged = (self.wasBank ~= nil) and (self.wasBank ~= isCurrentlyGuildBankAlt)
+	
+-- 	-- Recreate window if guild bank alt status changed (to add/remove highlight checkbox)
+-- 	if guildBankAltStatusChanged and self.Window then
+-- 		self.Window:Release()
+-- 		self.Window = nil
+-- 	end
+
+-- 	if not self.Window then
+-- 		self:DrawWindow()
+-- 		self.wasBank = isCurrentlyGuildBankAlt
+-- 	end
+
+-- 	if GBankClassic_UI_Inventory and GBankClassic_UI_Inventory.isOpen and GBankClassic_UI_Inventory.Window then
+-- 		self.Window:ClearAllPoints()
+-- 		self.Window:SetPoint("TOPLEFT", GBankClassic_UI_Inventory.Window.frame, "TOPRIGHT", 0, 0)
+-- 	end
+
+-- 	self:DrawContent()
+	
+-- 	-- Force layout update before showing to ensure proper sizing
+-- 	self.Window:DoLayout()
+	
+-- 	-- Show window after content is drawn and laid out to prevent initial sizing issue
+-- 	self.Window:Show()
+
+-- 	-- Start listening for bag changes to update fulfill button states (bank alts only)
+-- 	local player = GBankClassic_Guild:GetNormalizedPlayer()
+-- 	if player and GBankClassic_Guild:IsBank(player) then
+-- 		registerBagEvents()
+-- 	end
+
+-- 	if _G["GBankClassic"] then
+-- 		_G["GBankClassic"]:Show()
+-- 	else
+-- 		GBankClassic_UI:Controller()
+-- 	end
+-- end
+
+-- function UI_Requests:Close()
+-- 	if not self.isOpen then
+-- 		return
+-- 	end
+-- 	if not self.Window then
+-- 		return
+-- 	end
+
+-- 	-- Stop listening for bag changes
+-- 	unregisterBagEvents()
+
+-- 	-- Clear item highlighting
+-- 	if GBankClassic_ItemHighlight then
+-- 		GBankClassic_ItemHighlight:ClearAllOverlays()
+-- 	end
+
+-- 	onClose(self.Window)
+
+-- 	if GBankClassic_UI_Inventory.isOpen == false then
+-- 		_G["GBankClassic"]:Hide()
+-- 	end
+-- end
+
+-- function UI_Requests:ApplyColumnWidths()
+-- 	if not self.Content or not self.ColumnWidths then
+-- 		return
+-- 	end
+
+-- 	local widths = self.ColumnWidths
+-- 	local function applyTo(children)
+-- 		if not children then
+-- 			return
+-- 		end
+
+-- 		for _, child in ipairs(children) do
+-- 			if child and child.SetWidth then
+-- 				local colIndex = child:GetUserData("gbankRequestsColIndex")
+-- 				if colIndex and widths[colIndex] and not child:GetUserData("gbankRequestsKeepWidth") then
+-- 					child:SetWidth(widths[colIndex])
+-- 				end
+-- 			end
+-- 		end
+-- 	end
+
+-- 	applyTo(self.Content.children)
+-- 	if self.HeaderGroup then
+-- 		applyTo(self.HeaderGroup.children)
+-- 	end
+-- end
+
+-- function UI_Requests:UpdateColumnLayout()
+-- 	if not self.Content then
+-- 		return
+-- 	end
+
+-- 	local width = currentContentWidth(self)
+-- 	local columns, widths = columnLayout(width)
+-- 	local function applyTable(group)
+-- 		if not group then
+-- 			return
+-- 		end
+
+-- 		local tableData = group:GetUserData("table") or {}
+-- 		tableData.columns = columns
+-- 		tableData.spaceH = COLUMN_SPACING_H
+-- 		tableData.spaceV = COLUMN_SPACING_V
+-- 		group:SetUserData("table", tableData)
+-- 	end
+
+-- 	applyTable(self.Content)
+-- 	applyTable(self.HeaderGroup)
+-- 	self.ColumnWidths = widths
+-- 	self.lastLayoutWidth = math.floor((width or 0) + 0.5)
+-- end
+
+-- function UI_Requests:HandleResize()
+-- 	if not self.isOpen or not self.Content then
+-- 		return
+-- 	end
+
+-- 	local width = currentContentWidth(self)
+-- 	if not width or width <= 0 then
+-- 		return
+-- 	end
+
+-- 	local rounded = math.floor(width + 0.5)
+-- 	if self.lastLayoutWidth == rounded then
+-- 		return
+-- 	end
+
+-- 	self:UpdateColumnLayout()
+-- 	self:ApplyColumnWidths()
+-- 	if self.HeaderGroup then
+-- 		self.HeaderGroup:DoLayout()
+-- 	end
+-- 	if self.FilterGroup then
+-- 		self.FilterGroup:DoLayout()
+-- 	end
+-- 	self:AdjustTableHeight()
+-- 	if self.Window then
+-- 		self.Window:DoLayout()
+-- 	end
+-- 	self.Content:DoLayout()
+-- end
+
+-- function UI_Requests:AdjustTableHeight()
+-- 	if not self.Window or not self.Window.content or not self.Content then
+-- 		return
+-- 	end
+
+-- 	local contentHeight = self.Window.content:GetHeight() or 0
+-- 	local headerHeight = 0
+-- 	local headerRows = 0
+-- 	if self.FilterGroup and self.FilterGroup.frame then
+-- 		headerHeight = headerHeight + (self.FilterGroup.frame:GetHeight() or 0)
+-- 		headerRows = headerRows + 1
+-- 	end
+-- 	if self.HeaderGroup and self.HeaderGroup.frame then
+-- 		headerHeight = headerHeight + (self.HeaderGroup.frame:GetHeight() or 0)
+-- 		headerRows = headerRows + 1
+-- 	end
+-- 	local gap = 3 -- AceGUI Flow row spacing
+-- 	local height = contentHeight - headerHeight - gap * headerRows
+-- 	if height < 50 then
+-- 		height = 50
+-- 	end
+-- 	self.Content:SetHeight(height)
+-- end
+
+-- function UI_Requests:DrawWindow()
+-- 	local window = GBankClassic_UI:Create("Frame")
+-- 	window:Hide()
+-- 	window:SetCallback("OnClose", onClose)
+-- 	window:SetTitle("Requests")
+-- 	window:SetLayout("Flow")
+-- 	window:EnableResize(true)
+-- 	-- Persist window position/size across reloads
+-- 	if GBankClassic_Options and GBankClassic_Options.db then
+-- 		window:SetStatusTable(GBankClassic_Options.db.char.framePositions)
+-- 	end
+-- 	-- Set width after SetStatusTable to ensure minimum size is enforced
+-- 	window:SetWidth(MIN_WIDTH)
+-- 	if window.frame.SetResizeBounds then
+-- 		window.frame:SetResizeBounds(MIN_WIDTH, 200)
+-- 	else
+-- 		window.frame:SetMinResize(MIN_WIDTH, 200)
+-- 	end
+-- 	if not window.frame.gbankRequestsResizeHooked then
+-- 		window.frame.gbankRequestsResizeHooked = true
+-- 		window.frame:HookScript("OnSizeChanged", function()
+-- 			self:HandleResize()
+-- 		end)
+-- 	end
+	
+-- 	self.Window = window
+	
+-- 	self.HeaderWidgets = nil
+-- 	self.FilterWidgets = nil
+-- 	self.FilterRequester = nil
+-- 	self.FilterBank = nil
+
+-- 	if not useTwoHeaderLayout() then
+-- 		local filterGroup = GBankClassic_UI:Create("SimpleGroup")
+-- 		filterGroup:SetLayout("Table")
+-- 		filterGroup:SetUserData("table", {
+-- 			columns = {
+-- 				{ width = 0.5, align = "start" },
+-- 				{ width = 0.5, align = "start" },
+-- 			},
+-- 			spaceH = 10,
+-- 		})
+-- 		filterGroup:SetFullWidth(true)
+-- 		window:AddChild(filterGroup)
+-- 		self.FilterGroup = filterGroup
+
+-- 		local requesterFilter = GBankClassic_UI:Create("Dropdown")
+-- 		requesterFilter:SetLabel("Requester")
+-- 		requesterFilter:SetFullWidth(true)
+-- 		requesterFilter:SetCallback("OnValueChanged", function(widget, _, value)
+-- 			handleFilterChange(self, "requester", widget, value)
+-- 		end)
+-- 		filterGroup:AddChild(requesterFilter)
+-- 		self.FilterRequester = requesterFilter
+
+-- 		local bankFilter = GBankClassic_UI:Create("Dropdown")
+-- 		bankFilter:SetLabel("Bank")
+-- 		bankFilter:SetFullWidth(true)
+-- 		bankFilter:SetCallback("OnValueChanged", function(widget, _, value)
+-- 			handleFilterChange(self, "bank", widget, value)
+-- 		end)
+-- 		filterGroup:AddChild(bankFilter)
+-- 		self.FilterBank = bankFilter
+
+-- 		-- Add highlighting checkbox (only for guild bank alts)
+-- 		-- Check if guild roster is loaded before checking guild bank alt status
+-- 		if GetNumGuildMembers() > 0 then
+-- 			local currentPlayer = GBankClassic_Guild:GetNormalizedPlayer()
+-- 			local isBank = GBankClassic_Guild:IsBank(currentPlayer)
+-- 			GBankClassic_Output:Debug("UI", "UpdateFilters: currentPlayer=%s, isBank=%s", tostring(currentPlayer), tostring(isBank))
+			
+-- 			if isBank then
+-- 				GBankClassic_Output:Debug("UI", "UpdateFilters: Creating highlight checkbox")
+-- 				local highlightCheckbox = GBankClassic_UI:Create("CheckBox")
+-- 				highlightCheckbox:SetLabel("Highlight needed items")
+-- 				highlightCheckbox:SetFullWidth(true)
+-- 				highlightCheckbox:SetValue(GBankClassic_ItemHighlight and GBankClassic_ItemHighlight.enabled or false)
+-- 				highlightCheckbox:SetCallback("OnValueChanged", function(widget, _, value)
+-- 					if GBankClassic_ItemHighlight then
+-- 						GBankClassic_ItemHighlight:SetEnabled(value)
+-- 					end
+-- 				end)
+-- 				filterGroup:AddChild(highlightCheckbox)
+-- 				self.HighlightCheckbox = highlightCheckbox
+-- 				GBankClassic_Output:Debug("UI", "UpdateFilters: Highlight checkbox created and added to filterGroup")
+-- 			else
+-- 				GBankClassic_Output:Debug("UI", "UpdateFilters: Not a guild bank alt, skipping checkbox")
+-- 			end
+-- 		else
+-- 			GBankClassic_Output:Debug("UI", "UpdateFilters: Guild roster not loaded yet, skipping guild bank alt check")
+-- 		end
+-- 	end
+
+-- 	local headerGroup = GBankClassic_UI:Create("SimpleGroup")
+-- 	headerGroup:SetLayout("Table")
+-- 	headerGroup:SetUserData("table", {
+-- 		columns = columnLayout(MIN_WIDTH - CONTENT_WIDTH_PADDING),
+-- 		spaceH = COLUMN_SPACING_H,
+-- 		spaceV = COLUMN_SPACING_V,
+-- 	})
+-- 	headerGroup:SetFullWidth(true)
+-- 	if headerGroup.content and headerGroup.content.SetPoint then
+-- 		headerGroup.content:ClearAllPoints()
+-- 		headerGroup.content:SetPoint("TOPLEFT", 8, 0)
+-- 		headerGroup.content:SetPoint("BOTTOMRIGHT", 0, 0)
+-- 	end
+-- 	window:AddChild(headerGroup)
+-- 	self.HeaderGroup = headerGroup
+
+-- 	local tableFrame = GBankClassic_UI:Create("ScrollFrame")
+-- 	tableFrame:SetLayout("Table")
+-- 	tableFrame:SetUserData("table", {
+-- 		columns = columnLayout(MIN_WIDTH - CONTENT_WIDTH_PADDING),
+-- 		spaceH = COLUMN_SPACING_H,
+-- 		spaceV = COLUMN_SPACING_V,
+-- 	})
+-- 	tableFrame:SetFullWidth(true)
+
+-- 	tableFrame.scrollframe:ClearAllPoints()
+-- 	tableFrame.scrollframe:SetPoint("TOPLEFT", 8, -8)
+-- 	tableFrame.scrollbar:ClearAllPoints()
+-- 	tableFrame.scrollbar:SetPoint("TOPLEFT", tableFrame.scrollframe, "TOPRIGHT", -6, -12)
+-- 	tableFrame.scrollbar:SetPoint("BOTTOMLEFT", tableFrame.scrollframe, "BOTTOMRIGHT", -6, 22)
+
+-- 	window:AddChild(tableFrame)
+-- 	self.Content = tableFrame
+-- 	self.RowPool = nil
+-- 	self.EmptyRow = nil
+-- 	self:UpdateColumnLayout()
+-- end
+
+-- local function valueForSort(request, key)
+-- 	if key == "date" or key == "quantity" or key == "fulfilled" then
+-- 		return tonumber(request[key] or 0) or 0
+-- 	end
+
+-- 	return tostring(request[key] or ""):lower()
+-- end
+
+-- local function isComplete(request)
+-- 	local qty = tonumber(request.quantity or 0) or 0
+-- 	local fulfilled = tonumber(request.fulfilled or 0) or 0
+-- 	if request.status == "cancelled" or request.status == "complete" or request.status == "fulfilled" then
+-- 		return true
+-- 	end
+
+-- 	return fulfilled >= qty and qty > 0
+-- end
+
+-- local function isPending(request)
+-- 	if not request then
+-- 		return false
+-- 	end
+
+-- 	local qty = tonumber(request.quantity or 0) or 0
+-- 	if qty <= 0 then
+-- 		return false
+-- 	end
+
+-- 	local fulfilled = tonumber(request.fulfilled or 0) or 0
+-- 	if (request.status or "open") ~= "open" then
+-- 		return false
+-- 	end
+
+-- 	return fulfilled < qty
+-- end
+
+-- local function pendingCounts(requests)
+-- 	local requesterCounts = {}
+-- 	local bankCounts = {}
+-- 	-- Use pairs() since requests is now a map keyed by ID, not an array
+-- 	for _, req in pairs(requests or {}) do
+-- 		if isPending(req) then
+-- 			local requester = req.requester
+-- 			if requester and requester ~= "" then
+-- 				requesterCounts[requester] = (requesterCounts[requester] or 0) + 1
+-- 			end
+-- 			local bank = req.bank
+-- 			if bank and bank ~= "" then
+-- 				bankCounts[bank] = (bankCounts[bank] or 0) + 1
+-- 			end
+-- 		end
+-- 	end
+
+-- 	return requesterCounts, bankCounts
+-- end
+
+-- local function buildRequesterOptions(currentPlayer, requesterCounts)
+-- 	local list = {}
+-- 	local order = {}
+-- 	if currentPlayer and currentPlayer ~= "" then
+-- 		list[currentPlayer] = string.format("(%d) Me - %s", requesterCounts[currentPlayer] or 0, currentPlayer)
+-- 		table.insert(order, currentPlayer)
+-- 		list[FILTER_SEPARATOR_ME_ANY] = FILTER_SEPARATOR_LABEL
+-- 		table.insert(order, FILTER_SEPARATOR_ME_ANY)
+-- 	end
+-- 	list[FILTER_ANY] = "Any requester"
+-- 	table.insert(order, FILTER_ANY)
+
+-- 	local names = {}
+-- 	for name in pairs(requesterCounts or {}) do
+-- 		if name ~= currentPlayer then
+-- 			table.insert(names, name)
+-- 		end
+-- 	end
+-- 	table.sort(names, function(a, b)
+-- 		local countA = requesterCounts[a] or 0
+-- 		local countB = requesterCounts[b] or 0
+-- 		if countA == countB then
+-- 			return tostring(a) < tostring(b)
+-- 		end
+
+-- 		return countA > countB
+-- 	end)
+-- 	if #names > 0 then
+-- 		list[FILTER_SEPARATOR_ANY_REST] = FILTER_SEPARATOR_LABEL
+-- 		table.insert(order, FILTER_SEPARATOR_ANY_REST)
+-- 	end
+-- 	for _, name in ipairs(names) do
+-- 		list[name] = string.format("(%d) %s", requesterCounts[name], name)
+-- 		table.insert(order, name)
+-- 	end
+
+-- 	return list, order
+-- end
+
+-- local function buildBankOptions(currentPlayer, bankCounts)
+-- 	local list = {}
+-- 	local order = {}
+-- 	if currentPlayer and currentPlayer ~= "" then
+-- 		list[currentPlayer] = string.format("(%d) Me - %s", bankCounts[currentPlayer] or 0, currentPlayer)
+-- 		table.insert(order, currentPlayer)
+-- 		list[FILTER_SEPARATOR_ME_ANY] = FILTER_SEPARATOR_LABEL
+-- 		table.insert(order, FILTER_SEPARATOR_ME_ANY)
+-- 	end
+-- 	list[FILTER_ANY] = "Any bank"
+-- 	table.insert(order, FILTER_ANY)
+
+-- 	local names = {}
+-- 	for name in pairs(bankCounts or {}) do
+-- 		if name ~= currentPlayer then
+-- 			table.insert(names, name)
+-- 		end
+-- 	end
+-- 	table.sort(names, function(a, b)
+-- 		local countA = bankCounts[a] or 0
+-- 		local countB = bankCounts[b] or 0
+-- 		if countA == countB then
+-- 			return tostring(a) < tostring(b)
+-- 		end
+
+-- 		return countA > countB
+-- 	end)
+-- 	if #names > 0 then
+-- 		list[FILTER_SEPARATOR_ANY_REST] = FILTER_SEPARATOR_LABEL
+-- 		table.insert(order, FILTER_SEPARATOR_ANY_REST)
+-- 	end
+-- 	for _, name in ipairs(names) do
+-- 		list[name] = string.format("(%d) %s", bankCounts[name], name)
+-- 		table.insert(order, name)
+-- 	end
+
+-- 	return list, order
+-- end
+
+-- function UI_Requests:SortedRequests()
+-- 	local info = GBankClassic_Guild.Info
+-- 	if not info or not info.requests then
+-- 		GBankClassic_Output:Debug("REQUESTS", "SortedRequests: No guild info or requests")
+
+-- 		return {}
+-- 	end
+
+-- 	local list = {}
+-- 	-- Use pairs() since requests is now a map keyed by ID, not an array
+-- 	for _, req in pairs(info.requests) do
+-- 		table.insert(list, req)
+-- 	end
+
+-- 	GBankClassic_Output:Debug("REQUESTS", "SortedRequests: Found %d requests in GBankClassic_Guild.Info", #list)
+
+-- 	local column = self.sortColumn or "date"
+-- 	local direction = self.sortDirection or "desc"
+
+-- 	table.sort(list, function(a, b)
+-- 		local va = valueForSort(a, column)
+-- 		local vb = valueForSort(b, column)
+-- 		if va == vb then
+-- 			return valueForSort(a, "date") > valueForSort(b, "date")
+-- 		end
+-- 		if direction == "asc" then
+-- 			return va < vb
+-- 		end
+
+-- 		return va > vb
+-- 	end)
+
+-- 	return list
+-- end
+
+-- function UI_Requests:EnsureRow(index)
+-- 	if not self.Content then
+-- 		return nil
+-- 	end
+
+-- 	self.RowPool = self.RowPool or {}
+-- 	local row = self.RowPool[index]
+-- 	if row then
+-- 		return row
+-- 	end
+
+-- 	row = { cells = {} }
+-- 	for i, col in ipairs(COLUMNS) do
+-- 		if col.key == "actions" then
+-- 			local actionGroup = GBankClassic_UI:Create("SimpleGroup")
+-- 			actionGroup:SetLayout("Flow")
+-- 			tagColumnWidget(actionGroup, i, false)
+-- 			self.Content:AddChild(actionGroup)
+
+-- 			-- Fulfill button (first)
+-- 			local fulfillButton = GBankClassic_UI:Create("Button")
+-- 			fulfillButton:SetText(FULFILL_ICON)
+-- 			fulfillButton:SetWidth(24)
+-- 			fulfillButton:SetHeight(20)
+-- 			centerButtonText(fulfillButton)
+-- 			setupFulfillButtonTooltip(fulfillButton)
+-- 			actionGroup:AddChild(fulfillButton)
+
+-- 			-- Spacer between fulfill and complete/cancel
+-- 			local fulfillSpacer = GBankClassic_UI:Create("Label")
+-- 			fulfillSpacer:SetText("")
+-- 			fulfillSpacer:SetWidth(8)
+-- 			actionGroup:AddChild(fulfillSpacer)
+
+-- 			-- Complete button
+-- 			local completeButton = GBankClassic_UI:Create("Button")
+-- 			completeButton:SetText(COMPLETE_ICON)
+-- 			completeButton:SetWidth(24)
+-- 			completeButton:SetHeight(20)
+-- 			centerButtonText(completeButton)
+-- 			attachActionTooltip(completeButton, "Complete request", "Marks the request as completed by the bank.")
+-- 			actionGroup:AddChild(completeButton)
+
+-- 			-- Small spacer between complete and cancel
+-- 			local actionSpacer = GBankClassic_UI:Create("Label")
+-- 			actionSpacer:SetText("")
+-- 			actionSpacer:SetWidth(4)
+-- 			actionGroup:AddChild(actionSpacer)
+
+-- 			-- Cancel button
+-- 			local cancelButton = GBankClassic_UI:Create("Button")
+-- 			cancelButton:SetText(CANCEL_ICON)
+-- 			cancelButton:SetWidth(24)
+-- 			cancelButton:SetHeight(20)
+-- 			centerButtonText(cancelButton)
+-- 			attachActionTooltip(cancelButton, "Cancel request", "Cancels the request without fulfilling it.")
+-- 			actionGroup:AddChild(cancelButton)
+
+-- 			-- Spacer between cancel and delete
+-- 			local deleteSpacer = GBankClassic_UI:Create("Label")
+-- 			deleteSpacer:SetText("")
+-- 			deleteSpacer:SetWidth(8)
+-- 			actionGroup:AddChild(deleteSpacer)
+
+-- 			-- Delete button (last)
+-- 			local deleteButton = GBankClassic_UI:Create("Button")
+-- 			deleteButton:SetText(DELETE_ICON)
+-- 			deleteButton:SetWidth(24)
+-- 			deleteButton:SetHeight(20)
+-- 			centerButtonText(deleteButton)
+-- 			attachActionTooltip(deleteButton, "Delete permanently", "Permanently removes the request.")
+-- 			actionGroup:AddChild(deleteButton)
+
+-- 			row.actionGroup = actionGroup
+-- 			row.fulfillButton = fulfillButton
+-- 			row.fulfillSpacer = fulfillSpacer
+-- 			row.completeButton = completeButton
+-- 			row.actionSpacer = actionSpacer
+-- 			row.cancelButton = cancelButton
+-- 			row.deleteSpacer = deleteSpacer
+-- 			row.deleteButton = deleteButton
+-- 			row.cells[i] = actionGroup
+-- 		else
+-- 			local label = GBankClassic_UI:Create("Label")
+-- 			label.label:SetHeight(18)
+-- 			label.label:SetJustifyH(justifyForAlign(col.align))
+-- 			tagColumnWidget(label, i, false)
+-- 			self.Content:AddChild(label)
+-- 			row.cells[i] = label
+-- 		end
+-- 	end
+
+-- 	self.RowPool[index] = row
+
+-- 	return row
+-- end
+
+-- function UI_Requests:SetRowVisible(row, visible)
+-- 	if not row or not row.cells then
+-- 		return
+-- 	end
+
+-- 	for _, cell in ipairs(row.cells) do
+-- 		setWidgetShown(cell, visible)
+-- 	end
+-- end
+
+-- function UI_Requests:EnsureEmptyLabel()
+-- 	if not self.Content then
+-- 		return nil
+-- 	end
+-- 	if self.EmptyRow then
+-- 		return self.EmptyRow
+-- 	end
+
+-- 	local empty = GBankClassic_UI:Create("Label")
+-- 	empty:SetText("No requests yet.")
+-- 	empty:SetFullWidth(true)
+-- 	tagColumnWidget(empty, 1, false)
+-- 	self.Content:AddChild(empty)
+-- 	self.EmptyRow = empty
+
+-- 	return empty
+-- end
+
+-- local function colorize(text, completed)
+-- 	local color = completed and "ff7f7f7f" or "ffffffff"
+
+-- 	return string.format("|c%s%s|r", color, text)
+-- end
+
+-- function UI_Requests:EnsureHeaderRows()
+-- 	if not self.HeaderGroup then
+-- 		return
+-- 	end
+
+-- 	self.HeaderWidgets = self.HeaderWidgets or {}
+-- 	self.FilterWidgets = self.FilterWidgets or {}
+
+-- 	for i, col in ipairs(COLUMNS) do
+-- 		local button = self.HeaderWidgets[i]
+-- 		if not button then
+-- 			button = GBankClassic_UI:Create("Button")
+-- 			self.HeaderWidgets[i] = button
+-- 			tagColumnWidget(button, i, false)
+-- 			if button.text and button.text.SetJustifyH then
+-- 				button.text:SetJustifyH(justifyForAlign(col.align))
+-- 			end
+-- 			local colKey = col.key
+-- 			button:SetCallback("OnClick", function()
+-- 				if self.sortColumn == colKey then
+-- 					self.sortDirection = (self.sortDirection == "asc") and "desc" or "asc"
+-- 				else
+-- 					self.sortColumn = colKey
+-- 					self.sortDirection = "desc"
+-- 				end
+-- 				self:DrawContent()
+-- 			end)
+-- 			self.HeaderGroup:AddChild(button)
+-- 		end
+-- 	end
+
+-- 	if not useTwoHeaderLayout() then
+-- 		return
+-- 	end
+
+-- 	for i, col in ipairs(COLUMNS) do
+-- 		local widget = self.FilterWidgets[i]
+-- 		if not widget then
+-- 			if col.key == "requester" then
+-- 				local requesterFilter = GBankClassic_UI:Create("Dropdown")
+-- 				requesterFilter:SetCallback("OnValueChanged", function(widget, _, value)
+-- 					handleFilterChange(self, "requester", widget, value)
+-- 				end)
+-- 				widget = requesterFilter
+-- 				self.FilterRequester = requesterFilter
+-- 			elseif col.key == "bank" then
+-- 				local bankFilter = GBankClassic_UI:Create("Dropdown")
+-- 				bankFilter:SetCallback("OnValueChanged", function(widget, _, value)
+-- 					handleFilterChange(self, "bank", widget, value)
+-- 				end)
+-- 				widget = bankFilter
+-- 				self.FilterBank = bankFilter
+-- 			else
+-- 				local spacer = GBankClassic_UI:Create("Label")
+-- 				spacer:SetText("")
+-- 				widget = spacer
+-- 			end
+
+-- 			tagColumnWidget(widget, i, false)
+-- 			self.FilterWidgets[i] = widget
+-- 			self.HeaderGroup:AddChild(widget)
+-- 		end
+-- 	end
+-- end
+
+-- function UI_Requests:DrawHeader()
+-- 	local ArrowUpIcon = " |TInterface\\Buttons\\Arrow-Up-Up:0|t"
+-- 	local ArrowDownIcon = " |TInterface\\Buttons\\Arrow-Down-Up:0|t"
+-- 	if not self.HeaderGroup then
+-- 		return
+-- 	end
+
+-- 	self:EnsureHeaderRows()
+
+-- 	for i, col in ipairs(COLUMNS) do
+-- 		local label = col.label
+-- 		if self.sortColumn == col.key then
+-- 			label = label .. (self.sortDirection == "asc" and ArrowUpIcon or ArrowDownIcon)
+-- 		end
+-- 		local button = self.HeaderWidgets[i]
+
+-- 		button:SetText(label)
+-- 		local columnWidth = (self.ColumnWidths and self.ColumnWidths[i]) or col.width
+-- 		button:SetWidth(columnWidth)
+-- 		setWidgetShown(button, true)
+-- 	end
+
+-- 	for i, _ in ipairs(COLUMNS) do
+-- 		local widget = self.FilterWidgets[i]
+-- 		if widget and widget.SetWidth then
+-- 			local columnWidth = (self.ColumnWidths and self.ColumnWidths[i]) or COLUMNS[i].width
+-- 			widget:SetWidth(columnWidth)
+-- 			setWidgetShown(widget, true)
+-- 		end
+-- 	end
+-- end
+
+-- function UI_Requests:UpdateFilters()
+-- 	if not self.FilterRequester or not self.FilterBank then
+-- 		return
+-- 	end
+
+-- 	local info = GBankClassic_Guild.Info
+-- 	local requests = info and info.requests or {}
+-- 	local requesterCounts, bankCounts = pendingCounts(requests)
+-- 	local currentPlayer = GBankClassic_Guild:GetNormalizedPlayer()
+-- 	if not self.defaultFiltersApplied then
+-- 		if self.requesterFilter ~= nil or self.bankFilter ~= nil then
+-- 			self.defaultFiltersApplied = true
+-- 		elseif currentPlayer and currentPlayer ~= "" then
+-- 			if GBankClassic_Guild:IsBank(currentPlayer) then
+-- 				self.bankFilter = currentPlayer
+-- 			else
+-- 				self.requesterFilter = currentPlayer
+-- 			end
+-- 			self.defaultFiltersApplied = true
+-- 		end
+-- 	end
+
+-- 	local requesterList, requesterOrder = buildRequesterOptions(currentPlayer, requesterCounts)
+	
+-- 	-- Only update the requester dropdown if the list has changed
+-- 	local requesterListChanged = false
+-- 	if not self.cachedRequesterList or #requesterOrder ~= #(self.cachedRequesterOrder or {}) then
+-- 		requesterListChanged = true
+-- 	else
+-- 		for i, key in ipairs(requesterOrder) do
+-- 			if key ~= self.cachedRequesterOrder[i] or requesterList[key] ~= self.cachedRequesterList[key] then
+-- 				requesterListChanged = true
+-- 				break
+-- 			end
+-- 		end
+-- 	end
+	
+-- 	if requesterListChanged then
+-- 		self.FilterRequester:SetList(requesterList, requesterOrder)
+-- 		self.cachedRequesterList = requesterList
+-- 		self.cachedRequesterOrder = requesterOrder
+-- 		GBankClassic_Output:Debug("UI", "UpdateFilters: Requester dropdown list updated")
+-- 	end
+
+-- 	local bankList, bankOrder = buildBankOptions(currentPlayer, bankCounts)
+	
+-- 	-- Only update the bank dropdown if the list has changed
+-- 	local bankListChanged = false
+-- 	if not self.cachedBankList or #bankOrder ~= #(self.cachedBankOrder or {}) then
+-- 		bankListChanged = true
+-- 	else
+-- 		for i, key in ipairs(bankOrder) do
+-- 			if key ~= self.cachedBankOrder[i] or bankList[key] ~= self.cachedBankList[key] then
+-- 				bankListChanged = true
+-- 				break
+-- 			end
+-- 		end
+-- 	end
+	
+-- 	if bankListChanged then
+-- 		self.FilterBank:SetList(bankList, bankOrder)
+-- 		self.cachedBankList = bankList
+-- 		self.cachedBankOrder = bankOrder
+-- 		GBankClassic_Output:Debug("UI", "UpdateFilters: Bank dropdown list updated")
+-- 	end
+
+-- 	local requesterValue = self.requesterFilter or FILTER_ANY
+-- 	if requesterValue ~= FILTER_ANY and not requesterList[requesterValue] then
+-- 		self.requesterFilter = nil
+-- 		requesterValue = FILTER_ANY
+-- 	end
+-- 	self.FilterRequester:SetValue(requesterValue)
+
+-- 	local bankValue = self.bankFilter or FILTER_ANY
+-- 	if bankValue ~= FILTER_ANY and not bankList[bankValue] then
+-- 		self.bankFilter = nil
+-- 		bankValue = FILTER_ANY
+-- 	end
+-- 	self.FilterBank:SetValue(bankValue)
+-- end
+
+-- function UI_Requests:ApplyFilters(requests)
+-- 	if not self.requesterFilter and not self.bankFilter then
+-- 		GBankClassic_Output:Debug("REQUESTS", "ApplyFilters: No filters, returning all %d requests", #(requests or {}))
+
+-- 		return requests
+-- 	end
+
+-- 	local filtered = {}
+-- 	-- Use pairs() since requests is now a map keyed by ID, not an array
+-- 	for _, req in pairs(requests or {}) do
+-- 		if (not self.requesterFilter or req.requester == self.requesterFilter) and (not self.bankFilter or req.bank == self.bankFilter) then
+-- 			table.insert(filtered, req)
+-- 		end
+-- 	end
+
+-- 	GBankClassic_Output:Debug("REQUESTS", "ApplyFilters: Filtered from %d to %d requests (requester=%s, bank=%s)", #(requests or {}), #filtered, tostring(self.requesterFilter), tostring(self.bankFilter))
+
+-- 	return filtered
+-- end
+
+-- function UI_Requests:DrawContent()
+-- 	if not self.Content or not self.Window then
+-- 		GBankClassic_Output:Debug("REQUESTS", "DrawContent: No content or window")
+
+-- 		return
+-- 	end
+
+-- 	GBankClassic_Output:Debug("REQUESTS", "DrawContent: Starting UI refresh")
+
+-- 	local content = self.Content
+-- 	content:PauseLayout()
+
+-- 	self.Window:SetStatusText("")
+
+-- 	self:UpdateColumnLayout()
+-- 	self:DrawHeader()
+-- 	self:UpdateFilters()
+-- 	if self.HeaderGroup then
+-- 		self.HeaderGroup:DoLayout()
+-- 	end
+-- 	if self.FilterGroup then
+-- 		self.FilterGroup:DoLayout()
+-- 	end
+-- 	self:AdjustTableHeight()
+-- 	if self.Window then
+-- 		self.Window:DoLayout()
+-- 	end
+
+-- 	local sorted = self:SortedRequests()
+-- 	sorted = self:ApplyFilters(sorted)
+-- 	local count = #sorted
+	
+-- 	GBankClassic_Output:Debug("REQUESTS", "DrawContent: Displaying %d requests", count)
+	
+-- 	if count == 0 then
+-- 		local empty = self:EnsureEmptyLabel()
+-- 		local columnWidth = (self.ColumnWidths and self.ColumnWidths[1]) or COLUMNS[1].width
+-- 		if empty then
+-- 			empty:SetWidth(columnWidth)
+-- 		end
+-- 		setWidgetShown(empty, true)
+-- 		if self.RowPool then
+-- 			for _, row in ipairs(self.RowPool) do
+-- 				self:SetRowVisible(row, false)
+-- 			end
+-- 		end
+-- 	else
+-- 		if self.EmptyRow then
+-- 			setWidgetShown(self.EmptyRow, false)
+-- 		end
+
+-- 		local CheckMarkIcon = "|TInterface\\Buttons\\UI-CheckBox-Check:0|t "
+-- 		local actor = GBankClassic_Guild:GetNormalizedPlayer()
+-- 		local actorIsGM = actor and GBankClassic_Guild:SenderIsGM(actor) or false
+
+-- 		for index, req in ipairs(sorted) do
+-- 			local row = self:EnsureRow(index)
+-- 			self:SetRowVisible(row, true)
+
+-- 			local completed = isComplete(req)
+-- 			local requestId = req.id
+-- 			local canCancel = not completed and requestId and GBankClassic_Guild:CanCancelRequest(req, actor)
+-- 			local canComplete = not completed and requestId and GBankClassic_Guild:CanCompleteRequest(req, actor, actorIsGM)
+-- 			local canDelete = requestId and GBankClassic_Guild:CanDeleteRequest(req, actor, actorIsGM)
+-- 			local ts = tonumber(req.date or 0) or 0
+-- 			local dateText = ts > 0 and date("%Y-%m-%d %H:%M", ts) or "Unknown"
+-- 			if completed then
+-- 				dateText = CheckMarkIcon .. dateText
+-- 			end
+
+-- 			local function cellText(colKey)
+-- 				if colKey == "date" then
+-- 					return dateText
+-- 				elseif colKey == "requester" then
+-- 					return req.requester or ""
+-- 				elseif colKey == "bank" then
+-- 					return req.bank or ""
+-- 				elseif colKey == "quantity" then
+-- 					local qty = req.quantity
+-- 					if qty == nil or qty == "" then
+-- 						return ""
+-- 					end
+
+-- 					return tostring(qty) .. "x"
+-- 				elseif colKey == "item" then
+-- 					return req.item or ""
+-- 				elseif colKey == "fulfilled" then
+-- 					return tostring(req.fulfilled or "")
+-- 				elseif colKey == "notes" then
+-- 					return req.notes or ""
+-- 				end
+
+-- 				return tostring(req[colKey] or "")
+-- 			end
+
+-- 			-- Check fulfill eligibility
+-- 			local canFulfill, fulfillReason, itemsInBags = false, nil, 0
+-- 			local isActorBank = GBankClassic_Guild:IsBank(actor)
+-- 			if not completed and requestId and isActorBank then
+-- 				canFulfill, fulfillReason, itemsInBags = GBankClassic_Mail:CanFulfillRequest(req, actor)
+-- 			end
+-- 			local showFulfill = isActorBank and not completed and requestId
+-- 			-- Check mailbox state: flag is authoritative (set by events), frame is backup
+-- 			local mailboxOpen = GBankClassic_Mail.isOpen or (MailFrame and MailFrame:IsShown()) or false
+-- 			local fulfillEnabled = canFulfill and mailboxOpen
+
+-- 			local qtyNeeded = 0
+-- 			if req.quantity and req.fulfilled then
+-- 				qtyNeeded = (tonumber(req.quantity) or 0) - (tonumber(req.fulfilled) or 0)
+-- 			elseif req.quantity then
+-- 				qtyNeeded = tonumber(req.quantity) or 0
+-- 			end
+
+-- 			for i, col in ipairs(COLUMNS) do
+-- 				local columnWidth = (self.ColumnWidths and self.ColumnWidths[i]) or col.width
+-- 				if col.key == "actions" then
+-- 					local showComplete = canComplete and true or false
+-- 					local showCancel = canCancel and true or false
+-- 					local showDelete = canDelete and true or false
+-- 					if row and row.actionGroup then
+-- 						row.actionGroup:SetWidth(columnWidth)
+-- 					end
+-- 					-- Layout: [Fulfill] [spacer] [Complete] [spacer] [Cancel] [spacer] [Delete]
+-- 					if row and row.fulfillButton then
+-- 						setWidgetShown(row.fulfillButton, showFulfill)
+-- 					end
+-- 					if row and row.fulfillSpacer then
+-- 						setWidgetShown(row.fulfillSpacer, showFulfill and (showComplete or showCancel))
+-- 					end
+-- 					if row and row.completeButton then
+-- 						setWidgetShown(row.completeButton, showComplete)
+-- 					end
+-- 					if row and row.actionSpacer then
+-- 						setWidgetShown(row.actionSpacer, showComplete and showCancel)
+-- 					end
+-- 					if row and row.cancelButton then
+-- 						setWidgetShown(row.cancelButton, showCancel)
+-- 					end
+-- 					if row and row.deleteSpacer then
+-- 						setWidgetShown(row.deleteSpacer, showDelete and (showComplete or showCancel or showFulfill))
+-- 					end
+-- 					if row and row.deleteButton then
+-- 						setWidgetShown(row.deleteButton, showDelete)
+-- 					end
+
+-- 					-- Update fulfill button state, icon, and tooltip
+-- 					-- Don't use SetDisabled - it blocks mouse events including tooltips
+-- 					-- Instead, store disabled state and check in OnClick, use alpha for visual
+-- 					if row and row.fulfillButton and row.fulfillButton.frame then
+-- 						-- Special case: if split is needed, keep button enabled (PrepareFulfillMail will handle it)
+-- 						local needsSplit = fulfillReason and fulfillReason:find("Split")
+-- 						local buttonEnabled = fulfillEnabled or (canFulfill and mailboxOpen and needsSplit)
+-- 						row.fulfillButton.frame.gbankDisabled = not buttonEnabled
+-- 						row.fulfillButton.frame:SetAlpha(buttonEnabled and 1.0 or 0.4)
+
+-- 						-- Determine icon and tooltip based on state
+-- 						local icon, tooltipDetail
+-- 						if fulfillReason and fulfillReason:find("Split") then
+-- 							-- Split needed - show special icon (shovel)
+-- 							icon = FULFILL_ICON_NEED_SPLIT
+-- 							tooltipDetail = fulfillReason
+-- 						elseif fulfillEnabled then
+-- 							icon = FULFILL_ICON_READY
+-- 							local attachCount = math.min(itemsInBags, qtyNeeded)
+-- 							tooltipDetail = string.format("Attach %d %s to mail for %s.", attachCount, req.item or "items", req.requester or "requester")
+-- 						elseif not mailboxOpen then
+-- 							icon = FULFILL_ICON_NO_MAILBOX
+-- 							tooltipDetail = "Open a mailbox to fulfill this request."
+-- 						elseif fulfillReason and fulfillReason:find("Split") then
+-- 							-- Stack size issue
+-- 							icon = FULFILL_ICON_NEED_SPLIT
+-- 							tooltipDetail = fulfillReason
+-- 						elseif fulfillReason and fulfillReason:find("not in bags") then
+-- 							-- Items in bank but not picked up
+-- 							icon = FULFILL_ICON_NOT_IN_BAGS
+-- 							tooltipDetail = fulfillReason
+-- 						elseif fulfillReason then
+-- 							-- Other reason (no items at all, etc.)
+-- 							icon = FULFILL_ICON_NO_ITEMS
+-- 							tooltipDetail = fulfillReason
+-- 						else
+-- 							icon = FULFILL_ICON_NOT_IN_BAGS
+-- 							tooltipDetail = "Pick up items from bank first."
+-- 						end
+
+-- 						row.fulfillButton:SetText(icon)
+-- 						updateFulfillButtonTooltip(row.fulfillButton, "Fulfill request", tooltipDetail)
+-- 					end
+
+-- 					if row and row.completeButton then
+-- 						row.completeButton:SetCallback("OnClick", function()
+-- 							if not requestId then
+-- 								return
+-- 							end
+
+-- 							if not GBankClassic_Guild:CompleteRequest(requestId, actor) then
+-- 								self.Window:SetStatusText("Unable to complete request.")
+-- 							end
+-- 						end)
+-- 					end
+
+-- 					if row and row.cancelButton then
+-- 						row.cancelButton:SetCallback("OnClick", function()
+-- 							if not requestId then
+-- 								return
+-- 							end
+
+-- 							if not GBankClassic_Guild:CancelRequest(requestId, actor) then
+-- 								self.Window:SetStatusText("Unable to cancel request.")
+-- 							end
+-- 						end)
+-- 					end
+
+-- 					if row and row.deleteButton then
+-- 						row.deleteButton:SetCallback("OnClick", function()
+-- 						    if not requestId then
+-- 							    return
+-- 						    end
+
+-- 							confirmDeleteRequest(req, actor)
+-- 						end)
+-- 					end
+
+-- 					if row and row.fulfillButton then
+-- 						row.fulfillButton:SetCallback("OnClick", function()
+-- 							if not requestId then
+-- 								return
+-- 							end
+-- 							-- Check manual disabled state (we don't use SetDisabled to keep tooltips working)
+-- 							if row.fulfillButton and row.fulfillButton.frame and row.fulfillButton.frame.gbankDisabled then
+-- 								return
+-- 							end
+
+-- 							local success, message = GBankClassic_Mail:PrepareFulfillMail(req)
+-- 							self.Window:SetStatusText(message or "")
+-- 						end)
+-- 					end
+
+-- 					if row and row.actionGroup then
+-- 						row.actionGroup:DoLayout()
+-- 					end
+-- 				else
+-- 					if row and row.cells then
+-- 						local label = row.cells[i]
+-- 						label:SetText(colorize(cellText(col.key), completed))
+-- 						label:SetWidth(columnWidth)
+-- 						setWidgetShown(label, true)
+-- 					end
+-- 				end
+-- 			end
+-- 		end
+
+-- 		if self.RowPool then
+-- 			for i = count + 1, #self.RowPool do
+-- 				self:SetRowVisible(self.RowPool[i], false)
+-- 			end
+-- 		end
+-- 	end
+
+-- 	local status = string.format("%d request%s", count, count == 1 and "" or "s")
+-- 	self.Window:SetStatusText(status)
+
+-- 	content:ResumeLayout()
+-- 	content:DoLayout()
+-- end
\ No newline at end of file
diff --git a/Modules/UI/Search.lua b/Modules/UI/Search.lua
index 2454e9e..b0bf825 100644
--- a/Modules/UI/Search.lua
+++ b/Modules/UI/Search.lua
@@ -1,15 +1,279 @@
-GBankClassic_UI_Search = {}
+GBankClassic_UI_Search = GBankClassic_UI_Search or {}
 
-function GBankClassic_UI_Search:Init()
+local UI_Search = GBankClassic_UI_Search
+
+local Globals = GBankClassic_Globals
+local upvalues = Globals.GetUpvalues("GetCursorInfo", "ClearCursor", "IsShiftKeyDown", "IsControlKeyDown")
+local GetCursorInfo = upvalues.GetCursorInfo
+local ClearCursor = upvalues.ClearCursor
+local IsShiftKeyDown = upvalues.IsShiftKeyDown
+local IsControlKeyDown = upvalues.IsControlKeyDown
+local upvalues = Globals.GetUpvalues("Item")
+local Item = upvalues.Item
+
+function UI_Search:Init()
     self:DrawWindow()
 end
 
-local function OnClose(_)
-    GBankClassic_UI_Search.isOpen = false
-    GBankClassic_UI_Search.Window:Hide()
+local function onClose(_)
+    UI_Search.isOpen = false
+    UI_Search.Window:Hide()
+	-- if UI_Search.RequestDialog then
+	-- 	UI_Search.RequestDialog:Hide()
+	-- end
 end
 
-function GBankClassic_UI_Search:Toggle()
+-- -- Build (once) and show the request dialog for clicking search results
+-- function UI_Search:EnsureRequestDialog()
+-- 	if self.RequestDialog then
+-- 		return
+-- 	end
+
+-- 	local dialog = GBankClassic_UI:Create("Frame")
+-- 	dialog:Hide()
+-- 	dialog:SetTitle("Item request")
+-- 	dialog:SetLayout("List")
+-- 	dialog:SetWidth(340)
+-- 	dialog:SetHeight(200)
+-- 	dialog:EnableResize(false)
+-- 	dialog:SetCallback("OnClose", function(widget)
+-- 		widget:Hide()
+-- 	end)
+-- 	dialog.frame:SetBackdropColor(0, 0, 0, 1)
+-- 	dialog.frame:SetAlpha(1)
+-- 	if dialog.frame and dialog.frame.GetChildren then
+-- 		for _, child in ipairs({ dialog.frame:GetChildren() }) do
+-- 			-- Hide the built-in close button so we only show send/cancel actions
+-- 			if child.GetText and (child:GetText() == CLOSE or child:GetText() == "Close") then
+-- 				child:Hide()
+-- 				child:EnableMouse(false)
+-- 				break
+-- 			end
+-- 		end
+-- 	end
+
+-- 	local prompt = GBankClassic_UI:Create("Label")
+-- 	prompt:SetFullWidth(true)
+-- 	prompt:SetText("")
+-- 	prompt:SetJustifyH("LEFT")
+-- 	if prompt.label and prompt.label.SetWordWrap then
+-- 		prompt.label:SetWordWrap(true)
+-- 	end
+-- 	dialog:AddChild(prompt)
+-- 	dialog.Prompt = prompt
+
+-- 	local quantityInput = GBankClassic_UI:Create("Slider")
+-- 	quantityInput:SetLabel("Quantity")
+-- 	quantityInput:SetSliderValues(1, 1, 1)
+-- 	quantityInput:SetValue(1)
+-- 	quantityInput:SetFullWidth(true)
+-- 	if quantityInput.editbox and quantityInput.editbox.HookScript then
+-- 		quantityInput.editbox:HookScript("OnEnterPressed", function()
+-- 			self:SubmitRequest()
+-- 		end)
+-- 	end
+-- 	dialog:AddChild(quantityInput)
+-- 	dialog.QuantityInput = quantityInput
+
+-- 	local availableLabel = GBankClassic_UI:Create("Label")
+-- 	availableLabel:SetFullWidth(true)
+-- 	availableLabel:SetJustifyH("LEFT")
+-- 	availableLabel:SetText("")
+-- 	dialog:AddChild(availableLabel)
+-- 	dialog.AvailableLabel = availableLabel
+
+-- 	local buttons = GBankClassic_UI:Create("SimpleGroup")
+-- 	buttons:SetLayout("Table")
+-- 	buttons:SetUserData("table", {
+-- 		columns = {
+-- 			{ width = 0.5, align = "start" },
+-- 			{ width = 0.5, align = "end" },
+-- 		},
+-- 	})
+-- 	buttons:SetFullWidth(true)
+-- 	dialog:AddChild(buttons)
+
+-- 	local send = GBankClassic_UI:Create("Button")
+-- 	send:SetText("Send request")
+-- 	send:SetWidth(140)
+-- 	send:SetCallback("OnClick", function()
+-- 		self:SubmitRequest()
+-- 	end)
+-- 	buttons:AddChild(send)
+
+-- 	local cancel = GBankClassic_UI:Create("Button")
+-- 	cancel:SetText("Cancel")
+-- 	cancel:SetWidth(120)
+-- 	cancel:SetCallback("OnClick", function()
+-- 		dialog:Hide()
+-- 	end)
+-- 	buttons:AddChild(cancel)
+
+-- 	self.RequestDialog = dialog
+-- end
+
+-- function UI_Search:ShowRequestDialog(itemEntry, bankAlt)
+-- 	if not itemEntry or not itemEntry.Info or not bankAlt then
+-- 		return
+-- 	end
+
+-- 	self:EnsureRequestDialog()
+
+-- 	local itemName = itemEntry.Info.name or (itemEntry.Link and itemEntry.Link:match("%[(.-)%]")) or "Unknown item"
+-- 	self.requestContext = {
+-- 		item = itemEntry,
+-- 		bank = bankAlt,
+-- 		itemName = itemName,
+-- 		available = tonumber(itemEntry.Count) or 0,
+-- 	}
+
+-- 	local itemLabel = itemEntry.Link or itemName
+-- 	local prompt = string.format("Request how many %s from %s?", itemLabel, bankAlt)
+-- 	self.RequestDialog.Prompt:SetText(prompt)
+-- 	local available = self.requestContext.available
+
+--  -- Apply configured percentage limit to available quantity
+--  local maxRequestPercent = 100
+--  if GBankClassic_Options and GBankClassic_Options.GetMaxRequestPercent then
+--      maxRequestPercent = GBankClassic_Options:GetMaxRequestPercent()
+--  end
+--  local maxAllowed = math.floor(available * maxRequestPercent / 100)
+--  -- Always allow at least 1 item if any are available (handles single items like gear)
+--  if maxAllowed == 0 and available > 0 then
+--      maxAllowed = 1
+--  end
+
+--  local minQuantity = maxAllowed > 0 and 1 or 0
+--  local maxQuantity = maxAllowed > 0 and maxAllowed or 0
+-- 	if maxQuantity < minQuantity then
+-- 	 	maxQuantity = minQuantity
+-- 	end
+-- 	self.RequestDialog.QuantityInput:SetSliderValues(minQuantity, maxQuantity, 1)
+-- 	self.RequestDialog.QuantityInput:SetValue(minQuantity > 0 and 1 or 0)
+-- 	self.RequestDialog.QuantityInput:SetDisabled(maxQuantity == 0)
+-- 	if self.RequestDialog.AvailableLabel then
+-- 		if maxRequestPercent < 100 then
+--			self.RequestDialog.AvailableLabel:SetText(string.format("Available: %d (max %d%% = %d)", available, maxRequestPercent, maxAllowed))
+--      elseif available > 0 then
+-- 			self.RequestDialog.AvailableLabel:SetText(string.format("Available: %d", available))
+-- 		else
+-- 			self.RequestDialog.AvailableLabel:SetText("Available: none right now")
+-- 		end
+-- 	end
+-- 	self.RequestDialog:SetStatusText("")
+-- 	if self.Window and self.Window.frame and self.RequestDialog.frame then
+-- 		self.RequestDialog.frame:ClearAllPoints()
+-- 		self.RequestDialog.frame:SetPoint("TOPRIGHT", self.Window.frame, "TOPLEFT", -10, 0)
+-- 	end
+-- 	self.RequestDialog:Show()
+-- 	self.RequestDialog:DoLayout()
+-- 	if self.RequestDialog.QuantityInput.editbox and self.RequestDialog.QuantityInput.editbox.SetFocus then
+-- 		self.RequestDialog.QuantityInput.editbox:SetFocus()
+-- 		self.RequestDialog.QuantityInput.editbox:HighlightText()
+-- 	end
+-- end
+
+-- function UI_Search:SubmitRequest()
+-- 	if not self.requestContext or not self.RequestDialog then
+-- 		return
+-- 	end
+
+-- 	local quantityInput = self.RequestDialog.QuantityInput
+-- 	if quantityInput and quantityInput.editbox and quantityInput.editbox.GetText then
+-- 		local text = quantityInput.editbox:GetText()
+-- 		if text and text ~= "" then
+-- 			local typed = tonumber(text) or tonumber(text:match("%d+"))
+-- 			if typed then
+-- 				local minValue = tonumber(quantityInput.min)
+-- 				local maxValue = tonumber(quantityInput.max)
+-- 				if minValue and typed < minValue then
+-- 					typed = minValue
+-- 				end
+-- 				if maxValue and typed > maxValue then
+-- 					typed = maxValue
+-- 				end
+-- 				local step = tonumber(quantityInput.step)
+-- 				if step and step > 0 and minValue then
+-- 					typed = math.floor((typed - minValue) / step + 0.5) * step + minValue
+-- 				end
+-- 				quantityInput:SetValue(typed)
+-- 			end
+-- 		end
+-- 	end
+
+-- 	local quantity = tonumber(quantityInput and quantityInput:GetValue())
+-- 	local available = tonumber(self.requestContext.available) or 0
+
+--	-- Apply configured percentage limit to available quantity
+--	local maxRequestPercent = 100
+--	if GBankClassic_Options and GBankClassic_Options.GetMaxRequestPercent then
+--		maxRequestPercent = GBankClassic_Options:GetMaxRequestPercent()
+--	end
+--	local maxAllowed = math.floor(available * maxRequestPercent / 100)
+--	-- Always allow at least 1 item if any are available (handles single items like gear)
+--	if maxAllowed == 0 and available > 0 then
+--		maxAllowed = 1
+--	end
+
+-- 	if not quantity or quantity <= 0 then
+-- 		self.RequestDialog:SetStatusText("Enter a quantity greater than 0.")
+
+-- 		return
+-- 	end
+--	if quantity > maxAllowed then
+--		if maxAllowed <= 0 then
+--			if maxRequestPercent < 100 then
+--				self.RequestDialog:SetStatusText(string.format("Cannot request - max allowed is %d%% of %d = 0 items.", maxRequestPercent, available))
+--			else
+--				self.RequestDialog:SetStatusText("Cannot request - none available right now.")
+--			end
+
+--			return
+--		else
+--			if maxRequestPercent < 100 then
+--				self.RequestDialog:SetStatusText(string.format("Reduced to max allowed: %d items (%d%% of %d available)", maxAllowed, maxRequestPercent, available))
+--			else
+--				self.RequestDialog:SetStatusText(string.format("Reduced to available: %d", maxAllowed))
+--			end
+--			quantity = maxAllowed
+--			-- Don't return - allow the clamped request to proceed
+--		end
+--	end
+
+-- 	local requester = GBankClassic_Guild:GetNormalizedPlayer()
+-- 	if not requester then
+-- 		local name, realm = UnitName("player"), GetNormalizedRealmName()
+-- 		if name then
+-- 			requester = realm and (name .. "-" .. realm) or name
+-- 			requester = GBankClassic_Guild:NormalizeName(requester)
+-- 		end
+-- 	end
+
+-- 	local bank = GBankClassic_Guild:NormalizeName(self.requestContext.bank)
+
+-- 	local request = {
+-- 		date = GetServerTime(),
+-- 		requester = requester or "Unknown",
+-- 		bank = bank or self.requestContext.bank,
+-- 		item = self.requestContext.itemName,
+-- 		quantity = quantity,
+-- 		fulfilled = 0,
+-- 		notes = "",
+-- 	}
+
+-- 	if not GBankClassic_Guild:AddRequest(request) then
+-- 		self.RequestDialog:SetStatusText("Unable to send request.")
+
+-- 		return
+-- 	end
+
+-- 	self.RequestDialog:Hide()
+-- 	self.requestContext = nil
+
+-- 	GBankClassic_Output:Response("Requested %d x %s from %s", quantity, request.item, request.bank)
+-- end
+
+function UI_Search:Toggle()
     if self.isOpen then
         self:Close()
     else
@@ -17,7 +281,7 @@ function GBankClassic_UI_Search:Toggle()
     end
 end
 
-function GBankClassic_UI_Search:Open()
+function UI_Search:Open()
 	if self.isOpen then
 		return
 	end
@@ -28,6 +292,13 @@ function GBankClassic_UI_Search:Open()
         self:DrawWindow()
     end
 
+	-- Build search data only when search UI is opened
+	-- Performed here to avoid blocking initial window open
+	if not self.searchDataBuilt then
+		self:BuildSearchData()
+		self.searchDataBuilt = true
+	end
+
     self.Window:Show()
     if GBankClassic_UI_Inventory.isOpen and GBankClassic_UI_Inventory.Window then
         self.Window:ClearAllPoints()
@@ -45,30 +316,36 @@ function GBankClassic_UI_Search:Open()
     end
 end
 
-function GBankClassic_UI_Search:Close()
+function UI_Search:Close()
 	if not self.isOpen then
 		return
 	end
-
 	if not self.Window then
 		return
 	end
 
-    OnClose(self.Window)
+    onClose(self.Window)
 
     if GBankClassic_UI_Inventory.isOpen == false then
         _G["GBankClassic"]:Hide()
     end
 end
 
-function GBankClassic_UI_Search:DrawWindow()
+function UI_Search:DrawWindow()
     local searchWindow = GBankClassic_UI:Create("Frame")
     searchWindow:Hide()
-    searchWindow:SetCallback("OnClose", OnClose)
+    searchWindow:SetCallback("OnClose", onClose)
     searchWindow:SetTitle("Search")
     searchWindow:SetLayout("Flow")
-    searchWindow:SetWidth(250)
     searchWindow:EnableResize(false)
+
+	-- Persist window position/size across reloads
+	if GBankClassic_Options and GBankClassic_Options.db then
+		searchWindow:SetStatusTable(GBankClassic_Options.db.char.framePositions)
+	end
+
+	-- Set width after SetStatusTable to override any saved width
+    searchWindow:SetWidth(250)
     self.Window = searchWindow
 
     local searchInput = GBankClassic_UI:Create("EditBox")
@@ -130,7 +407,8 @@ function GBankClassic_UI_Search:DrawWindow()
     self.Results = resultGroup
 end
 
-function GBankClassic_UI_Search:BuildSearchData()
+function UI_Search:BuildSearchData()
+	GBankClassic_Output:Debug("SEARCH", "BuildSearchData called - clearing and rebuilding search data")
     self.SearchData = {
         Corpus = {},
         Lookup = {},
@@ -139,56 +417,128 @@ function GBankClassic_UI_Search:BuildSearchData()
     local info = GBankClassic_Guild.Info
 	local roster_alts = GBankClassic_Guild:GetRosterAlts()
 	if not info or not roster_alts then
+		GBankClassic_Output:Debug("SEARCH", "BuildSearchData: no info or roster_alts, returning early")
+
 		return
 	end
 
+	local rosterCount = GBankClassic_Globals:Count(roster_alts)
+	GBankClassic_Output:Debug("SEARCH", "BuildSearchData: processing %d roster alts", rosterCount)
+
     local items = {}
 	for _, player in pairs(roster_alts) do
 		local norm = GBankClassic_Guild:NormalizeName(player)
         local alt = info.alts[norm]
-        if alt and _G.type(alt) == "table" then
-            if alt.bank and alt.bank.items then
-                items = GBankClassic_Item:Aggregate(items, alt.bank.items)
-            end
-            if alt.bags and alt.bags.items then
-                items = GBankClassic_Item:Aggregate(items, alt.bags.items)
-            end
+		GBankClassic_Output:Debug("SEARCH", "Search corpus loop: processing player=%s, norm=%s, has alt=%s", player, norm, tostring(alt ~= nil))
+        if alt and type(alt) == "table" then
+			-- Use alt.items if available (aggregated format)
+			if alt.items and next(alt.items) ~= nil then
+				-- Use alt.items which includes bank+bags+mail
+				local beforeCount = #items
+				items = GBankClassic_Item:Aggregate(items, alt.items)
+				local afterCount = #items
+				GBankClassic_Output:Debug("SEARCH", "Search corpus: using alt.items for %s (%d items before, %d after aggregation)", player, beforeCount, afterCount)
+			else
+				-- Fallback: aggregate from sources for backward compatibility
+				if alt.bank then
+					items = GBankClassic_Item:Aggregate(items, alt.bank.items)
+				end
+				if alt.bags then
+					items = GBankClassic_Item:Aggregate(items, alt.bags.items)
+				end
+				-- Include mail items (now in array format like bank/bags)
+				if alt.mail and alt.mail.items then
+					local mailItemCount = GBankClassic_Globals:Count(alt.mail.items)
+					GBankClassic_Output:Debug("SEARCH", "Search corpus: aggregating mail for %s (%d unique items)", player, mailItemCount)
+					-- Mail items are now in array format, not key-value
+					items = GBankClassic_Item:Aggregate(items, alt.mail.items)
+				end
+			end
         end
     end
 
     local itemNames = {}
-    GBankClassic_Item:GetItems(items, function(list)
+	local corpusNamesSeen = {}
+	
+	-- Count items in hash table
+	local itemCount = GBankClassic_Globals:Count(items)
+	GBankClassic_Output:Debug("SEARCH", "About to validate %d items before GetItems", itemCount)
+	
+	-- Validate and filter items before passing to GetItems
+	local validItems = {}
+	local invalidCount = 0
+	for key, item in pairs(items) do
+		if item and item.ID and item.ID > 0 then
+			table.insert(validItems, item)
+		else
+			invalidCount = invalidCount + 1
+			GBankClassic_Output:Debug("SEARCH", "WARNING: Skipping invalid item at key %s (ID: %s, link: %s)", tostring(key), tostring(item and item.ID or "nil item"), tostring(item and item.Link or "nil"))
+		end
+	end
+	
+	GBankClassic_Output:Debug("SEARCH", "Passing %d valid items to GetItems (%d invalid skipped)", #validItems, invalidCount)
+	
+	GBankClassic_Item:GetItems(validItems, function(list)
         for _, v in pairs(list) do
             -- Skip malformed list entries
-            if v and v.ID and v.Info and v.Info.name and not itemNames[v.ID] then
-                table.insert(self.SearchData.Corpus, v.Info.name)
-                itemNames[v.ID] = v.Info.name
-            end
+			if v and v.ID and v.Info and v.Info.name then
+				-- Map item ID to name (for lookup table building later)
+				if not itemNames[v.ID] then
+					itemNames[v.ID] = v.Info.name
+				end
+				-- Only add each unique name to corpus once
+				if not corpusNamesSeen[v.Info.name] then
+					corpusNamesSeen[v.Info.name] = true
+					table.insert(self.SearchData.Corpus, v.Info.name)
+					GBankClassic_Output:Debug("SEARCH", "Corpus: added unique name '%s' (ID: %d)", v.Info.name, v.ID)
+				else
+					GBankClassic_Output:Debug("SEARCH", "Corpus: skipping duplicate name '%s' (ID: %d already in corpus)", v.Info.name, v.ID)
+				end
+			end
         end
 
 		for _, player in pairs(roster_alts) do
             local altItems = {}
 			local norm = GBankClassic_Guild:NormalizeName(player)
             local alt = info.alts[norm]
-            if alt and _G.type(alt) == "table" then
-                if alt.bank and alt.bank.items then
-                    altItems = GBankClassic_Item:Aggregate(altItems, alt.bank.items)
-                end
-                if alt.bags and alt.bags.items then
-                    altItems = GBankClassic_Item:Aggregate(altItems, alt.bags.items)
-                end
+			GBankClassic_Output:Debug("SEARCH", "Search results loop: processing player=%s, norm=%s, has alt=%s", player, norm, tostring(alt ~= nil))
+            if alt and type(alt) == "table" then
+				-- Use alt.items if available (aggregated format)
+				if alt.items and next(alt.items) ~= nil then
+				    -- Use alt.items which includes bank+bags+mail
+					for _, item in pairs(alt.items) do
+						table.insert(altItems, item)
+					end
+					GBankClassic_Output:Debug("SEARCH", "Search results: using alt.items for %s", player)
+				else
+					-- Fallback: aggregate from sources for backward compatibility
+					if alt.bank then
+						altItems = GBankClassic_Item:Aggregate(altItems, alt.bank.items)
+					end
+					if alt.bags then
+						altItems = GBankClassic_Item:Aggregate(altItems, alt.bags.items)
+					end
+					-- Include mail items (now in array format like bank/bags)
+					if alt.mail and alt.mail.items then
+						GBankClassic_Output:Debug("SEARCH", "Search results: aggregating mail for %s (%d unique items)", player, #alt.mail.items)
+						-- Mail items are now in array format, not key-value
+						altItems = GBankClassic_Item:Aggregate(altItems, alt.mail.items)
+					end
+				end
             end
 
             for _, itemEntry in pairs(altItems) do
                 local name = itemNames[itemEntry.ID]
                 if name then
+					GBankClassic_Output:Debug("SEARCH", "Search results: adding %s with count %d for player %s to lookup", name, itemEntry.Count or 0, player)
                     if not self.SearchData.Lookup[name] then
                         self.SearchData.Lookup[name] = {}
                     end
                     local found = false
                     for _, existingEntry in pairs(self.SearchData.Lookup[name]) do
-                        if existingEntry.alt == player then
+						if existingEntry.alt == player and existingEntry.item.ID == itemEntry.ID then
                             found = true
+							GBankClassic_Output:Debug("SEARCH", "Search results: duplicate found - skipping %s (ID: %d) for %s", name, itemEntry.ID, player)
                             break
                         end
                     end
@@ -202,7 +552,7 @@ function GBankClassic_UI_Search:BuildSearchData()
     end)
 end
 
-function GBankClassic_UI_Search:DrawContent()
+function UI_Search:DrawContent()
 	if not self.Results then
 		return
 	end
@@ -225,7 +575,7 @@ function GBankClassic_UI_Search:DrawContent()
     if search and string.sub(search, 0, 2) == "|c" then
         self.searchField:SetText("")
         local item = Item:CreateFromItemLink(search)
-		if item then
+		if item and item.itemID then
 			item:ContinueOnItemLoad(function()
 				local name = item:GetItemName()
 				if name then
@@ -252,22 +602,58 @@ function GBankClassic_UI_Search:DrawContent()
 		return
 	end
 
+	GBankClassic_Output:Debug("SEARCH", "Search for '%s': Corpus has %d entries", searchText, #searchData.Corpus)
+
     local count = 0
+	local matchedNames = 0
     for _, v in pairs(searchData.Corpus) do
         if not v then
             -- Skip malformed corpus entries
         else
             local result = string.find(v:lower(), searchText)
             if result ~= nil then
+				matchedNames = matchedNames + 1
+				GBankClassic_Output:Debug("SEARCH", "Match #%d: '%s' contains '%s'", matchedNames, v, searchText)
                 local lookupList = searchData.Lookup[v]
                 if not lookupList then
                     -- No lookup for this name; skip
+					GBankClassic_Output:Debug("SEARCH", "Search display: '%s' matched search but has NO lookup entries", v)
                 else
+					local lookupCount = GBankClassic_Globals:Count(lookupList)
+					GBankClassic_Output:Debug("SEARCH", "Search display: '%s' matched search, has %d lookup entries", v, lookupCount)
                     for _, vv in pairs(lookupList) do
-                        GBankClassic_UI:DrawItem(vv.item, self.Results, 30, 35, 30, 30, 0, 5)
+						local resultItem = vv.item
+						local bankAlt = vv.alt
+						GBankClassic_Output:Debug("SEARCH", "Search display: showing %s with %d items for %s",
+							resultItem.Info and resultItem.Info.name or "Unknown", resultItem.Count or 0, bankAlt)
+						local itemWidget = GBankClassic_UI:DrawItem(resultItem, self.Results, 30, 35, 30, 30, 0, 5)
+						if itemWidget then
+							itemWidget:SetCallback("OnClick", function(widget, event)
+								if IsShiftKeyDown() or IsControlKeyDown() then
+									GBankClassic_UI:EventHandler(widget, event)
+
+									return
+								end
+                                
+								-- self:ShowRequestDialog(resultItem, bankAlt)
+							end)
+						end
 
                         local label = GBankClassic_UI:Create("Label")
-                        label:SetText(vv.alt)
+                        -- Check if item is in mail (mail.items is an array)
+                        local norm = GBankClassic_Guild:NormalizeName(bankAlt)
+                        local alt = GBankClassic_Guild.Info and GBankClassic_Guild.Info.alts and GBankClassic_Guild.Info.alts[norm]
+                        local inMail = false
+                        if alt and alt.mail and alt.mail.items then
+                            for _, item in ipairs(alt.mail.items) do
+                                if item.ID == resultItem.ID then
+                                    inMail = true
+                                    break
+                                end
+                            end
+                        end					
+                        local mailIcon = inMail and " \124TInterface\\MailFrame\\UI-MailIcon-Up:16:16\124t" or ""	
+                        label:SetText(bankAlt .. mailIcon)
                         label.label:SetSize(100, 30)
                         label.label:SetJustifyV("MIDDLE")
                         self.Results:AddChild(label)
@@ -279,6 +665,8 @@ function GBankClassic_UI_Search:DrawContent()
         end
     end
 
+	GBankClassic_Output:Debug("SEARCH", "Search complete: matched %d names, displayed %d result widgets", matchedNames, count)
+
     local status = count .. " Result"
     if count > 1 then
         status = status .. "s"
